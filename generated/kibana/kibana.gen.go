// Package kibana provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package kibana

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

const (
	BasicAuthScopes = "basicAuth.Scopes"
)

// Defines values for AgentPolicyMonitoringEnabled.
const (
	AgentPolicyMonitoringEnabledLogs    AgentPolicyMonitoringEnabled = "logs"
	AgentPolicyMonitoringEnabledMetrics AgentPolicyMonitoringEnabled = "metrics"
)

// Defines values for AgentPolicyCreateRequestMonitoringEnabled.
const (
	AgentPolicyCreateRequestMonitoringEnabledLogs    AgentPolicyCreateRequestMonitoringEnabled = "logs"
	AgentPolicyCreateRequestMonitoringEnabledMetrics AgentPolicyCreateRequestMonitoringEnabled = "metrics"
)

// Defines values for AgentPolicyUpdateRequestMonitoringEnabled.
const (
	Logs    AgentPolicyUpdateRequestMonitoringEnabled = "logs"
	Metrics AgentPolicyUpdateRequestMonitoringEnabled = "metrics"
)

// Defines values for Aggtype.
const (
	AggtypeAvg   Aggtype = "avg"
	AggtypeCount Aggtype = "count"
	AggtypeMax   Aggtype = "max"
	AggtypeMin   Aggtype = "min"
	AggtypeSum   Aggtype = "sum"
)

// Defines values for BudgetingMethod.
const (
	Occurrences BudgetingMethod = "occurrences"
	Timeslices  BudgetingMethod = "timeslices"
)

// Defines values for CreateAnomalyDetectionAlertRuleRequestRuleTypeId.
const (
	XpackMlAnomalyDetectionAlert CreateAnomalyDetectionAlertRuleRequestRuleTypeId = "xpack.ml.anomaly_detection_alert"
)

// Defines values for CreateAnomalyDetectionJobsHealthRuleRequestRuleTypeId.
const (
	XpackMlAnomalyDetectionJobsHealth CreateAnomalyDetectionJobsHealthRuleRequestRuleTypeId = "xpack.ml.anomaly_detection_jobs_health"
)

// Defines values for CreateApmAnomalyRuleRequestRuleTypeId.
const (
	ApmAnomaly CreateApmAnomalyRuleRequestRuleTypeId = "apm.anomaly"
)

// Defines values for CreateApmErrorCountRuleRequestRuleTypeId.
const (
	ApmErrorRate CreateApmErrorCountRuleRequestRuleTypeId = "apm.error_rate"
)

// Defines values for CreateApmTransactionDurationRuleRequestRuleTypeId.
const (
	ApmTransactionDuration CreateApmTransactionDurationRuleRequestRuleTypeId = "apm.transaction_duration"
)

// Defines values for CreateApmTransactionErrorRateRuleRequestRuleTypeId.
const (
	ApmTransactionErrorRate CreateApmTransactionErrorRateRuleRequestRuleTypeId = "apm.transaction_error_rate"
)

// Defines values for CreateEsQueryRuleRequestRuleTypeId.
const (
	DotEsQuery CreateEsQueryRuleRequestRuleTypeId = ".es-query"
)

// Defines values for CreateGeoContainmentRuleRequestRuleTypeId.
const (
	DotGeoContainment CreateGeoContainmentRuleRequestRuleTypeId = ".geo-containment"
)

// Defines values for CreateIndexThresholdRuleRequestRuleTypeId.
const (
	DotIndexThreshold CreateIndexThresholdRuleRequestRuleTypeId = ".index-threshold"
)

// Defines values for CreateInfraInventoryRuleRequestRuleTypeId.
const (
	MetricsAlertInventoryThreshold CreateInfraInventoryRuleRequestRuleTypeId = "metrics.alert.inventory.threshold"
)

// Defines values for CreateInfraMetricAnomalyRuleRequestRuleTypeId.
const (
	MetricsAlertAnomaly CreateInfraMetricAnomalyRuleRequestRuleTypeId = "metrics.alert.anomaly"
)

// Defines values for CreateInfraMetricThresholdRuleRequestRuleTypeId.
const (
	MetricsAlertThreshold CreateInfraMetricThresholdRuleRequestRuleTypeId = "metrics.alert.threshold"
)

// Defines values for CreateLogThresholdRuleRequestRuleTypeId.
const (
	LogsAlertDocumentCount CreateLogThresholdRuleRequestRuleTypeId = "logs.alert.document.count"
)

// Defines values for CreateMonitoringCcrExceptionsRuleRequestRuleTypeId.
const (
	MonitoringCcrReadExceptions CreateMonitoringCcrExceptionsRuleRequestRuleTypeId = "monitoring_ccr_read_exceptions"
)

// Defines values for CreateMonitoringClusterHealthRuleRequestRuleTypeId.
const (
	MonitoringAlertClusterHealth CreateMonitoringClusterHealthRuleRequestRuleTypeId = "monitoring_alert_cluster_health"
)

// Defines values for CreateMonitoringCpuUsageRuleRequestRuleTypeId.
const (
	MonitoringAlertCpuUsage CreateMonitoringCpuUsageRuleRequestRuleTypeId = "monitoring_alert_cpu_usage"
)

// Defines values for CreateMonitoringDiskUsageRuleRequestRuleTypeId.
const (
	MonitoringAlertDiskUsage CreateMonitoringDiskUsageRuleRequestRuleTypeId = "monitoring_alert_disk_usage"
)

// Defines values for CreateMonitoringElasticsearchVersionMismatchRuleRequestRuleTypeId.
const (
	MonitoringAlertElasticsearchVersionMismatch CreateMonitoringElasticsearchVersionMismatchRuleRequestRuleTypeId = "monitoring_alert_elasticsearch_version_mismatch"
)

// Defines values for CreateMonitoringJvmMemoryUsageRuleRequestRuleTypeId.
const (
	MonitoringAlertJvmMemoryUsage CreateMonitoringJvmMemoryUsageRuleRequestRuleTypeId = "monitoring_alert_jvm_memory_usage"
)

// Defines values for CreateMonitoringKibanaVersionMismatchRuleRequestRuleTypeId.
const (
	MonitoringAlertKibanaVersionMismatch CreateMonitoringKibanaVersionMismatchRuleRequestRuleTypeId = "monitoring_alert_kibana_version_mismatch"
)

// Defines values for CreateMonitoringLicenseExpirationRuleRequestRuleTypeId.
const (
	MonitoringAlertLicenseExpiration CreateMonitoringLicenseExpirationRuleRequestRuleTypeId = "monitoring_alert_license_expiration"
)

// Defines values for CreateMonitoringLogstashVersionMismatchRuleRequestRuleTypeId.
const (
	MonitoringAlertLogstashVersionMismatch CreateMonitoringLogstashVersionMismatchRuleRequestRuleTypeId = "monitoring_alert_logstash_version_mismatch"
)

// Defines values for CreateMonitoringMissingDataRuleRequestRuleTypeId.
const (
	MonitoringAlertMissingMonitoringData CreateMonitoringMissingDataRuleRequestRuleTypeId = "monitoring_alert_missing_monitoring_data"
)

// Defines values for CreateMonitoringNodesChangedRuleRequestRuleTypeId.
const (
	MonitoringAlertNodesChanged CreateMonitoringNodesChangedRuleRequestRuleTypeId = "monitoring_alert_nodes_changed"
)

// Defines values for CreateMonitoringShardSizeRuleRequestRuleTypeId.
const (
	MonitoringShardSize CreateMonitoringShardSizeRuleRequestRuleTypeId = "monitoring_shard_size"
)

// Defines values for CreateMonitoringThreadPoolSearchRejectionsRuleRequestRuleTypeId.
const (
	MonitoringAlertThreadPoolSearchRejections CreateMonitoringThreadPoolSearchRejectionsRuleRequestRuleTypeId = "monitoring_alert_thread_pool_search_rejections"
)

// Defines values for CreateMonitoringThreadPoolWriteRejectionsRuleRequestRuleTypeId.
const (
	MonitoringAlertThreadPoolWriteRejections CreateMonitoringThreadPoolWriteRejectionsRuleRequestRuleTypeId = "monitoring_alert_thread_pool_write_rejections"
)

// Defines values for CreateSiemEqlRuleRequestRuleTypeId.
const (
	SiemEqlRule CreateSiemEqlRuleRequestRuleTypeId = "siem.eqlRule"
)

// Defines values for CreateSiemIndicatorRuleRequestRuleTypeId.
const (
	SiemIndicatorRule CreateSiemIndicatorRuleRequestRuleTypeId = "siem.indicatorRule"
)

// Defines values for CreateSiemMlRuleRequestRuleTypeId.
const (
	SiemMlRule CreateSiemMlRuleRequestRuleTypeId = "siem.mlRule"
)

// Defines values for CreateSiemNewTermsRuleRequestRuleTypeId.
const (
	SiemNewTermsRule CreateSiemNewTermsRuleRequestRuleTypeId = "siem.newTermsRule"
)

// Defines values for CreateSiemNotificationsRuleRequestRuleTypeId.
const (
	SiemNotifications CreateSiemNotificationsRuleRequestRuleTypeId = "siem.notifications"
)

// Defines values for CreateSiemQueryRuleRequestRuleTypeId.
const (
	SiemQueryRule CreateSiemQueryRuleRequestRuleTypeId = "siem.queryRule"
)

// Defines values for CreateSiemSavedQueryRuleRequestRuleTypeId.
const (
	SiemSavedQueryRule CreateSiemSavedQueryRuleRequestRuleTypeId = "siem.savedQueryRule"
)

// Defines values for CreateSiemThresholdRuleRequestRuleTypeId.
const (
	SiemThresholdRule CreateSiemThresholdRuleRequestRuleTypeId = "siem.thresholdRule"
)

// Defines values for CreateSloBurnRateRuleRequestRuleTypeId.
const (
	SloRulesBurnRate CreateSloBurnRateRuleRequestRuleTypeId = "slo.rules.burnRate"
)

// Defines values for CreateSyntheticsMonitorStatusRuleRequestRuleTypeId.
const (
	XpackSyntheticsAlertsMonitorStatus CreateSyntheticsMonitorStatusRuleRequestRuleTypeId = "xpack.synthetics.alerts.monitorStatus"
)

// Defines values for CreateSyntheticsUptimeDurationAnomalyRuleRequestRuleTypeId.
const (
	XpackUptimeAlertsDurationAnomaly CreateSyntheticsUptimeDurationAnomalyRuleRequestRuleTypeId = "xpack.uptime.alerts.durationAnomaly"
)

// Defines values for CreateSyntheticsUptimeTlsCertificateRuleRequestRuleTypeId.
const (
	XpackUptimeAlertsTlsCertificate CreateSyntheticsUptimeTlsCertificateRuleRequestRuleTypeId = "xpack.uptime.alerts.tlsCertificate"
)

// Defines values for CreateSyntheticsUptimeTlsRuleRequestRuleTypeId.
const (
	XpackUptimeAlertsTls CreateSyntheticsUptimeTlsRuleRequestRuleTypeId = "xpack.uptime.alerts.tls"
)

// Defines values for CreateTransformHealthRuleRequestRuleTypeId.
const (
	TransformHealth CreateTransformHealthRuleRequestRuleTypeId = "transform_health"
)

// Defines values for CreateUptimeMonitorStatusRuleRequestRuleTypeId.
const (
	XpackUptimeAlertsMonitorStatus CreateUptimeMonitorStatusRuleRequestRuleTypeId = "xpack.uptime.alerts.monitorStatus"
)

// Defines values for ElasticsearchAssetType.
const (
	ComponentTemplate   ElasticsearchAssetType = "component_template"
	DataStreamIlmPolicy ElasticsearchAssetType = "data_stream_ilm_policy"
	IlmPolicy           ElasticsearchAssetType = "ilm_policy"
	IndexTemplate       ElasticsearchAssetType = "index_template"
	IngestPipeline      ElasticsearchAssetType = "ingest_pipeline"
	Transform           ElasticsearchAssetType = "transform"
)

// Defines values for Groupby.
const (
	All Groupby = "all"
	Top Groupby = "top"
)

// Defines values for IndicatorPropertiesCustomMetricParamsGoodMetricsAggregation.
const (
	IndicatorPropertiesCustomMetricParamsGoodMetricsAggregationSum IndicatorPropertiesCustomMetricParamsGoodMetricsAggregation = "sum"
)

// Defines values for IndicatorPropertiesCustomMetricParamsTotalMetricsAggregation.
const (
	IndicatorPropertiesCustomMetricParamsTotalMetricsAggregationSum IndicatorPropertiesCustomMetricParamsTotalMetricsAggregation = "sum"
)

// Defines values for IndicatorPropertiesHistogramParamsGoodAggregation.
const (
	IndicatorPropertiesHistogramParamsGoodAggregationRange      IndicatorPropertiesHistogramParamsGoodAggregation = "range"
	IndicatorPropertiesHistogramParamsGoodAggregationValueCount IndicatorPropertiesHistogramParamsGoodAggregation = "value_count"
)

// Defines values for IndicatorPropertiesHistogramParamsTotalAggregation.
const (
	IndicatorPropertiesHistogramParamsTotalAggregationRange      IndicatorPropertiesHistogramParamsTotalAggregation = "range"
	IndicatorPropertiesHistogramParamsTotalAggregationValueCount IndicatorPropertiesHistogramParamsTotalAggregation = "value_count"
)

// Defines values for IndicatorPropertiesTimesliceMetricParamsMetricComparator.
const (
	GT  IndicatorPropertiesTimesliceMetricParamsMetricComparator = "GT"
	GTE IndicatorPropertiesTimesliceMetricParamsMetricComparator = "GTE"
	LT  IndicatorPropertiesTimesliceMetricParamsMetricComparator = "LT"
	LTE IndicatorPropertiesTimesliceMetricParamsMetricComparator = "LTE"
)

// Defines values for InstallationInfoInstallSource.
const (
	InstallationInfoInstallSourceBundled  InstallationInfoInstallSource = "bundled"
	InstallationInfoInstallSourceRegistry InstallationInfoInstallSource = "registry"
	InstallationInfoInstallSourceUpload   InstallationInfoInstallSource = "upload"
)

// Defines values for InstallationInfoInstallStatus.
const (
	InstallationInfoInstallStatusInstallFailed InstallationInfoInstallStatus = "install_failed"
	InstallationInfoInstallStatusInstalled     InstallationInfoInstallStatus = "installed"
	InstallationInfoInstallStatusInstalling    InstallationInfoInstallStatus = "installing"
)

// Defines values for InstallationInfoLatestExecutedStateName.
const (
	CreateRestartInstallation       InstallationInfoLatestExecutedStateName = "create_restart_installation"
	DeletePreviousPipelines         InstallationInfoLatestExecutedStateName = "delete_previous_pipelines"
	InstallIlmPolicies              InstallationInfoLatestExecutedStateName = "install_ilm_policies"
	InstallIndexTemplatePipelines   InstallationInfoLatestExecutedStateName = "install_index_template_pipelines"
	InstallKibanaAssets             InstallationInfoLatestExecutedStateName = "install_kibana_assets"
	InstallMlModel                  InstallationInfoLatestExecutedStateName = "install_ml_model"
	InstallTransforms               InstallationInfoLatestExecutedStateName = "install_transforms"
	RemoveLegacyTemplates           InstallationInfoLatestExecutedStateName = "remove_legacy_templates"
	SaveArchiveEntriesFromAssetsMap InstallationInfoLatestExecutedStateName = "save_archive_entries_from_assets_map"
	UpdateCurrentWriteIndices       InstallationInfoLatestExecutedStateName = "update_current_write_indices"
	UpdateSo                        InstallationInfoLatestExecutedStateName = "update_so"
)

// Defines values for InstallationInfoVerificationStatus.
const (
	Unknown    InstallationInfoVerificationStatus = "unknown"
	Unverified InstallationInfoVerificationStatus = "unverified"
	Verified   InstallationInfoVerificationStatus = "verified"
)

// Defines values for KibanaSavedObjectType.
const (
	CspRuleTemplate KibanaSavedObjectType = "csp_rule_template"
	Dashboard       KibanaSavedObjectType = "dashboard"
	IndexPattern    KibanaSavedObjectType = "index-pattern"
	Lens            KibanaSavedObjectType = "lens"
	Map             KibanaSavedObjectType = "map"
	MlModule        KibanaSavedObjectType = "ml-module"
	Search          KibanaSavedObjectType = "search"
	SecurityRule    KibanaSavedObjectType = "security-rule"
	Visualization   KibanaSavedObjectType = "visualization"
)

// Defines values for NotifyWhen.
const (
	NotifyWhenOnActionGroupChange NotifyWhen = "onActionGroupChange"
	NotifyWhenOnActiveAlert       NotifyWhen = "onActiveAlert"
	NotifyWhenOnThrottleInterval  NotifyWhen = "onThrottleInterval"
)

// Defines values for NotifyWhenAction.
const (
	NotifyWhenActionOnActionGroupChange NotifyWhenAction = "onActionGroupChange"
	NotifyWhenActionOnActiveAlert       NotifyWhenAction = "onActiveAlert"
	NotifyWhenActionOnThrottleInterval  NotifyWhenAction = "onThrottleInterval"
)

// Defines values for OutputCreateRequestElasticsearchPreset.
const (
	OutputCreateRequestElasticsearchPresetBalanced   OutputCreateRequestElasticsearchPreset = "balanced"
	OutputCreateRequestElasticsearchPresetCustom     OutputCreateRequestElasticsearchPreset = "custom"
	OutputCreateRequestElasticsearchPresetLatency    OutputCreateRequestElasticsearchPreset = "latency"
	OutputCreateRequestElasticsearchPresetScale      OutputCreateRequestElasticsearchPreset = "scale"
	OutputCreateRequestElasticsearchPresetThroughput OutputCreateRequestElasticsearchPreset = "throughput"
)

// Defines values for OutputCreateRequestElasticsearchType.
const (
	OutputCreateRequestElasticsearchTypeElasticsearch OutputCreateRequestElasticsearchType = "elasticsearch"
)

// Defines values for OutputCreateRequestKafkaConnectionType.
const (
	OutputCreateRequestKafkaConnectionTypeEncryption OutputCreateRequestKafkaConnectionType = "encryption"
	OutputCreateRequestKafkaConnectionTypePlaintext  OutputCreateRequestKafkaConnectionType = "plaintext"
)

// Defines values for OutputCreateRequestKafkaSslVerificationMode.
const (
	OutputCreateRequestKafkaSslVerificationModeCertificate OutputCreateRequestKafkaSslVerificationMode = "certificate"
	OutputCreateRequestKafkaSslVerificationModeFull        OutputCreateRequestKafkaSslVerificationMode = "full"
	OutputCreateRequestKafkaSslVerificationModeNone        OutputCreateRequestKafkaSslVerificationMode = "none"
	OutputCreateRequestKafkaSslVerificationModeStrict      OutputCreateRequestKafkaSslVerificationMode = "strict"
)

// Defines values for OutputCreateRequestKafkaType.
const (
	OutputCreateRequestKafkaTypeKafka OutputCreateRequestKafkaType = "kafka"
)

// Defines values for OutputCreateRequestLogstashType.
const (
	OutputCreateRequestLogstashTypeLogstash OutputCreateRequestLogstashType = "logstash"
)

// Defines values for OutputCreateRequestRemoteElasticsearchType.
const (
	RemoteElasticsearch OutputCreateRequestRemoteElasticsearchType = "remote_elasticsearch"
)

// Defines values for OutputUpdateRequestElasticsearchPreset.
const (
	OutputUpdateRequestElasticsearchPresetBalanced   OutputUpdateRequestElasticsearchPreset = "balanced"
	OutputUpdateRequestElasticsearchPresetCustom     OutputUpdateRequestElasticsearchPreset = "custom"
	OutputUpdateRequestElasticsearchPresetLatency    OutputUpdateRequestElasticsearchPreset = "latency"
	OutputUpdateRequestElasticsearchPresetScale      OutputUpdateRequestElasticsearchPreset = "scale"
	OutputUpdateRequestElasticsearchPresetThroughput OutputUpdateRequestElasticsearchPreset = "throughput"
)

// Defines values for OutputUpdateRequestElasticsearchType.
const (
	OutputUpdateRequestElasticsearchTypeElasticsearch OutputUpdateRequestElasticsearchType = "elasticsearch"
)

// Defines values for OutputUpdateRequestKafkaConnectionType.
const (
	OutputUpdateRequestKafkaConnectionTypeEncryption OutputUpdateRequestKafkaConnectionType = "encryption"
	OutputUpdateRequestKafkaConnectionTypePlaintext  OutputUpdateRequestKafkaConnectionType = "plaintext"
)

// Defines values for OutputUpdateRequestKafkaSslVerificationMode.
const (
	OutputUpdateRequestKafkaSslVerificationModeCertificate OutputUpdateRequestKafkaSslVerificationMode = "certificate"
	OutputUpdateRequestKafkaSslVerificationModeFull        OutputUpdateRequestKafkaSslVerificationMode = "full"
	OutputUpdateRequestKafkaSslVerificationModeNone        OutputUpdateRequestKafkaSslVerificationMode = "none"
	OutputUpdateRequestKafkaSslVerificationModeStrict      OutputUpdateRequestKafkaSslVerificationMode = "strict"
)

// Defines values for OutputUpdateRequestKafkaType.
const (
	OutputUpdateRequestKafkaTypeKafka OutputUpdateRequestKafkaType = "kafka"
)

// Defines values for OutputUpdateRequestLogstashType.
const (
	OutputUpdateRequestLogstashTypeLogstash OutputUpdateRequestLogstashType = "logstash"
)

// Defines values for PackageInfoConditionsElasticsearchSubscription.
const (
	Basic      PackageInfoConditionsElasticsearchSubscription = "basic"
	Enterprise PackageInfoConditionsElasticsearchSubscription = "enterprise"
	Gold       PackageInfoConditionsElasticsearchSubscription = "gold"
	Platinum   PackageInfoConditionsElasticsearchSubscription = "platinum"
)

// Defines values for PackageInfoRelease.
const (
	Beta         PackageInfoRelease = "beta"
	Experimental PackageInfoRelease = "experimental"
	Ga           PackageInfoRelease = "ga"
)

// Defines values for PackageInfoSourceLicense.
const (
	Apache20  PackageInfoSourceLicense = "Apache-2.0"
	Elastic20 PackageInfoSourceLicense = "Elastic-2.0"
)

// Defines values for PackageInstallSource.
const (
	PackageInstallSourceBundled  PackageInstallSource = "bundled"
	PackageInstallSourceRegistry PackageInstallSource = "registry"
	PackageInstallSourceUpload   PackageInstallSource = "upload"
)

// Defines values for PackageStatus.
const (
	PackageStatusInstallFailed PackageStatus = "install_failed"
	PackageStatusInstalled     PackageStatus = "installed"
	PackageStatusInstalling    PackageStatus = "installing"
	PackageStatusNotInstalled  PackageStatus = "not_installed"
)

// Defines values for ParamsEsQueryRule0SearchType.
const (
	EsqlQuery ParamsEsQueryRule0SearchType = "esqlQuery"
)

// Defines values for ParamsEsQueryRule0ThresholdComparator.
const (
	ParamsEsQueryRule0ThresholdComparatorEmpty ParamsEsQueryRule0ThresholdComparator = ">"
)

// Defines values for ParamsEsQueryRule1SearchType.
const (
	SearchSource ParamsEsQueryRule1SearchType = "searchSource"
)

// Defines values for ParamsEsQueryRule2SearchType.
const (
	EsQuery ParamsEsQueryRule2SearchType = "esQuery"
)

// Defines values for ParamsPropertyApmAnomalyAnomalySeverityType.
const (
	Critical ParamsPropertyApmAnomalyAnomalySeverityType = "critical"
	Major    ParamsPropertyApmAnomalyAnomalySeverityType = "major"
	Minor    ParamsPropertyApmAnomalyAnomalySeverityType = "minor"
	Warning  ParamsPropertyApmAnomalyAnomalySeverityType = "warning"
)

// Defines values for ParamsPropertyApmAnomalyWindowUnit.
const (
	ParamsPropertyApmAnomalyWindowUnitD ParamsPropertyApmAnomalyWindowUnit = "d"
	ParamsPropertyApmAnomalyWindowUnitH ParamsPropertyApmAnomalyWindowUnit = "h"
	ParamsPropertyApmAnomalyWindowUnitM ParamsPropertyApmAnomalyWindowUnit = "m"
)

// Defines values for ParamsPropertyApmErrorCountGroupBy.
const (
	ParamsPropertyApmErrorCountGroupByErrorGroupingKey   ParamsPropertyApmErrorCountGroupBy = "error.grouping_key"
	ParamsPropertyApmErrorCountGroupByServiceEnvironment ParamsPropertyApmErrorCountGroupBy = "service.environment"
	ParamsPropertyApmErrorCountGroupByServiceName        ParamsPropertyApmErrorCountGroupBy = "service.name"
	ParamsPropertyApmErrorCountGroupByTransactionName    ParamsPropertyApmErrorCountGroupBy = "transaction.name"
)

// Defines values for ParamsPropertyApmErrorCountWindowUnit.
const (
	ParamsPropertyApmErrorCountWindowUnitD ParamsPropertyApmErrorCountWindowUnit = "d"
	ParamsPropertyApmErrorCountWindowUnitH ParamsPropertyApmErrorCountWindowUnit = "h"
	ParamsPropertyApmErrorCountWindowUnitM ParamsPropertyApmErrorCountWindowUnit = "m"
)

// Defines values for ParamsPropertyApmTransactionDurationAggregationType.
const (
	ParamsPropertyApmTransactionDurationAggregationTypeAvg   ParamsPropertyApmTransactionDurationAggregationType = "avg"
	ParamsPropertyApmTransactionDurationAggregationTypeN95th ParamsPropertyApmTransactionDurationAggregationType = "95th"
	ParamsPropertyApmTransactionDurationAggregationTypeN99th ParamsPropertyApmTransactionDurationAggregationType = "99th"
)

// Defines values for ParamsPropertyApmTransactionDurationGroupBy.
const (
	ParamsPropertyApmTransactionDurationGroupByServiceEnvironment ParamsPropertyApmTransactionDurationGroupBy = "service.environment"
	ParamsPropertyApmTransactionDurationGroupByServiceName        ParamsPropertyApmTransactionDurationGroupBy = "service.name"
	ParamsPropertyApmTransactionDurationGroupByTransactionName    ParamsPropertyApmTransactionDurationGroupBy = "transaction.name"
	ParamsPropertyApmTransactionDurationGroupByTransactionType    ParamsPropertyApmTransactionDurationGroupBy = "transaction.type"
)

// Defines values for ParamsPropertyApmTransactionDurationWindowUnit.
const (
	ParamsPropertyApmTransactionDurationWindowUnitD ParamsPropertyApmTransactionDurationWindowUnit = "d"
	ParamsPropertyApmTransactionDurationWindowUnitH ParamsPropertyApmTransactionDurationWindowUnit = "h"
	ParamsPropertyApmTransactionDurationWindowUnitM ParamsPropertyApmTransactionDurationWindowUnit = "m"
)

// Defines values for ParamsPropertyApmTransactionErrorRateGroupBy.
const (
	ServiceEnvironment ParamsPropertyApmTransactionErrorRateGroupBy = "service.environment"
	ServiceName        ParamsPropertyApmTransactionErrorRateGroupBy = "service.name"
	TransactionName    ParamsPropertyApmTransactionErrorRateGroupBy = "transaction.name"
	TransactionType    ParamsPropertyApmTransactionErrorRateGroupBy = "transaction.type"
)

// Defines values for ParamsPropertyApmTransactionErrorRateWindowUnit.
const (
	ParamsPropertyApmTransactionErrorRateWindowUnitD ParamsPropertyApmTransactionErrorRateWindowUnit = "d"
	ParamsPropertyApmTransactionErrorRateWindowUnitH ParamsPropertyApmTransactionErrorRateWindowUnit = "h"
	ParamsPropertyApmTransactionErrorRateWindowUnitM ParamsPropertyApmTransactionErrorRateWindowUnit = "m"
)

// Defines values for ParamsPropertyInfraInventoryCriteriaComparator.
const (
	ParamsPropertyInfraInventoryCriteriaComparatorBetween ParamsPropertyInfraInventoryCriteriaComparator = "between"
	ParamsPropertyInfraInventoryCriteriaComparatorEmpty   ParamsPropertyInfraInventoryCriteriaComparator = "<"
	ParamsPropertyInfraInventoryCriteriaComparatorN1      ParamsPropertyInfraInventoryCriteriaComparator = "<="
	ParamsPropertyInfraInventoryCriteriaComparatorN2      ParamsPropertyInfraInventoryCriteriaComparator = ">"
	ParamsPropertyInfraInventoryCriteriaComparatorN3      ParamsPropertyInfraInventoryCriteriaComparator = ">="
	ParamsPropertyInfraInventoryCriteriaComparatorOutside ParamsPropertyInfraInventoryCriteriaComparator = "outside"
)

// Defines values for ParamsPropertyInfraInventoryCriteriaCustomMetricAggregation.
const (
	ParamsPropertyInfraInventoryCriteriaCustomMetricAggregationAvg  ParamsPropertyInfraInventoryCriteriaCustomMetricAggregation = "avg"
	ParamsPropertyInfraInventoryCriteriaCustomMetricAggregationMax  ParamsPropertyInfraInventoryCriteriaCustomMetricAggregation = "max"
	ParamsPropertyInfraInventoryCriteriaCustomMetricAggregationMin  ParamsPropertyInfraInventoryCriteriaCustomMetricAggregation = "min"
	ParamsPropertyInfraInventoryCriteriaCustomMetricAggregationRate ParamsPropertyInfraInventoryCriteriaCustomMetricAggregation = "rate"
)

// Defines values for ParamsPropertyInfraInventoryCriteriaCustomMetricType.
const (
	ParamsPropertyInfraInventoryCriteriaCustomMetricTypeCustom ParamsPropertyInfraInventoryCriteriaCustomMetricType = "custom"
)

// Defines values for ParamsPropertyInfraInventoryCriteriaMetric.
const (
	ParamsPropertyInfraInventoryCriteriaMetricCount                 ParamsPropertyInfraInventoryCriteriaMetric = "count"
	ParamsPropertyInfraInventoryCriteriaMetricCpu                   ParamsPropertyInfraInventoryCriteriaMetric = "cpu"
	ParamsPropertyInfraInventoryCriteriaMetricCustom                ParamsPropertyInfraInventoryCriteriaMetric = "custom"
	ParamsPropertyInfraInventoryCriteriaMetricDiskIOReadBytes       ParamsPropertyInfraInventoryCriteriaMetric = "diskIOReadBytes"
	ParamsPropertyInfraInventoryCriteriaMetricDiskIOWriteBytes      ParamsPropertyInfraInventoryCriteriaMetric = "diskIOWriteBytes"
	ParamsPropertyInfraInventoryCriteriaMetricDiskLatency           ParamsPropertyInfraInventoryCriteriaMetric = "diskLatency"
	ParamsPropertyInfraInventoryCriteriaMetricLoad                  ParamsPropertyInfraInventoryCriteriaMetric = "load"
	ParamsPropertyInfraInventoryCriteriaMetricLogRate               ParamsPropertyInfraInventoryCriteriaMetric = "logRate"
	ParamsPropertyInfraInventoryCriteriaMetricMemory                ParamsPropertyInfraInventoryCriteriaMetric = "memory"
	ParamsPropertyInfraInventoryCriteriaMetricMemoryTotal           ParamsPropertyInfraInventoryCriteriaMetric = "memoryTotal"
	ParamsPropertyInfraInventoryCriteriaMetricRdsActiveTransactions ParamsPropertyInfraInventoryCriteriaMetric = "rdsActiveTransactions"
	ParamsPropertyInfraInventoryCriteriaMetricRdsConnections        ParamsPropertyInfraInventoryCriteriaMetric = "rdsConnections"
	ParamsPropertyInfraInventoryCriteriaMetricRdsLatency            ParamsPropertyInfraInventoryCriteriaMetric = "rdsLatency"
	ParamsPropertyInfraInventoryCriteriaMetricRdsQueriesExecuted    ParamsPropertyInfraInventoryCriteriaMetric = "rdsQueriesExecuted"
	ParamsPropertyInfraInventoryCriteriaMetricRx                    ParamsPropertyInfraInventoryCriteriaMetric = "rx"
	ParamsPropertyInfraInventoryCriteriaMetricS3BucketSize          ParamsPropertyInfraInventoryCriteriaMetric = "s3BucketSize"
	ParamsPropertyInfraInventoryCriteriaMetricS3DownloadBytes       ParamsPropertyInfraInventoryCriteriaMetric = "s3DownloadBytes"
	ParamsPropertyInfraInventoryCriteriaMetricS3NumberOfObjects     ParamsPropertyInfraInventoryCriteriaMetric = "s3NumberOfObjects"
	ParamsPropertyInfraInventoryCriteriaMetricS3TotalRequests       ParamsPropertyInfraInventoryCriteriaMetric = "s3TotalRequests"
	ParamsPropertyInfraInventoryCriteriaMetricS3UploadBytes         ParamsPropertyInfraInventoryCriteriaMetric = "s3UploadBytes"
	ParamsPropertyInfraInventoryCriteriaMetricSqsMessagesDelayed    ParamsPropertyInfraInventoryCriteriaMetric = "sqsMessagesDelayed"
	ParamsPropertyInfraInventoryCriteriaMetricSqsMessagesEmpty      ParamsPropertyInfraInventoryCriteriaMetric = "sqsMessagesEmpty"
	ParamsPropertyInfraInventoryCriteriaMetricSqsMessagesSent       ParamsPropertyInfraInventoryCriteriaMetric = "sqsMessagesSent"
	ParamsPropertyInfraInventoryCriteriaMetricSqsMessagesVisible    ParamsPropertyInfraInventoryCriteriaMetric = "sqsMessagesVisible"
	ParamsPropertyInfraInventoryCriteriaMetricSqsOldestMessage      ParamsPropertyInfraInventoryCriteriaMetric = "sqsOldestMessage"
	ParamsPropertyInfraInventoryCriteriaMetricTx                    ParamsPropertyInfraInventoryCriteriaMetric = "tx"
)

// Defines values for ParamsPropertyInfraInventoryCriteriaTimeUnit.
const (
	ParamsPropertyInfraInventoryCriteriaTimeUnitD ParamsPropertyInfraInventoryCriteriaTimeUnit = "d"
	ParamsPropertyInfraInventoryCriteriaTimeUnitH ParamsPropertyInfraInventoryCriteriaTimeUnit = "h"
	ParamsPropertyInfraInventoryCriteriaTimeUnitM ParamsPropertyInfraInventoryCriteriaTimeUnit = "m"
	ParamsPropertyInfraInventoryCriteriaTimeUnitS ParamsPropertyInfraInventoryCriteriaTimeUnit = "s"
)

// Defines values for ParamsPropertyInfraInventoryCriteriaWarningComparator.
const (
	ParamsPropertyInfraInventoryCriteriaWarningComparatorBetween ParamsPropertyInfraInventoryCriteriaWarningComparator = "between"
	ParamsPropertyInfraInventoryCriteriaWarningComparatorEmpty   ParamsPropertyInfraInventoryCriteriaWarningComparator = "<"
	ParamsPropertyInfraInventoryCriteriaWarningComparatorN1      ParamsPropertyInfraInventoryCriteriaWarningComparator = "<="
	ParamsPropertyInfraInventoryCriteriaWarningComparatorN2      ParamsPropertyInfraInventoryCriteriaWarningComparator = ">"
	ParamsPropertyInfraInventoryCriteriaWarningComparatorN3      ParamsPropertyInfraInventoryCriteriaWarningComparator = ">="
	ParamsPropertyInfraInventoryCriteriaWarningComparatorOutside ParamsPropertyInfraInventoryCriteriaWarningComparator = "outside"
)

// Defines values for ParamsPropertyInfraInventoryNodeType.
const (
	AwsEC2    ParamsPropertyInfraInventoryNodeType = "awsEC2"
	AwsRDS    ParamsPropertyInfraInventoryNodeType = "awsRDS"
	AwsS3     ParamsPropertyInfraInventoryNodeType = "awsS3"
	AwsSQS    ParamsPropertyInfraInventoryNodeType = "awsSQS"
	Container ParamsPropertyInfraInventoryNodeType = "container"
	Host      ParamsPropertyInfraInventoryNodeType = "host"
	Pod       ParamsPropertyInfraInventoryNodeType = "pod"
)

// Defines values for ParamsPropertyInfraMetricThresholdCriteria0AggType.
const (
	ParamsPropertyInfraMetricThresholdCriteria0AggTypeAvg         ParamsPropertyInfraMetricThresholdCriteria0AggType = "avg"
	ParamsPropertyInfraMetricThresholdCriteria0AggTypeCardinality ParamsPropertyInfraMetricThresholdCriteria0AggType = "cardinality"
	ParamsPropertyInfraMetricThresholdCriteria0AggTypeCount       ParamsPropertyInfraMetricThresholdCriteria0AggType = "count"
	ParamsPropertyInfraMetricThresholdCriteria0AggTypeCustom      ParamsPropertyInfraMetricThresholdCriteria0AggType = "custom"
	ParamsPropertyInfraMetricThresholdCriteria0AggTypeMax         ParamsPropertyInfraMetricThresholdCriteria0AggType = "max"
	ParamsPropertyInfraMetricThresholdCriteria0AggTypeMin         ParamsPropertyInfraMetricThresholdCriteria0AggType = "min"
	ParamsPropertyInfraMetricThresholdCriteria0AggTypeP95         ParamsPropertyInfraMetricThresholdCriteria0AggType = "p95"
	ParamsPropertyInfraMetricThresholdCriteria0AggTypeP99         ParamsPropertyInfraMetricThresholdCriteria0AggType = "p99"
	ParamsPropertyInfraMetricThresholdCriteria0AggTypeRate        ParamsPropertyInfraMetricThresholdCriteria0AggType = "rate"
	ParamsPropertyInfraMetricThresholdCriteria0AggTypeSum         ParamsPropertyInfraMetricThresholdCriteria0AggType = "sum"
)

// Defines values for ParamsPropertyInfraMetricThresholdCriteria0Comparator.
const (
	ParamsPropertyInfraMetricThresholdCriteria0ComparatorBetween ParamsPropertyInfraMetricThresholdCriteria0Comparator = "between"
	ParamsPropertyInfraMetricThresholdCriteria0ComparatorEmpty   ParamsPropertyInfraMetricThresholdCriteria0Comparator = "<"
	ParamsPropertyInfraMetricThresholdCriteria0ComparatorN1      ParamsPropertyInfraMetricThresholdCriteria0Comparator = "<="
	ParamsPropertyInfraMetricThresholdCriteria0ComparatorN2      ParamsPropertyInfraMetricThresholdCriteria0Comparator = ">"
	ParamsPropertyInfraMetricThresholdCriteria0ComparatorN3      ParamsPropertyInfraMetricThresholdCriteria0Comparator = ">="
	ParamsPropertyInfraMetricThresholdCriteria0ComparatorOutside ParamsPropertyInfraMetricThresholdCriteria0Comparator = "outside"
)

// Defines values for ParamsPropertyInfraMetricThresholdCriteria0WarningComparator.
const (
	ParamsPropertyInfraMetricThresholdCriteria0WarningComparatorBetween ParamsPropertyInfraMetricThresholdCriteria0WarningComparator = "between"
	ParamsPropertyInfraMetricThresholdCriteria0WarningComparatorEmpty   ParamsPropertyInfraMetricThresholdCriteria0WarningComparator = "<"
	ParamsPropertyInfraMetricThresholdCriteria0WarningComparatorN1      ParamsPropertyInfraMetricThresholdCriteria0WarningComparator = "<="
	ParamsPropertyInfraMetricThresholdCriteria0WarningComparatorN2      ParamsPropertyInfraMetricThresholdCriteria0WarningComparator = ">"
	ParamsPropertyInfraMetricThresholdCriteria0WarningComparatorN3      ParamsPropertyInfraMetricThresholdCriteria0WarningComparator = ">="
	ParamsPropertyInfraMetricThresholdCriteria0WarningComparatorOutside ParamsPropertyInfraMetricThresholdCriteria0WarningComparator = "outside"
)

// Defines values for ParamsPropertyInfraMetricThresholdCriteria1AggType.
const (
	ParamsPropertyInfraMetricThresholdCriteria1AggTypeCount ParamsPropertyInfraMetricThresholdCriteria1AggType = "count"
)

// Defines values for ParamsPropertyInfraMetricThresholdCriteria1Comparator.
const (
	ParamsPropertyInfraMetricThresholdCriteria1ComparatorBetween ParamsPropertyInfraMetricThresholdCriteria1Comparator = "between"
	ParamsPropertyInfraMetricThresholdCriteria1ComparatorEmpty   ParamsPropertyInfraMetricThresholdCriteria1Comparator = "<"
	ParamsPropertyInfraMetricThresholdCriteria1ComparatorN1      ParamsPropertyInfraMetricThresholdCriteria1Comparator = "<="
	ParamsPropertyInfraMetricThresholdCriteria1ComparatorN2      ParamsPropertyInfraMetricThresholdCriteria1Comparator = ">"
	ParamsPropertyInfraMetricThresholdCriteria1ComparatorN3      ParamsPropertyInfraMetricThresholdCriteria1Comparator = ">="
	ParamsPropertyInfraMetricThresholdCriteria1ComparatorOutside ParamsPropertyInfraMetricThresholdCriteria1Comparator = "outside"
)

// Defines values for ParamsPropertyInfraMetricThresholdCriteria1WarningComparator.
const (
	ParamsPropertyInfraMetricThresholdCriteria1WarningComparatorBetween ParamsPropertyInfraMetricThresholdCriteria1WarningComparator = "between"
	ParamsPropertyInfraMetricThresholdCriteria1WarningComparatorEmpty   ParamsPropertyInfraMetricThresholdCriteria1WarningComparator = "<"
	ParamsPropertyInfraMetricThresholdCriteria1WarningComparatorN1      ParamsPropertyInfraMetricThresholdCriteria1WarningComparator = "<="
	ParamsPropertyInfraMetricThresholdCriteria1WarningComparatorN2      ParamsPropertyInfraMetricThresholdCriteria1WarningComparator = ">"
	ParamsPropertyInfraMetricThresholdCriteria1WarningComparatorN3      ParamsPropertyInfraMetricThresholdCriteria1WarningComparator = ">="
	ParamsPropertyInfraMetricThresholdCriteria1WarningComparatorOutside ParamsPropertyInfraMetricThresholdCriteria1WarningComparator = "outside"
)

// Defines values for ParamsPropertyInfraMetricThresholdCriteria2AggType.
const (
	Custom ParamsPropertyInfraMetricThresholdCriteria2AggType = "custom"
)

// Defines values for ParamsPropertyInfraMetricThresholdCriteria2Comparator.
const (
	ParamsPropertyInfraMetricThresholdCriteria2ComparatorBetween ParamsPropertyInfraMetricThresholdCriteria2Comparator = "between"
	ParamsPropertyInfraMetricThresholdCriteria2ComparatorEmpty   ParamsPropertyInfraMetricThresholdCriteria2Comparator = "<"
	ParamsPropertyInfraMetricThresholdCriteria2ComparatorN1      ParamsPropertyInfraMetricThresholdCriteria2Comparator = "<="
	ParamsPropertyInfraMetricThresholdCriteria2ComparatorN2      ParamsPropertyInfraMetricThresholdCriteria2Comparator = ">"
	ParamsPropertyInfraMetricThresholdCriteria2ComparatorN3      ParamsPropertyInfraMetricThresholdCriteria2Comparator = ">="
	ParamsPropertyInfraMetricThresholdCriteria2ComparatorOutside ParamsPropertyInfraMetricThresholdCriteria2Comparator = "outside"
)

// Defines values for ParamsPropertyInfraMetricThresholdCriteria2CustomMetric0AggType.
const (
	ParamsPropertyInfraMetricThresholdCriteria2CustomMetric0AggTypeAvg         ParamsPropertyInfraMetricThresholdCriteria2CustomMetric0AggType = "avg"
	ParamsPropertyInfraMetricThresholdCriteria2CustomMetric0AggTypeCardinality ParamsPropertyInfraMetricThresholdCriteria2CustomMetric0AggType = "cardinality"
	ParamsPropertyInfraMetricThresholdCriteria2CustomMetric0AggTypeMax         ParamsPropertyInfraMetricThresholdCriteria2CustomMetric0AggType = "max"
	ParamsPropertyInfraMetricThresholdCriteria2CustomMetric0AggTypeMin         ParamsPropertyInfraMetricThresholdCriteria2CustomMetric0AggType = "min"
	ParamsPropertyInfraMetricThresholdCriteria2CustomMetric0AggTypeSum         ParamsPropertyInfraMetricThresholdCriteria2CustomMetric0AggType = "sum"
)

// Defines values for ParamsPropertyInfraMetricThresholdCriteria2CustomMetric1AggType.
const (
	ParamsPropertyInfraMetricThresholdCriteria2CustomMetric1AggTypeCount ParamsPropertyInfraMetricThresholdCriteria2CustomMetric1AggType = "count"
)

// Defines values for ParamsPropertyInfraMetricThresholdCriteria2WarningComparator.
const (
	ParamsPropertyInfraMetricThresholdCriteria2WarningComparatorBetween ParamsPropertyInfraMetricThresholdCriteria2WarningComparator = "between"
	ParamsPropertyInfraMetricThresholdCriteria2WarningComparatorEmpty   ParamsPropertyInfraMetricThresholdCriteria2WarningComparator = "<"
	ParamsPropertyInfraMetricThresholdCriteria2WarningComparatorN1      ParamsPropertyInfraMetricThresholdCriteria2WarningComparator = "<="
	ParamsPropertyInfraMetricThresholdCriteria2WarningComparatorN2      ParamsPropertyInfraMetricThresholdCriteria2WarningComparator = ">"
	ParamsPropertyInfraMetricThresholdCriteria2WarningComparatorN3      ParamsPropertyInfraMetricThresholdCriteria2WarningComparator = ">="
	ParamsPropertyInfraMetricThresholdCriteria2WarningComparatorOutside ParamsPropertyInfraMetricThresholdCriteria2WarningComparator = "outside"
)

// Defines values for ParamsPropertyLogThreshold0CountComparator.
const (
	ParamsPropertyLogThreshold0CountComparatorDoesNotEqual       ParamsPropertyLogThreshold0CountComparator = "does not equal"
	ParamsPropertyLogThreshold0CountComparatorDoesNotMatch       ParamsPropertyLogThreshold0CountComparator = "does not match"
	ParamsPropertyLogThreshold0CountComparatorDoesNotMatchPhrase ParamsPropertyLogThreshold0CountComparator = "does not match phrase"
	ParamsPropertyLogThreshold0CountComparatorEquals             ParamsPropertyLogThreshold0CountComparator = "equals"
	ParamsPropertyLogThreshold0CountComparatorLessThan           ParamsPropertyLogThreshold0CountComparator = "less than"
	ParamsPropertyLogThreshold0CountComparatorLessThanOrEquals   ParamsPropertyLogThreshold0CountComparator = "less than or equals"
	ParamsPropertyLogThreshold0CountComparatorMatches            ParamsPropertyLogThreshold0CountComparator = "matches"
	ParamsPropertyLogThreshold0CountComparatorMatchesPhrase      ParamsPropertyLogThreshold0CountComparator = "matches phrase"
	ParamsPropertyLogThreshold0CountComparatorMoreThan           ParamsPropertyLogThreshold0CountComparator = "more than"
	ParamsPropertyLogThreshold0CountComparatorMoreThanOrEquals   ParamsPropertyLogThreshold0CountComparator = "more than or equals"
)

// Defines values for ParamsPropertyLogThreshold0CriteriaComparator.
const (
	ParamsPropertyLogThreshold0CriteriaComparatorDoesNotEqual       ParamsPropertyLogThreshold0CriteriaComparator = "does not equal"
	ParamsPropertyLogThreshold0CriteriaComparatorDoesNotMatch       ParamsPropertyLogThreshold0CriteriaComparator = "does not match"
	ParamsPropertyLogThreshold0CriteriaComparatorDoesNotMatchPhrase ParamsPropertyLogThreshold0CriteriaComparator = "does not match phrase"
	ParamsPropertyLogThreshold0CriteriaComparatorEquals             ParamsPropertyLogThreshold0CriteriaComparator = "equals"
	ParamsPropertyLogThreshold0CriteriaComparatorLessThan           ParamsPropertyLogThreshold0CriteriaComparator = "less than"
	ParamsPropertyLogThreshold0CriteriaComparatorLessThanOrEquals   ParamsPropertyLogThreshold0CriteriaComparator = "less than or equals"
	ParamsPropertyLogThreshold0CriteriaComparatorMatches            ParamsPropertyLogThreshold0CriteriaComparator = "matches"
	ParamsPropertyLogThreshold0CriteriaComparatorMatchesPhrase      ParamsPropertyLogThreshold0CriteriaComparator = "matches phrase"
	ParamsPropertyLogThreshold0CriteriaComparatorMoreThan           ParamsPropertyLogThreshold0CriteriaComparator = "more than"
	ParamsPropertyLogThreshold0CriteriaComparatorMoreThanOrEquals   ParamsPropertyLogThreshold0CriteriaComparator = "more than or equals"
)

// Defines values for ParamsPropertyLogThreshold0LogViewType.
const (
	ParamsPropertyLogThreshold0LogViewTypeLogViewReference ParamsPropertyLogThreshold0LogViewType = "log-view-reference"
)

// Defines values for ParamsPropertyLogThreshold0TimeUnit.
const (
	ParamsPropertyLogThreshold0TimeUnitD ParamsPropertyLogThreshold0TimeUnit = "d"
	ParamsPropertyLogThreshold0TimeUnitH ParamsPropertyLogThreshold0TimeUnit = "h"
	ParamsPropertyLogThreshold0TimeUnitM ParamsPropertyLogThreshold0TimeUnit = "m"
	ParamsPropertyLogThreshold0TimeUnitS ParamsPropertyLogThreshold0TimeUnit = "s"
)

// Defines values for ParamsPropertyLogThreshold1CountComparator.
const (
	ParamsPropertyLogThreshold1CountComparatorDoesNotEqual       ParamsPropertyLogThreshold1CountComparator = "does not equal"
	ParamsPropertyLogThreshold1CountComparatorDoesNotMatch       ParamsPropertyLogThreshold1CountComparator = "does not match"
	ParamsPropertyLogThreshold1CountComparatorDoesNotMatchPhrase ParamsPropertyLogThreshold1CountComparator = "does not match phrase"
	ParamsPropertyLogThreshold1CountComparatorEquals             ParamsPropertyLogThreshold1CountComparator = "equals"
	ParamsPropertyLogThreshold1CountComparatorLessThan           ParamsPropertyLogThreshold1CountComparator = "less than"
	ParamsPropertyLogThreshold1CountComparatorLessThanOrEquals   ParamsPropertyLogThreshold1CountComparator = "less than or equals"
	ParamsPropertyLogThreshold1CountComparatorMatches            ParamsPropertyLogThreshold1CountComparator = "matches"
	ParamsPropertyLogThreshold1CountComparatorMatchesPhrase      ParamsPropertyLogThreshold1CountComparator = "matches phrase"
	ParamsPropertyLogThreshold1CountComparatorMoreThan           ParamsPropertyLogThreshold1CountComparator = "more than"
	ParamsPropertyLogThreshold1CountComparatorMoreThanOrEquals   ParamsPropertyLogThreshold1CountComparator = "more than or equals"
)

// Defines values for ParamsPropertyLogThreshold1CriteriaComparator.
const (
	ParamsPropertyLogThreshold1CriteriaComparatorDoesNotEqual       ParamsPropertyLogThreshold1CriteriaComparator = "does not equal"
	ParamsPropertyLogThreshold1CriteriaComparatorDoesNotMatch       ParamsPropertyLogThreshold1CriteriaComparator = "does not match"
	ParamsPropertyLogThreshold1CriteriaComparatorDoesNotMatchPhrase ParamsPropertyLogThreshold1CriteriaComparator = "does not match phrase"
	ParamsPropertyLogThreshold1CriteriaComparatorEquals             ParamsPropertyLogThreshold1CriteriaComparator = "equals"
	ParamsPropertyLogThreshold1CriteriaComparatorLessThan           ParamsPropertyLogThreshold1CriteriaComparator = "less than"
	ParamsPropertyLogThreshold1CriteriaComparatorLessThanOrEquals   ParamsPropertyLogThreshold1CriteriaComparator = "less than or equals"
	ParamsPropertyLogThreshold1CriteriaComparatorMatches            ParamsPropertyLogThreshold1CriteriaComparator = "matches"
	ParamsPropertyLogThreshold1CriteriaComparatorMatchesPhrase      ParamsPropertyLogThreshold1CriteriaComparator = "matches phrase"
	ParamsPropertyLogThreshold1CriteriaComparatorMoreThan           ParamsPropertyLogThreshold1CriteriaComparator = "more than"
	ParamsPropertyLogThreshold1CriteriaComparatorMoreThanOrEquals   ParamsPropertyLogThreshold1CriteriaComparator = "more than or equals"
)

// Defines values for ParamsPropertyLogThreshold1LogViewType.
const (
	ParamsPropertyLogThreshold1LogViewTypeLogViewReference ParamsPropertyLogThreshold1LogViewType = "log-view-reference"
)

// Defines values for ParamsPropertyLogThreshold1TimeUnit.
const (
	ParamsPropertyLogThreshold1TimeUnitD ParamsPropertyLogThreshold1TimeUnit = "d"
	ParamsPropertyLogThreshold1TimeUnitH ParamsPropertyLogThreshold1TimeUnit = "h"
	ParamsPropertyLogThreshold1TimeUnitM ParamsPropertyLogThreshold1TimeUnit = "m"
	ParamsPropertyLogThreshold1TimeUnitS ParamsPropertyLogThreshold1TimeUnit = "s"
)

// Defines values for SummaryStatus.
const (
	DEGRADING SummaryStatus = "DEGRADING"
	HEALTHY   SummaryStatus = "HEALTHY"
	NODATA    SummaryStatus = "NO_DATA"
	VIOLATED  SummaryStatus = "VIOLATED"
)

// Defines values for Thresholdcomparator.
const (
	ThresholdcomparatorBetween    Thresholdcomparator = "between"
	ThresholdcomparatorEmpty      Thresholdcomparator = ">"
	ThresholdcomparatorN1         Thresholdcomparator = ">="
	ThresholdcomparatorN2         Thresholdcomparator = "<"
	ThresholdcomparatorN3         Thresholdcomparator = "<="
	ThresholdcomparatorNotBetween Thresholdcomparator = "notBetween"
)

// Defines values for TimeWindowType.
const (
	CalendarAligned TimeWindowType = "calendarAligned"
	Rolling         TimeWindowType = "rolling"
)

// Defines values for TimesliceMetricBasicMetricWithFieldAggregation.
const (
	TimesliceMetricBasicMetricWithFieldAggregationAvg          TimesliceMetricBasicMetricWithFieldAggregation = "avg"
	TimesliceMetricBasicMetricWithFieldAggregationCardinality  TimesliceMetricBasicMetricWithFieldAggregation = "cardinality"
	TimesliceMetricBasicMetricWithFieldAggregationLastValue    TimesliceMetricBasicMetricWithFieldAggregation = "last_value"
	TimesliceMetricBasicMetricWithFieldAggregationMax          TimesliceMetricBasicMetricWithFieldAggregation = "max"
	TimesliceMetricBasicMetricWithFieldAggregationMin          TimesliceMetricBasicMetricWithFieldAggregation = "min"
	TimesliceMetricBasicMetricWithFieldAggregationStdDeviation TimesliceMetricBasicMetricWithFieldAggregation = "std_deviation"
	TimesliceMetricBasicMetricWithFieldAggregationSum          TimesliceMetricBasicMetricWithFieldAggregation = "sum"
)

// Defines values for TimesliceMetricDocCountMetricAggregation.
const (
	DocCount TimesliceMetricDocCountMetricAggregation = "doc_count"
)

// Defines values for TimesliceMetricPercentileMetricAggregation.
const (
	Percentile TimesliceMetricPercentileMetricAggregation = "percentile"
)

// Defines values for Timewindowunit.
const (
	TimewindowunitD Timewindowunit = "d"
	TimewindowunitH Timewindowunit = "h"
	TimewindowunitM Timewindowunit = "m"
	TimewindowunitS Timewindowunit = "s"
)

// Defines values for Format.
const (
	FormatLegacy     Format = "legacy"
	FormatSimplified Format = "simplified"
)

// Defines values for FindRulesParamsSortOrder.
const (
	FindRulesParamsSortOrderAsc  FindRulesParamsSortOrder = "asc"
	FindRulesParamsSortOrderDesc FindRulesParamsSortOrder = "desc"
)

// Defines values for GetPackagePoliciesParamsFormat.
const (
	GetPackagePoliciesParamsFormatLegacy     GetPackagePoliciesParamsFormat = "legacy"
	GetPackagePoliciesParamsFormatSimplified GetPackagePoliciesParamsFormat = "simplified"
)

// Defines values for CreatePackagePolicyParamsFormat.
const (
	CreatePackagePolicyParamsFormatLegacy     CreatePackagePolicyParamsFormat = "legacy"
	CreatePackagePolicyParamsFormatSimplified CreatePackagePolicyParamsFormat = "simplified"
)

// Defines values for GetPackagePolicyParamsFormat.
const (
	GetPackagePolicyParamsFormatLegacy     GetPackagePolicyParamsFormat = "legacy"
	GetPackagePolicyParamsFormatSimplified GetPackagePolicyParamsFormat = "simplified"
)

// Defines values for UpdatePackagePolicyParamsFormat.
const (
	Legacy     UpdatePackagePolicyParamsFormat = "legacy"
	Simplified UpdatePackagePolicyParamsFormat = "simplified"
)

// Defines values for FindSlosOpParamsSortBy.
const (
	ErrorBudgetConsumed  FindSlosOpParamsSortBy = "error_budget_consumed"
	ErrorBudgetRemaining FindSlosOpParamsSortBy = "error_budget_remaining"
	SliValue             FindSlosOpParamsSortBy = "sli_value"
	Status               FindSlosOpParamsSortBy = "status"
)

// Defines values for FindSlosOpParamsSortDirection.
const (
	FindSlosOpParamsSortDirectionAsc  FindSlosOpParamsSortDirection = "asc"
	FindSlosOpParamsSortDirectionDesc FindSlosOpParamsSortDirection = "desc"
)

// N400Response defines model for 400_response.
type N400Response struct {
	Error      string  `json:"error"`
	Message    string  `json:"message"`
	StatusCode float32 `json:"statusCode"`
}

// N401Response defines model for 401_response.
type N401Response struct {
	Error      string  `json:"error"`
	Message    string  `json:"message"`
	StatusCode float32 `json:"statusCode"`
}

// N403Response defines model for 403_response.
type N403Response struct {
	Error      string  `json:"error"`
	Message    string  `json:"message"`
	StatusCode float32 `json:"statusCode"`
}

// N404Response defines model for 404_response.
type N404Response struct {
	Error      string  `json:"error"`
	Message    string  `json:"message"`
	StatusCode float32 `json:"statusCode"`
}

// N409Response defines model for 409_response.
type N409Response struct {
	Error      string  `json:"error"`
	Message    string  `json:"message"`
	StatusCode float32 `json:"statusCode"`
}

// Actions defines model for actions.
type Actions = []struct {
	// AlertsFilter Conditions that affect whether the action runs. If you specify multiple conditions, all conditions must be met for the action to run. For example, if an alert occurs within the specified time frame and matches the query, the action runs.
	AlertsFilter *struct {
		// Query Defines a query filter that determines whether the action runs.
		Query *struct {
			Filters []Filter `json:"filters,omitempty"`

			// Kql A filter written in Kibana Query Language (KQL).
			Kql *string `json:"kql,omitempty"`
		} `json:"query,omitempty"`

		// Timeframe Defines a period that limits whether the action runs.
		Timeframe *struct {
			// Days Defines the days of the week that the action can run, represented as an array of numbers. For example, `1` represents Monday. An empty array is equivalent to specifying all the days of the week.
			Days []int `json:"days,omitempty"`

			// Hours Defines the range of time in a day that the action can run. If the `start` value is `00:00` and the `end` value is `24:00`, actions be generated all day.
			Hours *struct {
				// End The end of the time frame in 24-hour notation (`hh:mm`).
				End *string `json:"end,omitempty"`

				// Start The start of the time frame in 24-hour notation (`hh:mm`).
				Start *string `json:"start,omitempty"`
			} `json:"hours,omitempty"`

			// Timezone The ISO time zone for the `hours` values. Values such as `UTC` and `UTC+1` also work but lack built-in daylight savings time support and are not recommended.
			Timezone *string `json:"timezone,omitempty"`
		} `json:"timeframe,omitempty"`
	} `json:"alerts_filter,omitempty"`

	// ConnectorTypeId The type of connector. This property appears in responses but cannot be set in requests.
	ConnectorTypeId *string `json:"connector_type_id,omitempty"`

	// Frequency The properties that affect how often actions are generated. If the rule type supports setting `summary` to `true`, the action can be a summary of alerts at the specified notification interval. Otherwise, an action runs for each alert at the specified notification interval. NOTE: You cannot specify these parameters when `notify_when` or `throttle` are defined at the rule level.
	Frequency *struct {
		// NotifyWhen Indicates how often alerts generate actions. Valid values include: `onActionGroupChange`: Actions run when the alert status changes; `onActiveAlert`: Actions run when the alert becomes active and at each check interval while the rule conditions are met; `onThrottleInterval`: Actions run when the alert becomes active and at the interval specified in the throttle property while the rule conditions are met. NOTE: You cannot specify `notify_when` at both the rule and action level. The recommended method is to set it for each action. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
		NotifyWhen NotifyWhenAction `json:"notify_when"`

		// Summary Indicates whether the action is a summary.
		Summary bool `json:"summary"`

		// Throttle The throttle interval, which defines how often an alert generates repeated actions. It is specified in seconds, minutes, hours, or days and is applicable only if `notify_when` is set to `onThrottleInterval`. NOTE: You cannot specify the throttle interval at both the rule and action level. The recommended method is to set it for each action. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
		Throttle *ThrottleAction `json:"throttle"`
	} `json:"frequency,omitempty"`

	// Group The group name, which affects when the action runs (for example, when the threshold is met or when the alert is recovered). Each rule type has a list of valid action group names. If you don't need to group actions, set to `default`.
	Group string `json:"group"`

	// Id The identifier for the connector saved object.
	Id string `json:"id"`

	// Params The parameters for the action, which are sent to the connector. The `params` are handled as Mustache templates and passed a default set of context.
	Params map[string]interface{} `json:"params"`

	// Uuid A universally unique identifier (UUID) for the action.
	Uuid *string `json:"uuid,omitempty"`
}

// AgentPolicy defines model for agent_policy.
type AgentPolicy struct {
	// AdvancedSettings Advanced settings stored in the agent policy, e.g. agent_limits_go_max_procs
	AdvancedSettings map[string]interface{} `json:"advanced_settings"`
	AgentFeatures    []struct {
		Enabled bool   `json:"enabled"`
		Name    string `json:"name"`
	} `json:"agent_features,omitempty"`
	Agents            *float32                                                     `json:"agents,omitempty"`
	DataOutputId      *string                                                      `json:"data_output_id"`
	Description       *string                                                      `json:"description,omitempty"`
	DownloadSourceId  *string                                                      `json:"download_source_id"`
	FleetServerHostId *string                                                      `json:"fleet_server_host_id"`
	GlobalDataTags    []map[string]AgentPolicy_GlobalDataTags_AdditionalProperties `json:"global_data_tags,omitempty"`
	Id                string                                                       `json:"id"`
	InactivityTimeout *int                                                         `json:"inactivity_timeout,omitempty"`

	// IsProtected Indicates whether the agent policy has tamper protection enabled. Default false.
	IsProtected *bool `json:"is_protected,omitempty"`

	// KeepMonitoringAlive When set to true, monitoring will be enabled but logs/metrics collection will be disabled
	KeepMonitoringAlive *bool                          `json:"keep_monitoring_alive"`
	MonitoringEnabled   []AgentPolicyMonitoringEnabled `json:"monitoring_enabled,omitempty"`
	MonitoringOutputId  *string                        `json:"monitoring_output_id"`
	Name                string                         `json:"name"`
	Namespace           string                         `json:"namespace"`

	// Overrides Override settings that are defined in the agent policy. Input settings cannot be overridden. The override option should be used only in unusual circumstances and not as a routine procedure.
	Overrides map[string]interface{} `json:"overrides"`

	// PackagePolicies This field is present only when retrieving a single agent policy, or when retrieving a list of agent policies with the ?full=true parameter
	PackagePolicies []PackagePolicy `json:"package_policies,omitempty"`
	Revision        *float32        `json:"revision,omitempty"`

	// SupportsAgentless Indicates whether the agent policy supports agentless integrations. Only allowed in a serverless environment.
	SupportsAgentless  *bool      `json:"supports_agentless,omitempty"`
	UnenrollTimeout    *int       `json:"unenroll_timeout,omitempty"`
	UnprivilegedAgents *float32   `json:"unprivileged_agents,omitempty"`
	UpdatedBy          *string    `json:"updated_by,omitempty"`
	UpdatedOn          *time.Time `json:"updated_on,omitempty"`
}

// AgentPolicyGlobalDataTags0 defines model for .
type AgentPolicyGlobalDataTags0 = string

// AgentPolicyGlobalDataTags1 defines model for .
type AgentPolicyGlobalDataTags1 = float32

// AgentPolicy_GlobalDataTags_AdditionalProperties defines model for agent_policy.global_data_tags.AdditionalProperties.
type AgentPolicy_GlobalDataTags_AdditionalProperties struct {
	union json.RawMessage
}

// AgentPolicyMonitoringEnabled defines model for AgentPolicy.MonitoringEnabled.
type AgentPolicyMonitoringEnabled string

// AgentPolicyCreateRequest defines model for agent_policy_create_request.
type AgentPolicyCreateRequest struct {
	AgentFeatures []struct {
		Enabled bool   `json:"enabled"`
		Name    string `json:"name"`
	} `json:"agent_features,omitempty"`
	DataOutputId      *string `json:"data_output_id"`
	Description       *string `json:"description,omitempty"`
	DownloadSourceId  *string `json:"download_source_id"`
	FleetServerHostId *string `json:"fleet_server_host_id"`

	// Force Force agent policy creation even if packages are not verified.
	Force              *bool                                                                     `json:"force,omitempty"`
	GlobalDataTags     []map[string]AgentPolicyCreateRequest_GlobalDataTags_AdditionalProperties `json:"global_data_tags,omitempty"`
	Id                 *string                                                                   `json:"id,omitempty"`
	InactivityTimeout  *int                                                                      `json:"inactivity_timeout,omitempty"`
	IsProtected        *bool                                                                     `json:"is_protected,omitempty"`
	MonitoringEnabled  []AgentPolicyCreateRequestMonitoringEnabled                               `json:"monitoring_enabled,omitempty"`
	MonitoringOutputId *string                                                                   `json:"monitoring_output_id"`
	Name               string                                                                    `json:"name"`
	Namespace          string                                                                    `json:"namespace"`
	UnenrollTimeout    *int                                                                      `json:"unenroll_timeout,omitempty"`
}

// AgentPolicyCreateRequestGlobalDataTags0 defines model for .
type AgentPolicyCreateRequestGlobalDataTags0 = string

// AgentPolicyCreateRequestGlobalDataTags1 defines model for .
type AgentPolicyCreateRequestGlobalDataTags1 = float32

// AgentPolicyCreateRequest_GlobalDataTags_AdditionalProperties defines model for agent_policy_create_request.global_data_tags.AdditionalProperties.
type AgentPolicyCreateRequest_GlobalDataTags_AdditionalProperties struct {
	union json.RawMessage
}

// AgentPolicyCreateRequestMonitoringEnabled defines model for AgentPolicyCreateRequest.MonitoringEnabled.
type AgentPolicyCreateRequestMonitoringEnabled string

// AgentPolicyUpdateRequest defines model for agent_policy_update_request.
type AgentPolicyUpdateRequest struct {
	AgentFeatures []struct {
		Enabled bool   `json:"enabled"`
		Name    string `json:"name"`
	} `json:"agent_features,omitempty"`
	DataOutputId      *string `json:"data_output_id"`
	Description       *string `json:"description,omitempty"`
	DownloadSourceId  *string `json:"download_source_id"`
	FleetServerHostId *string `json:"fleet_server_host_id"`

	// Force Force agent policy creation even if packages are not verified.
	Force              *bool                                       `json:"force,omitempty"`
	InactivityTimeout  *int                                        `json:"inactivity_timeout,omitempty"`
	IsProtected        *bool                                       `json:"is_protected,omitempty"`
	MonitoringEnabled  []AgentPolicyUpdateRequestMonitoringEnabled `json:"monitoring_enabled,omitempty"`
	MonitoringOutputId *string                                     `json:"monitoring_output_id"`
	Name               string                                      `json:"name"`
	Namespace          string                                      `json:"namespace"`
	UnenrollTimeout    *int                                        `json:"unenroll_timeout,omitempty"`
}

// AgentPolicyUpdateRequestMonitoringEnabled defines model for AgentPolicyUpdateRequest.MonitoringEnabled.
type AgentPolicyUpdateRequestMonitoringEnabled string

// Aggfield The name of the numeric field that is used in the aggregation. This property is required when `aggType` is `avg`, `max`, `min` or `sum`.
type Aggfield = string

// Aggtype The type of aggregation to perform.
type Aggtype string

// AlertDelay Indicates that an alert occurs only when the specified number of consecutive runs met the rule conditions.
type AlertDelay struct {
	// Active The number of consecutive runs that must meet the rule conditions.
	Active float32 `json:"active"`
}

// Allownoindex Allows the data view saved object to exist before the data is available.
type Allownoindex = bool

// BudgetingMethod The budgeting method to use when computing the rollup data.
type BudgetingMethod string

// Consumer The name of the application or feature that owns the rule. For example: `alerts`, `apm`, `discover`, `infrastructure`, `logs`, `metrics`, `ml`, `monitoring`, `securitySolution`, `siem`, `stackAlerts`, or `uptime`.
type Consumer = string

// CreateAnomalyDetectionAlertRuleRequest A rule that checks if the anomaly detection job results contain anomalies that match the rule conditions.
type CreateAnomalyDetectionAlertRuleRequest struct {
	Actions Actions `json:"actions"`

	// AlertDelay Indicates that an alert occurs only when the specified number of consecutive runs met the rule conditions.
	AlertDelay *AlertDelay `json:"alert_delay,omitempty"`

	// Consumer The name of the application or feature that owns the rule. For example: `alerts`, `apm`, `discover`, `infrastructure`, `logs`, `metrics`, `ml`, `monitoring`, `securitySolution`, `siem`, `stackAlerts`, or `uptime`.
	Consumer Consumer `json:"consumer"`

	// Enabled Indicates whether you want to run the rule on an interval basis after it is created.
	Enabled *EnabledRule `json:"enabled,omitempty"`

	// Name The name of the rule. While this name does not have to be unique, a distinctive name can help you identify a rule.
	Name NameRule `json:"name"`

	// NotifyWhen Deprecated in 8.13.0. Use the `notify_when` property in the action `frequency` object instead. Indicates how often alerts generate actions. NOTE: You cannot specify `notify_when` at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	NotifyWhen *NotifyWhen `json:"notify_when,omitempty"`

	// Params The parameters for an anomaly detection rule.
	Params map[string]interface{} `json:"params"`

	// RuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
	RuleTypeId CreateAnomalyDetectionAlertRuleRequestRuleTypeId `json:"rule_type_id"`

	// Schedule The check interval, which specifies how frequently the rule conditions are checked. The interval is specified in seconds, minutes, hours, or days.
	Schedule Schedule `json:"schedule"`

	// Tags The tags for the rule.
	Tags Tags `json:"tags,omitempty"`

	// Throttle Deprecated in 8.13.0. Use the `throttle` property in the action `frequency` object instead. The throttle interval, which defines how often an alert generates repeated actions. NOTE: You cannot specify the throttle interval at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	Throttle *Throttle `json:"throttle"`
}

// CreateAnomalyDetectionAlertRuleRequestRuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
type CreateAnomalyDetectionAlertRuleRequestRuleTypeId string

// CreateAnomalyDetectionJobsHealthRuleRequest An rule that monitors job health and alerts if an operational issue occurred that may prevent the job from detecting anomalies.
type CreateAnomalyDetectionJobsHealthRuleRequest struct {
	Actions Actions `json:"actions"`

	// AlertDelay Indicates that an alert occurs only when the specified number of consecutive runs met the rule conditions.
	AlertDelay *AlertDelay `json:"alert_delay,omitempty"`

	// Consumer The name of the application or feature that owns the rule. For example: `alerts`, `apm`, `discover`, `infrastructure`, `logs`, `metrics`, `ml`, `monitoring`, `securitySolution`, `siem`, `stackAlerts`, or `uptime`.
	Consumer Consumer `json:"consumer"`

	// Enabled Indicates whether you want to run the rule on an interval basis after it is created.
	Enabled *EnabledRule `json:"enabled,omitempty"`

	// Name The name of the rule. While this name does not have to be unique, a distinctive name can help you identify a rule.
	Name NameRule `json:"name"`

	// NotifyWhen Deprecated in 8.13.0. Use the `notify_when` property in the action `frequency` object instead. Indicates how often alerts generate actions. NOTE: You cannot specify `notify_when` at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	NotifyWhen *NotifyWhen `json:"notify_when,omitempty"`

	// Params The parameters for an anomaly detection jobs health rule.
	Params map[string]interface{} `json:"params"`

	// RuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
	RuleTypeId CreateAnomalyDetectionJobsHealthRuleRequestRuleTypeId `json:"rule_type_id"`

	// Schedule The check interval, which specifies how frequently the rule conditions are checked. The interval is specified in seconds, minutes, hours, or days.
	Schedule Schedule `json:"schedule"`

	// Tags The tags for the rule.
	Tags Tags `json:"tags,omitempty"`

	// Throttle Deprecated in 8.13.0. Use the `throttle` property in the action `frequency` object instead. The throttle interval, which defines how often an alert generates repeated actions. NOTE: You cannot specify the throttle interval at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	Throttle *Throttle `json:"throttle"`
}

// CreateAnomalyDetectionJobsHealthRuleRequestRuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
type CreateAnomalyDetectionJobsHealthRuleRequestRuleTypeId string

// CreateApmAnomalyRuleRequest A rule that detects when either the latency, throughput, or failed transaction rate of a service is anomalous.
type CreateApmAnomalyRuleRequest struct {
	Actions Actions `json:"actions"`

	// AlertDelay Indicates that an alert occurs only when the specified number of consecutive runs met the rule conditions.
	AlertDelay *AlertDelay `json:"alert_delay,omitempty"`

	// Consumer The name of the application or feature that owns the rule. For example: `alerts`, `apm`, `discover`, `infrastructure`, `logs`, `metrics`, `ml`, `monitoring`, `securitySolution`, `siem`, `stackAlerts`, or `uptime`.
	Consumer Consumer `json:"consumer"`

	// Enabled Indicates whether you want to run the rule on an interval basis after it is created.
	Enabled *EnabledRule `json:"enabled,omitempty"`

	// Name The name of the rule. While this name does not have to be unique, a distinctive name can help you identify a rule.
	Name NameRule `json:"name"`

	// NotifyWhen Deprecated in 8.13.0. Use the `notify_when` property in the action `frequency` object instead. Indicates how often alerts generate actions. NOTE: You cannot specify `notify_when` at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	NotifyWhen *NotifyWhen              `json:"notify_when,omitempty"`
	Params     ParamsPropertyApmAnomaly `json:"params"`

	// RuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
	RuleTypeId CreateApmAnomalyRuleRequestRuleTypeId `json:"rule_type_id"`

	// Schedule The check interval, which specifies how frequently the rule conditions are checked. The interval is specified in seconds, minutes, hours, or days.
	Schedule Schedule `json:"schedule"`

	// Tags The tags for the rule.
	Tags Tags `json:"tags,omitempty"`

	// Throttle Deprecated in 8.13.0. Use the `throttle` property in the action `frequency` object instead. The throttle interval, which defines how often an alert generates repeated actions. NOTE: You cannot specify the throttle interval at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	Throttle *Throttle `json:"throttle"`
}

// CreateApmAnomalyRuleRequestRuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
type CreateApmAnomalyRuleRequestRuleTypeId string

// CreateApmErrorCountRuleRequest A rule that detects when the number of errors in a service exceeds a defined threshold.
type CreateApmErrorCountRuleRequest struct {
	Actions Actions `json:"actions"`

	// AlertDelay Indicates that an alert occurs only when the specified number of consecutive runs met the rule conditions.
	AlertDelay *AlertDelay `json:"alert_delay,omitempty"`

	// Consumer The name of the application or feature that owns the rule. For example: `alerts`, `apm`, `discover`, `infrastructure`, `logs`, `metrics`, `ml`, `monitoring`, `securitySolution`, `siem`, `stackAlerts`, or `uptime`.
	Consumer Consumer `json:"consumer"`

	// Enabled Indicates whether you want to run the rule on an interval basis after it is created.
	Enabled *EnabledRule `json:"enabled,omitempty"`

	// Name The name of the rule. While this name does not have to be unique, a distinctive name can help you identify a rule.
	Name NameRule `json:"name"`

	// NotifyWhen Deprecated in 8.13.0. Use the `notify_when` property in the action `frequency` object instead. Indicates how often alerts generate actions. NOTE: You cannot specify `notify_when` at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	NotifyWhen *NotifyWhen                 `json:"notify_when,omitempty"`
	Params     ParamsPropertyApmErrorCount `json:"params"`

	// RuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
	RuleTypeId CreateApmErrorCountRuleRequestRuleTypeId `json:"rule_type_id"`

	// Schedule The check interval, which specifies how frequently the rule conditions are checked. The interval is specified in seconds, minutes, hours, or days.
	Schedule Schedule `json:"schedule"`

	// Tags The tags for the rule.
	Tags Tags `json:"tags,omitempty"`

	// Throttle Deprecated in 8.13.0. Use the `throttle` property in the action `frequency` object instead. The throttle interval, which defines how often an alert generates repeated actions. NOTE: You cannot specify the throttle interval at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	Throttle *Throttle `json:"throttle"`
}

// CreateApmErrorCountRuleRequestRuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
type CreateApmErrorCountRuleRequestRuleTypeId string

// CreateApmTransactionDurationRuleRequest A rule that detects when the latency of a specific transaction type in a service exceeds a threshold.
type CreateApmTransactionDurationRuleRequest struct {
	Actions Actions `json:"actions"`

	// AlertDelay Indicates that an alert occurs only when the specified number of consecutive runs met the rule conditions.
	AlertDelay *AlertDelay `json:"alert_delay,omitempty"`

	// Consumer The name of the application or feature that owns the rule. For example: `alerts`, `apm`, `discover`, `infrastructure`, `logs`, `metrics`, `ml`, `monitoring`, `securitySolution`, `siem`, `stackAlerts`, or `uptime`.
	Consumer Consumer `json:"consumer"`

	// Enabled Indicates whether you want to run the rule on an interval basis after it is created.
	Enabled *EnabledRule `json:"enabled,omitempty"`

	// Name The name of the rule. While this name does not have to be unique, a distinctive name can help you identify a rule.
	Name NameRule `json:"name"`

	// NotifyWhen Deprecated in 8.13.0. Use the `notify_when` property in the action `frequency` object instead. Indicates how often alerts generate actions. NOTE: You cannot specify `notify_when` at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	NotifyWhen *NotifyWhen                          `json:"notify_when,omitempty"`
	Params     ParamsPropertyApmTransactionDuration `json:"params"`

	// RuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
	RuleTypeId CreateApmTransactionDurationRuleRequestRuleTypeId `json:"rule_type_id"`

	// Schedule The check interval, which specifies how frequently the rule conditions are checked. The interval is specified in seconds, minutes, hours, or days.
	Schedule Schedule `json:"schedule"`

	// Tags The tags for the rule.
	Tags Tags `json:"tags,omitempty"`

	// Throttle Deprecated in 8.13.0. Use the `throttle` property in the action `frequency` object instead. The throttle interval, which defines how often an alert generates repeated actions. NOTE: You cannot specify the throttle interval at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	Throttle *Throttle `json:"throttle"`
}

// CreateApmTransactionDurationRuleRequestRuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
type CreateApmTransactionDurationRuleRequestRuleTypeId string

// CreateApmTransactionErrorRateRuleRequest A rule that sends notifications when the rate of transaction errors in a service exceeds a threshold.
type CreateApmTransactionErrorRateRuleRequest struct {
	Actions Actions `json:"actions"`

	// AlertDelay Indicates that an alert occurs only when the specified number of consecutive runs met the rule conditions.
	AlertDelay *AlertDelay `json:"alert_delay,omitempty"`

	// Consumer The name of the application or feature that owns the rule. For example: `alerts`, `apm`, `discover`, `infrastructure`, `logs`, `metrics`, `ml`, `monitoring`, `securitySolution`, `siem`, `stackAlerts`, or `uptime`.
	Consumer Consumer `json:"consumer"`

	// Enabled Indicates whether you want to run the rule on an interval basis after it is created.
	Enabled *EnabledRule `json:"enabled,omitempty"`

	// Name The name of the rule. While this name does not have to be unique, a distinctive name can help you identify a rule.
	Name NameRule `json:"name"`

	// NotifyWhen Deprecated in 8.13.0. Use the `notify_when` property in the action `frequency` object instead. Indicates how often alerts generate actions. NOTE: You cannot specify `notify_when` at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	NotifyWhen *NotifyWhen                           `json:"notify_when,omitempty"`
	Params     ParamsPropertyApmTransactionErrorRate `json:"params"`

	// RuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
	RuleTypeId CreateApmTransactionErrorRateRuleRequestRuleTypeId `json:"rule_type_id"`

	// Schedule The check interval, which specifies how frequently the rule conditions are checked. The interval is specified in seconds, minutes, hours, or days.
	Schedule Schedule `json:"schedule"`

	// Tags The tags for the rule.
	Tags Tags `json:"tags,omitempty"`

	// Throttle Deprecated in 8.13.0. Use the `throttle` property in the action `frequency` object instead. The throttle interval, which defines how often an alert generates repeated actions. NOTE: You cannot specify the throttle interval at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	Throttle *Throttle `json:"throttle"`
}

// CreateApmTransactionErrorRateRuleRequestRuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
type CreateApmTransactionErrorRateRuleRequestRuleTypeId string

// CreateDataViewRequestObject defines model for create_data_view_request_object.
type CreateDataViewRequestObject struct {
	// DataView The data view object.
	DataView struct {
		// AllowNoIndex Allows the data view saved object to exist before the data is available.
		AllowNoIndex *Allownoindex         `json:"allowNoIndex,omitempty"`
		FieldAttrs   map[string]Fieldattrs `json:"fieldAttrs,omitempty"`

		// FieldFormats A map of field formats by field name.
		FieldFormats Fieldformats           `json:"fieldFormats,omitempty"`
		Fields       map[string]interface{} `json:"fields,omitempty"`
		Id           *string                `json:"id,omitempty"`

		// Name The data view name.
		Name *string `json:"name,omitempty"`

		// Namespaces An array of space identifiers for sharing the data view between multiple spaces.
		Namespaces      Namespaces                 `json:"namespaces,omitempty"`
		RuntimeFieldMap map[string]Runtimefieldmap `json:"runtimeFieldMap,omitempty"`

		// SourceFilters The array of field names you want to filter out in Discover.
		SourceFilters Sourcefilters `json:"sourceFilters,omitempty"`

		// TimeFieldName The timestamp field name, which you use for time-based data views.
		TimeFieldName *Timefieldname `json:"timeFieldName,omitempty"`

		// Title Comma-separated list of data streams, indices, and aliases that you want to search. Supports wildcards (`*`).
		Title Title `json:"title"`

		// Type When set to `rollup`, identifies the rollup data views.
		Type *Type `json:"type,omitempty"`

		// TypeMeta When you use rollup indices, contains the field list for the rollup data view API endpoints.
		TypeMeta *Typemeta `json:"typeMeta,omitempty"`
		Version  *string   `json:"version,omitempty"`
	} `json:"data_view"`

	// Override Override an existing data view if a data view with the provided title already exists.
	Override *bool `json:"override,omitempty"`
}

// CreateEsQueryRuleRequest A rule that runs a user-configured query, compares the number of matches to a configured threshold, and schedules actions to run when the threshold condition is met.
type CreateEsQueryRuleRequest struct {
	Actions Actions `json:"actions"`

	// AlertDelay Indicates that an alert occurs only when the specified number of consecutive runs met the rule conditions.
	AlertDelay *AlertDelay `json:"alert_delay,omitempty"`

	// Consumer The name of the application or feature that owns the rule. For example: `alerts`, `apm`, `discover`, `infrastructure`, `logs`, `metrics`, `ml`, `monitoring`, `securitySolution`, `siem`, `stackAlerts`, or `uptime`.
	Consumer Consumer `json:"consumer"`

	// Enabled Indicates whether you want to run the rule on an interval basis after it is created.
	Enabled *EnabledRule `json:"enabled,omitempty"`

	// Name The name of the rule. While this name does not have to be unique, a distinctive name can help you identify a rule.
	Name NameRule `json:"name"`

	// NotifyWhen Deprecated in 8.13.0. Use the `notify_when` property in the action `frequency` object instead. Indicates how often alerts generate actions. NOTE: You cannot specify `notify_when` at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	NotifyWhen *NotifyWhen       `json:"notify_when,omitempty"`
	Params     ParamsEsQueryRule `json:"params"`

	// RuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
	RuleTypeId CreateEsQueryRuleRequestRuleTypeId `json:"rule_type_id"`

	// Schedule The check interval, which specifies how frequently the rule conditions are checked. The interval is specified in seconds, minutes, hours, or days.
	Schedule Schedule `json:"schedule"`

	// Tags The tags for the rule.
	Tags Tags `json:"tags,omitempty"`

	// Throttle Deprecated in 8.13.0. Use the `throttle` property in the action `frequency` object instead. The throttle interval, which defines how often an alert generates repeated actions. NOTE: You cannot specify the throttle interval at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	Throttle *Throttle `json:"throttle"`
}

// CreateEsQueryRuleRequestRuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
type CreateEsQueryRuleRequestRuleTypeId string

// CreateGeoContainmentRuleRequest A rule that runs an Elasticsearch query over indices to determine whether any documents are currently contained within any boundaries from the specified boundary index. In the event that an entity is contained within a boundary, an alert may be generated.
type CreateGeoContainmentRuleRequest struct {
	Actions Actions `json:"actions"`

	// AlertDelay Indicates that an alert occurs only when the specified number of consecutive runs met the rule conditions.
	AlertDelay *AlertDelay `json:"alert_delay,omitempty"`

	// Consumer The name of the application or feature that owns the rule. For example: `alerts`, `apm`, `discover`, `infrastructure`, `logs`, `metrics`, `ml`, `monitoring`, `securitySolution`, `siem`, `stackAlerts`, or `uptime`.
	Consumer Consumer `json:"consumer"`

	// Enabled Indicates whether you want to run the rule on an interval basis after it is created.
	Enabled *EnabledRule `json:"enabled,omitempty"`

	// Name The name of the rule. While this name does not have to be unique, a distinctive name can help you identify a rule.
	Name NameRule `json:"name"`

	// NotifyWhen Deprecated in 8.13.0. Use the `notify_when` property in the action `frequency` object instead. Indicates how often alerts generate actions. NOTE: You cannot specify `notify_when` at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	NotifyWhen *NotifyWhen `json:"notify_when,omitempty"`

	// Params The parameters for an tracking containment rule.
	Params map[string]interface{} `json:"params"`

	// RuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
	RuleTypeId CreateGeoContainmentRuleRequestRuleTypeId `json:"rule_type_id"`

	// Schedule The check interval, which specifies how frequently the rule conditions are checked. The interval is specified in seconds, minutes, hours, or days.
	Schedule Schedule `json:"schedule"`

	// Tags The tags for the rule.
	Tags Tags `json:"tags,omitempty"`

	// Throttle Deprecated in 8.13.0. Use the `throttle` property in the action `frequency` object instead. The throttle interval, which defines how often an alert generates repeated actions. NOTE: You cannot specify the throttle interval at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	Throttle *Throttle `json:"throttle"`
}

// CreateGeoContainmentRuleRequestRuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
type CreateGeoContainmentRuleRequestRuleTypeId string

// CreateIndexThresholdRuleRequest A rule that runs an Elasticsearch query, aggregates field values from documents, compares them to threshold values, and schedules actions to run when the thresholds are met.
type CreateIndexThresholdRuleRequest struct {
	Actions Actions `json:"actions"`

	// AlertDelay Indicates that an alert occurs only when the specified number of consecutive runs met the rule conditions.
	AlertDelay *AlertDelay `json:"alert_delay,omitempty"`

	// Consumer The name of the application or feature that owns the rule. For example: `alerts`, `apm`, `discover`, `infrastructure`, `logs`, `metrics`, `ml`, `monitoring`, `securitySolution`, `siem`, `stackAlerts`, or `uptime`.
	Consumer Consumer `json:"consumer"`

	// Enabled Indicates whether you want to run the rule on an interval basis after it is created.
	Enabled *EnabledRule `json:"enabled,omitempty"`

	// Name The name of the rule. While this name does not have to be unique, a distinctive name can help you identify a rule.
	Name NameRule `json:"name"`

	// NotifyWhen Deprecated in 8.13.0. Use the `notify_when` property in the action `frequency` object instead. Indicates how often alerts generate actions. NOTE: You cannot specify `notify_when` at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	NotifyWhen *NotifyWhen `json:"notify_when,omitempty"`

	// Params The parameters for an index threshold rule.
	Params ParamsIndexThresholdRule `json:"params"`

	// RuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
	RuleTypeId CreateIndexThresholdRuleRequestRuleTypeId `json:"rule_type_id"`

	// Schedule The check interval, which specifies how frequently the rule conditions are checked. The interval is specified in seconds, minutes, hours, or days.
	Schedule Schedule `json:"schedule"`

	// Tags The tags for the rule.
	Tags Tags `json:"tags,omitempty"`

	// Throttle Deprecated in 8.13.0. Use the `throttle` property in the action `frequency` object instead. The throttle interval, which defines how often an alert generates repeated actions. NOTE: You cannot specify the throttle interval at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	Throttle *Throttle `json:"throttle"`
}

// CreateIndexThresholdRuleRequestRuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
type CreateIndexThresholdRuleRequestRuleTypeId string

// CreateInfraInventoryRuleRequest A rule that sends notifications when a metric has reached or exceeded a value for a specific resource or a group of resources within your infrastructure.
type CreateInfraInventoryRuleRequest struct {
	Actions Actions `json:"actions"`

	// AlertDelay Indicates that an alert occurs only when the specified number of consecutive runs met the rule conditions.
	AlertDelay *AlertDelay `json:"alert_delay,omitempty"`

	// Consumer The name of the application or feature that owns the rule. For example: `alerts`, `apm`, `discover`, `infrastructure`, `logs`, `metrics`, `ml`, `monitoring`, `securitySolution`, `siem`, `stackAlerts`, or `uptime`.
	Consumer Consumer `json:"consumer"`

	// Enabled Indicates whether you want to run the rule on an interval basis after it is created.
	Enabled *EnabledRule `json:"enabled,omitempty"`

	// Name The name of the rule. While this name does not have to be unique, a distinctive name can help you identify a rule.
	Name NameRule `json:"name"`

	// NotifyWhen Deprecated in 8.13.0. Use the `notify_when` property in the action `frequency` object instead. Indicates how often alerts generate actions. NOTE: You cannot specify `notify_when` at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	NotifyWhen *NotifyWhen                  `json:"notify_when,omitempty"`
	Params     ParamsPropertyInfraInventory `json:"params"`

	// RuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
	RuleTypeId CreateInfraInventoryRuleRequestRuleTypeId `json:"rule_type_id"`

	// Schedule The check interval, which specifies how frequently the rule conditions are checked. The interval is specified in seconds, minutes, hours, or days.
	Schedule Schedule `json:"schedule"`

	// Tags The tags for the rule.
	Tags Tags `json:"tags,omitempty"`

	// Throttle Deprecated in 8.13.0. Use the `throttle` property in the action `frequency` object instead. The throttle interval, which defines how often an alert generates repeated actions. NOTE: You cannot specify the throttle interval at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	Throttle *Throttle `json:"throttle"`
}

// CreateInfraInventoryRuleRequestRuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
type CreateInfraInventoryRuleRequestRuleTypeId string

// CreateInfraMetricAnomalyRuleRequest defines model for create_infra_metric_anomaly_rule_request.
type CreateInfraMetricAnomalyRuleRequest struct {
	Actions Actions `json:"actions"`

	// AlertDelay Indicates that an alert occurs only when the specified number of consecutive runs met the rule conditions.
	AlertDelay *AlertDelay `json:"alert_delay,omitempty"`

	// Consumer The name of the application or feature that owns the rule. For example: `alerts`, `apm`, `discover`, `infrastructure`, `logs`, `metrics`, `ml`, `monitoring`, `securitySolution`, `siem`, `stackAlerts`, or `uptime`.
	Consumer Consumer `json:"consumer"`

	// Enabled Indicates whether you want to run the rule on an interval basis after it is created.
	Enabled *EnabledRule `json:"enabled,omitempty"`

	// Name The name of the rule. While this name does not have to be unique, a distinctive name can help you identify a rule.
	Name NameRule `json:"name"`

	// NotifyWhen Deprecated in 8.13.0. Use the `notify_when` property in the action `frequency` object instead. Indicates how often alerts generate actions. NOTE: You cannot specify `notify_when` at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	NotifyWhen *NotifyWhen `json:"notify_when,omitempty"`

	// Params The parameters for an infrastructure anomaly rule.
	Params map[string]interface{} `json:"params"`

	// RuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
	RuleTypeId CreateInfraMetricAnomalyRuleRequestRuleTypeId `json:"rule_type_id"`

	// Schedule The check interval, which specifies how frequently the rule conditions are checked. The interval is specified in seconds, minutes, hours, or days.
	Schedule Schedule `json:"schedule"`

	// Tags The tags for the rule.
	Tags Tags `json:"tags,omitempty"`

	// Throttle Deprecated in 8.13.0. Use the `throttle` property in the action `frequency` object instead. The throttle interval, which defines how often an alert generates repeated actions. NOTE: You cannot specify the throttle interval at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	Throttle *Throttle `json:"throttle"`
}

// CreateInfraMetricAnomalyRuleRequestRuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
type CreateInfraMetricAnomalyRuleRequestRuleTypeId string

// CreateInfraMetricThresholdRuleRequest A rule that sends notifications when a metric has reached or exceeded a value for a specific time period.
type CreateInfraMetricThresholdRuleRequest struct {
	Actions Actions `json:"actions"`

	// AlertDelay Indicates that an alert occurs only when the specified number of consecutive runs met the rule conditions.
	AlertDelay *AlertDelay `json:"alert_delay,omitempty"`

	// Consumer The name of the application or feature that owns the rule. For example: `alerts`, `apm`, `discover`, `infrastructure`, `logs`, `metrics`, `ml`, `monitoring`, `securitySolution`, `siem`, `stackAlerts`, or `uptime`.
	Consumer Consumer `json:"consumer"`

	// Enabled Indicates whether you want to run the rule on an interval basis after it is created.
	Enabled *EnabledRule `json:"enabled,omitempty"`

	// Name The name of the rule. While this name does not have to be unique, a distinctive name can help you identify a rule.
	Name NameRule `json:"name"`

	// NotifyWhen Deprecated in 8.13.0. Use the `notify_when` property in the action `frequency` object instead. Indicates how often alerts generate actions. NOTE: You cannot specify `notify_when` at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	NotifyWhen *NotifyWhen                        `json:"notify_when,omitempty"`
	Params     ParamsPropertyInfraMetricThreshold `json:"params"`

	// RuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
	RuleTypeId CreateInfraMetricThresholdRuleRequestRuleTypeId `json:"rule_type_id"`

	// Schedule The check interval, which specifies how frequently the rule conditions are checked. The interval is specified in seconds, minutes, hours, or days.
	Schedule Schedule `json:"schedule"`

	// Tags The tags for the rule.
	Tags Tags `json:"tags,omitempty"`

	// Throttle Deprecated in 8.13.0. Use the `throttle` property in the action `frequency` object instead. The throttle interval, which defines how often an alert generates repeated actions. NOTE: You cannot specify the throttle interval at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	Throttle *Throttle `json:"throttle"`
}

// CreateInfraMetricThresholdRuleRequestRuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
type CreateInfraMetricThresholdRuleRequestRuleTypeId string

// CreateLogThresholdRuleRequest A rule that detects when a log aggregation exceeds a threshold.
type CreateLogThresholdRuleRequest struct {
	Actions Actions `json:"actions"`

	// AlertDelay Indicates that an alert occurs only when the specified number of consecutive runs met the rule conditions.
	AlertDelay *AlertDelay `json:"alert_delay,omitempty"`

	// Consumer The name of the application or feature that owns the rule. For example: `alerts`, `apm`, `discover`, `infrastructure`, `logs`, `metrics`, `ml`, `monitoring`, `securitySolution`, `siem`, `stackAlerts`, or `uptime`.
	Consumer Consumer `json:"consumer"`

	// Enabled Indicates whether you want to run the rule on an interval basis after it is created.
	Enabled *EnabledRule `json:"enabled,omitempty"`

	// Name The name of the rule. While this name does not have to be unique, a distinctive name can help you identify a rule.
	Name NameRule `json:"name"`

	// NotifyWhen Deprecated in 8.13.0. Use the `notify_when` property in the action `frequency` object instead. Indicates how often alerts generate actions. NOTE: You cannot specify `notify_when` at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	NotifyWhen *NotifyWhen                `json:"notify_when,omitempty"`
	Params     ParamsPropertyLogThreshold `json:"params"`

	// RuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
	RuleTypeId CreateLogThresholdRuleRequestRuleTypeId `json:"rule_type_id"`

	// Schedule The check interval, which specifies how frequently the rule conditions are checked. The interval is specified in seconds, minutes, hours, or days.
	Schedule Schedule `json:"schedule"`

	// Tags The tags for the rule.
	Tags Tags `json:"tags,omitempty"`

	// Throttle Deprecated in 8.13.0. Use the `throttle` property in the action `frequency` object instead. The throttle interval, which defines how often an alert generates repeated actions. NOTE: You cannot specify the throttle interval at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	Throttle *Throttle `json:"throttle"`
}

// CreateLogThresholdRuleRequestRuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
type CreateLogThresholdRuleRequestRuleTypeId string

// CreateMonitoringCcrExceptionsRuleRequest A rule that detects cross-cluster replication (CCR) read exceptions.
type CreateMonitoringCcrExceptionsRuleRequest struct {
	Actions Actions `json:"actions"`

	// Consumer The name of the application or feature that owns the rule. For example: `alerts`, `apm`, `discover`, `infrastructure`, `logs`, `metrics`, `ml`, `monitoring`, `securitySolution`, `siem`, `stackAlerts`, or `uptime`.
	Consumer Consumer `json:"consumer"`

	// Enabled Indicates whether you want to run the rule on an interval basis after it is created.
	Enabled *EnabledRule `json:"enabled,omitempty"`

	// Name The name of the rule. While this name does not have to be unique, a distinctive name can help you identify a rule.
	Name NameRule `json:"name"`

	// NotifyWhen Deprecated in 8.13.0. Use the `notify_when` property in the action `frequency` object instead. Indicates how often alerts generate actions. NOTE: You cannot specify `notify_when` at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	NotifyWhen *NotifyWhen `json:"notify_when,omitempty"`

	// Params The parameters for a CCR read exceptions rule.
	Params map[string]interface{} `json:"params"`

	// RuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
	RuleTypeId CreateMonitoringCcrExceptionsRuleRequestRuleTypeId `json:"rule_type_id"`

	// Schedule The check interval, which specifies how frequently the rule conditions are checked. The interval is specified in seconds, minutes, hours, or days.
	Schedule Schedule `json:"schedule"`

	// Tags The tags for the rule.
	Tags Tags `json:"tags,omitempty"`

	// Throttle Deprecated in 8.13.0. Use the `throttle` property in the action `frequency` object instead. The throttle interval, which defines how often an alert generates repeated actions. NOTE: You cannot specify the throttle interval at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	Throttle *Throttle `json:"throttle"`
}

// CreateMonitoringCcrExceptionsRuleRequestRuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
type CreateMonitoringCcrExceptionsRuleRequestRuleTypeId string

// CreateMonitoringClusterHealthRuleRequest A rule that detects when the health of the cluster changes.
type CreateMonitoringClusterHealthRuleRequest struct {
	Actions Actions `json:"actions"`

	// Consumer The name of the application or feature that owns the rule. For example: `alerts`, `apm`, `discover`, `infrastructure`, `logs`, `metrics`, `ml`, `monitoring`, `securitySolution`, `siem`, `stackAlerts`, or `uptime`.
	Consumer Consumer `json:"consumer"`

	// Enabled Indicates whether you want to run the rule on an interval basis after it is created.
	Enabled *EnabledRule `json:"enabled,omitempty"`

	// Name The name of the rule. While this name does not have to be unique, a distinctive name can help you identify a rule.
	Name NameRule `json:"name"`

	// NotifyWhen Deprecated in 8.13.0. Use the `notify_when` property in the action `frequency` object instead. Indicates how often alerts generate actions. NOTE: You cannot specify `notify_when` at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	NotifyWhen *NotifyWhen `json:"notify_when,omitempty"`

	// Params The parameters for a cluster health rule.
	Params map[string]interface{} `json:"params"`

	// RuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
	RuleTypeId CreateMonitoringClusterHealthRuleRequestRuleTypeId `json:"rule_type_id"`

	// Schedule The check interval, which specifies how frequently the rule conditions are checked. The interval is specified in seconds, minutes, hours, or days.
	Schedule Schedule `json:"schedule"`

	// Tags The tags for the rule.
	Tags Tags `json:"tags,omitempty"`

	// Throttle Deprecated in 8.13.0. Use the `throttle` property in the action `frequency` object instead. The throttle interval, which defines how often an alert generates repeated actions. NOTE: You cannot specify the throttle interval at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	Throttle *Throttle `json:"throttle"`
}

// CreateMonitoringClusterHealthRuleRequestRuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
type CreateMonitoringClusterHealthRuleRequestRuleTypeId string

// CreateMonitoringCpuUsageRuleRequest A rule that detects when the CPU load for a node is consistently high.
type CreateMonitoringCpuUsageRuleRequest struct {
	Actions Actions `json:"actions"`

	// Consumer The name of the application or feature that owns the rule. For example: `alerts`, `apm`, `discover`, `infrastructure`, `logs`, `metrics`, `ml`, `monitoring`, `securitySolution`, `siem`, `stackAlerts`, or `uptime`.
	Consumer Consumer `json:"consumer"`

	// Enabled Indicates whether you want to run the rule on an interval basis after it is created.
	Enabled *EnabledRule `json:"enabled,omitempty"`

	// Name The name of the rule. While this name does not have to be unique, a distinctive name can help you identify a rule.
	Name NameRule `json:"name"`

	// NotifyWhen Deprecated in 8.13.0. Use the `notify_when` property in the action `frequency` object instead. Indicates how often alerts generate actions. NOTE: You cannot specify `notify_when` at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	NotifyWhen *NotifyWhen `json:"notify_when,omitempty"`

	// Params The parameters for a CPU usage rule.
	Params map[string]interface{} `json:"params"`

	// RuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
	RuleTypeId CreateMonitoringCpuUsageRuleRequestRuleTypeId `json:"rule_type_id"`

	// Schedule The check interval, which specifies how frequently the rule conditions are checked. The interval is specified in seconds, minutes, hours, or days.
	Schedule Schedule `json:"schedule"`

	// Tags The tags for the rule.
	Tags Tags `json:"tags,omitempty"`

	// Throttle Deprecated in 8.13.0. Use the `throttle` property in the action `frequency` object instead. The throttle interval, which defines how often an alert generates repeated actions. NOTE: You cannot specify the throttle interval at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	Throttle *Throttle `json:"throttle"`
}

// CreateMonitoringCpuUsageRuleRequestRuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
type CreateMonitoringCpuUsageRuleRequestRuleTypeId string

// CreateMonitoringDiskUsageRuleRequest A rule that detects when the disk usage for a node is consistently high.
type CreateMonitoringDiskUsageRuleRequest struct {
	Actions Actions `json:"actions"`

	// Consumer The name of the application or feature that owns the rule. For example: `alerts`, `apm`, `discover`, `infrastructure`, `logs`, `metrics`, `ml`, `monitoring`, `securitySolution`, `siem`, `stackAlerts`, or `uptime`.
	Consumer Consumer `json:"consumer"`

	// Enabled Indicates whether you want to run the rule on an interval basis after it is created.
	Enabled *EnabledRule `json:"enabled,omitempty"`

	// Name The name of the rule. While this name does not have to be unique, a distinctive name can help you identify a rule.
	Name NameRule `json:"name"`

	// NotifyWhen Deprecated in 8.13.0. Use the `notify_when` property in the action `frequency` object instead. Indicates how often alerts generate actions. NOTE: You cannot specify `notify_when` at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	NotifyWhen *NotifyWhen `json:"notify_when,omitempty"`

	// Params The parameters for a disk usage rule.
	Params map[string]interface{} `json:"params"`

	// RuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
	RuleTypeId CreateMonitoringDiskUsageRuleRequestRuleTypeId `json:"rule_type_id"`

	// Schedule The check interval, which specifies how frequently the rule conditions are checked. The interval is specified in seconds, minutes, hours, or days.
	Schedule Schedule `json:"schedule"`

	// Tags The tags for the rule.
	Tags Tags `json:"tags,omitempty"`

	// Throttle Deprecated in 8.13.0. Use the `throttle` property in the action `frequency` object instead. The throttle interval, which defines how often an alert generates repeated actions. NOTE: You cannot specify the throttle interval at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	Throttle *Throttle `json:"throttle"`
}

// CreateMonitoringDiskUsageRuleRequestRuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
type CreateMonitoringDiskUsageRuleRequestRuleTypeId string

// CreateMonitoringElasticsearchVersionMismatchRuleRequest A rule that detects when the cluster has multipe versions of Elasticsearch.
type CreateMonitoringElasticsearchVersionMismatchRuleRequest struct {
	Actions Actions `json:"actions"`

	// Consumer The name of the application or feature that owns the rule. For example: `alerts`, `apm`, `discover`, `infrastructure`, `logs`, `metrics`, `ml`, `monitoring`, `securitySolution`, `siem`, `stackAlerts`, or `uptime`.
	Consumer Consumer `json:"consumer"`

	// Enabled Indicates whether you want to run the rule on an interval basis after it is created.
	Enabled *EnabledRule `json:"enabled,omitempty"`

	// Name The name of the rule. While this name does not have to be unique, a distinctive name can help you identify a rule.
	Name NameRule `json:"name"`

	// NotifyWhen Deprecated in 8.13.0. Use the `notify_when` property in the action `frequency` object instead. Indicates how often alerts generate actions. NOTE: You cannot specify `notify_when` at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	NotifyWhen *NotifyWhen `json:"notify_when,omitempty"`

	// Params The parameters for a Elasticsearch version mismatch rule.
	Params map[string]interface{} `json:"params"`

	// RuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
	RuleTypeId CreateMonitoringElasticsearchVersionMismatchRuleRequestRuleTypeId `json:"rule_type_id"`

	// Schedule The check interval, which specifies how frequently the rule conditions are checked. The interval is specified in seconds, minutes, hours, or days.
	Schedule Schedule `json:"schedule"`

	// Tags The tags for the rule.
	Tags Tags `json:"tags,omitempty"`

	// Throttle Deprecated in 8.13.0. Use the `throttle` property in the action `frequency` object instead. The throttle interval, which defines how often an alert generates repeated actions. NOTE: You cannot specify the throttle interval at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	Throttle *Throttle `json:"throttle"`
}

// CreateMonitoringElasticsearchVersionMismatchRuleRequestRuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
type CreateMonitoringElasticsearchVersionMismatchRuleRequestRuleTypeId string

// CreateMonitoringJvmMemoryUsageRuleRequest A rule that detects when a node reports high memory usage.
type CreateMonitoringJvmMemoryUsageRuleRequest struct {
	Actions Actions `json:"actions"`

	// Consumer The name of the application or feature that owns the rule. For example: `alerts`, `apm`, `discover`, `infrastructure`, `logs`, `metrics`, `ml`, `monitoring`, `securitySolution`, `siem`, `stackAlerts`, or `uptime`.
	Consumer Consumer `json:"consumer"`

	// Enabled Indicates whether you want to run the rule on an interval basis after it is created.
	Enabled *EnabledRule `json:"enabled,omitempty"`

	// Name The name of the rule. While this name does not have to be unique, a distinctive name can help you identify a rule.
	Name NameRule `json:"name"`

	// NotifyWhen Deprecated in 8.13.0. Use the `notify_when` property in the action `frequency` object instead. Indicates how often alerts generate actions. NOTE: You cannot specify `notify_when` at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	NotifyWhen *NotifyWhen `json:"notify_when,omitempty"`

	// Params The parameters for a JVM memory usage rule.
	Params map[string]interface{} `json:"params"`

	// RuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
	RuleTypeId CreateMonitoringJvmMemoryUsageRuleRequestRuleTypeId `json:"rule_type_id"`

	// Schedule The check interval, which specifies how frequently the rule conditions are checked. The interval is specified in seconds, minutes, hours, or days.
	Schedule Schedule `json:"schedule"`

	// Tags The tags for the rule.
	Tags Tags `json:"tags,omitempty"`

	// Throttle Deprecated in 8.13.0. Use the `throttle` property in the action `frequency` object instead. The throttle interval, which defines how often an alert generates repeated actions. NOTE: You cannot specify the throttle interval at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	Throttle *Throttle `json:"throttle"`
}

// CreateMonitoringJvmMemoryUsageRuleRequestRuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
type CreateMonitoringJvmMemoryUsageRuleRequestRuleTypeId string

// CreateMonitoringKibanaVersionMismatchRuleRequest A rule that detects when the cluster has multiple versions of Kibana.
type CreateMonitoringKibanaVersionMismatchRuleRequest struct {
	Actions Actions `json:"actions"`

	// Consumer The name of the application or feature that owns the rule. For example: `alerts`, `apm`, `discover`, `infrastructure`, `logs`, `metrics`, `ml`, `monitoring`, `securitySolution`, `siem`, `stackAlerts`, or `uptime`.
	Consumer Consumer `json:"consumer"`

	// Enabled Indicates whether you want to run the rule on an interval basis after it is created.
	Enabled *EnabledRule `json:"enabled,omitempty"`

	// Name The name of the rule. While this name does not have to be unique, a distinctive name can help you identify a rule.
	Name NameRule `json:"name"`

	// NotifyWhen Deprecated in 8.13.0. Use the `notify_when` property in the action `frequency` object instead. Indicates how often alerts generate actions. NOTE: You cannot specify `notify_when` at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	NotifyWhen *NotifyWhen `json:"notify_when,omitempty"`

	// Params The parameters for a Kibana version mismatch rule.
	Params map[string]interface{} `json:"params"`

	// RuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
	RuleTypeId CreateMonitoringKibanaVersionMismatchRuleRequestRuleTypeId `json:"rule_type_id"`

	// Schedule The check interval, which specifies how frequently the rule conditions are checked. The interval is specified in seconds, minutes, hours, or days.
	Schedule Schedule `json:"schedule"`

	// Tags The tags for the rule.
	Tags Tags `json:"tags,omitempty"`

	// Throttle Deprecated in 8.13.0. Use the `throttle` property in the action `frequency` object instead. The throttle interval, which defines how often an alert generates repeated actions. NOTE: You cannot specify the throttle interval at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	Throttle *Throttle `json:"throttle"`
}

// CreateMonitoringKibanaVersionMismatchRuleRequestRuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
type CreateMonitoringKibanaVersionMismatchRuleRequestRuleTypeId string

// CreateMonitoringLicenseExpirationRuleRequest A rule that detects when the cluster license is about to expire.
type CreateMonitoringLicenseExpirationRuleRequest struct {
	Actions Actions `json:"actions"`

	// Consumer The name of the application or feature that owns the rule. For example: `alerts`, `apm`, `discover`, `infrastructure`, `logs`, `metrics`, `ml`, `monitoring`, `securitySolution`, `siem`, `stackAlerts`, or `uptime`.
	Consumer Consumer `json:"consumer"`

	// Enabled Indicates whether you want to run the rule on an interval basis after it is created.
	Enabled *EnabledRule `json:"enabled,omitempty"`

	// Name The name of the rule. While this name does not have to be unique, a distinctive name can help you identify a rule.
	Name NameRule `json:"name"`

	// NotifyWhen Deprecated in 8.13.0. Use the `notify_when` property in the action `frequency` object instead. Indicates how often alerts generate actions. NOTE: You cannot specify `notify_when` at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	NotifyWhen *NotifyWhen `json:"notify_when,omitempty"`

	// Params The parameters for a license expiration rule.
	Params map[string]interface{} `json:"params"`

	// RuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
	RuleTypeId CreateMonitoringLicenseExpirationRuleRequestRuleTypeId `json:"rule_type_id"`

	// Schedule The check interval, which specifies how frequently the rule conditions are checked. The interval is specified in seconds, minutes, hours, or days.
	Schedule Schedule `json:"schedule"`

	// Tags The tags for the rule.
	Tags Tags `json:"tags,omitempty"`

	// Throttle Deprecated in 8.13.0. Use the `throttle` property in the action `frequency` object instead. The throttle interval, which defines how often an alert generates repeated actions. NOTE: You cannot specify the throttle interval at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	Throttle *Throttle `json:"throttle"`
}

// CreateMonitoringLicenseExpirationRuleRequestRuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
type CreateMonitoringLicenseExpirationRuleRequestRuleTypeId string

// CreateMonitoringLogstashVersionMismatchRuleRequest A rule that detects when the cluster has multiple versions of Logstash.
type CreateMonitoringLogstashVersionMismatchRuleRequest struct {
	Actions Actions `json:"actions"`

	// Consumer The name of the application or feature that owns the rule. For example: `alerts`, `apm`, `discover`, `infrastructure`, `logs`, `metrics`, `ml`, `monitoring`, `securitySolution`, `siem`, `stackAlerts`, or `uptime`.
	Consumer Consumer `json:"consumer"`

	// Enabled Indicates whether you want to run the rule on an interval basis after it is created.
	Enabled *EnabledRule `json:"enabled,omitempty"`

	// Name The name of the rule. While this name does not have to be unique, a distinctive name can help you identify a rule.
	Name NameRule `json:"name"`

	// NotifyWhen Deprecated in 8.13.0. Use the `notify_when` property in the action `frequency` object instead. Indicates how often alerts generate actions. NOTE: You cannot specify `notify_when` at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	NotifyWhen *NotifyWhen `json:"notify_when,omitempty"`

	// Params The parameters for a Logstash version mismatch rule.
	Params map[string]interface{} `json:"params"`

	// RuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
	RuleTypeId CreateMonitoringLogstashVersionMismatchRuleRequestRuleTypeId `json:"rule_type_id"`

	// Schedule The check interval, which specifies how frequently the rule conditions are checked. The interval is specified in seconds, minutes, hours, or days.
	Schedule Schedule `json:"schedule"`

	// Tags The tags for the rule.
	Tags Tags `json:"tags,omitempty"`

	// Throttle Deprecated in 8.13.0. Use the `throttle` property in the action `frequency` object instead. The throttle interval, which defines how often an alert generates repeated actions. NOTE: You cannot specify the throttle interval at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	Throttle *Throttle `json:"throttle"`
}

// CreateMonitoringLogstashVersionMismatchRuleRequestRuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
type CreateMonitoringLogstashVersionMismatchRuleRequestRuleTypeId string

// CreateMonitoringMissingDataRuleRequest A rule that detects when monitoring data is missing.
type CreateMonitoringMissingDataRuleRequest struct {
	Actions Actions `json:"actions"`

	// Consumer The name of the application or feature that owns the rule. For example: `alerts`, `apm`, `discover`, `infrastructure`, `logs`, `metrics`, `ml`, `monitoring`, `securitySolution`, `siem`, `stackAlerts`, or `uptime`.
	Consumer Consumer `json:"consumer"`

	// Enabled Indicates whether you want to run the rule on an interval basis after it is created.
	Enabled *EnabledRule `json:"enabled,omitempty"`

	// Name The name of the rule. While this name does not have to be unique, a distinctive name can help you identify a rule.
	Name NameRule `json:"name"`

	// NotifyWhen Deprecated in 8.13.0. Use the `notify_when` property in the action `frequency` object instead. Indicates how often alerts generate actions. NOTE: You cannot specify `notify_when` at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	NotifyWhen *NotifyWhen `json:"notify_when,omitempty"`

	// Params The parameters for a missing monitoring data rule.
	Params map[string]interface{} `json:"params"`

	// RuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
	RuleTypeId CreateMonitoringMissingDataRuleRequestRuleTypeId `json:"rule_type_id"`

	// Schedule The check interval, which specifies how frequently the rule conditions are checked. The interval is specified in seconds, minutes, hours, or days.
	Schedule Schedule `json:"schedule"`

	// Tags The tags for the rule.
	Tags Tags `json:"tags,omitempty"`

	// Throttle Deprecated in 8.13.0. Use the `throttle` property in the action `frequency` object instead. The throttle interval, which defines how often an alert generates repeated actions. NOTE: You cannot specify the throttle interval at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	Throttle *Throttle `json:"throttle"`
}

// CreateMonitoringMissingDataRuleRequestRuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
type CreateMonitoringMissingDataRuleRequestRuleTypeId string

// CreateMonitoringNodesChangedRuleRequest A rule that detects when nodes are added, removed, or restarted.
type CreateMonitoringNodesChangedRuleRequest struct {
	Actions Actions `json:"actions"`

	// Consumer The name of the application or feature that owns the rule. For example: `alerts`, `apm`, `discover`, `infrastructure`, `logs`, `metrics`, `ml`, `monitoring`, `securitySolution`, `siem`, `stackAlerts`, or `uptime`.
	Consumer Consumer `json:"consumer"`

	// Enabled Indicates whether you want to run the rule on an interval basis after it is created.
	Enabled *EnabledRule `json:"enabled,omitempty"`

	// Name The name of the rule. While this name does not have to be unique, a distinctive name can help you identify a rule.
	Name NameRule `json:"name"`

	// NotifyWhen Deprecated in 8.13.0. Use the `notify_when` property in the action `frequency` object instead. Indicates how often alerts generate actions. NOTE: You cannot specify `notify_when` at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	NotifyWhen *NotifyWhen `json:"notify_when,omitempty"`

	// Params The parameters for a nodes changed rule.
	Params map[string]interface{} `json:"params"`

	// RuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
	RuleTypeId CreateMonitoringNodesChangedRuleRequestRuleTypeId `json:"rule_type_id"`

	// Schedule The check interval, which specifies how frequently the rule conditions are checked. The interval is specified in seconds, minutes, hours, or days.
	Schedule Schedule `json:"schedule"`

	// Tags The tags for the rule.
	Tags Tags `json:"tags,omitempty"`

	// Throttle Deprecated in 8.13.0. Use the `throttle` property in the action `frequency` object instead. The throttle interval, which defines how often an alert generates repeated actions. NOTE: You cannot specify the throttle interval at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	Throttle *Throttle `json:"throttle"`
}

// CreateMonitoringNodesChangedRuleRequestRuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
type CreateMonitoringNodesChangedRuleRequestRuleTypeId string

// CreateMonitoringShardSizeRuleRequest A rule that detects when the average shard size is larger than a threshold.
type CreateMonitoringShardSizeRuleRequest struct {
	Actions Actions `json:"actions"`

	// Consumer The name of the application or feature that owns the rule. For example: `alerts`, `apm`, `discover`, `infrastructure`, `logs`, `metrics`, `ml`, `monitoring`, `securitySolution`, `siem`, `stackAlerts`, or `uptime`.
	Consumer Consumer `json:"consumer"`

	// Enabled Indicates whether you want to run the rule on an interval basis after it is created.
	Enabled *EnabledRule `json:"enabled,omitempty"`

	// Name The name of the rule. While this name does not have to be unique, a distinctive name can help you identify a rule.
	Name NameRule `json:"name"`

	// NotifyWhen Deprecated in 8.13.0. Use the `notify_when` property in the action `frequency` object instead. Indicates how often alerts generate actions. NOTE: You cannot specify `notify_when` at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	NotifyWhen *NotifyWhen `json:"notify_when,omitempty"`

	// Params The parameters for a shard size rule.
	Params map[string]interface{} `json:"params"`

	// RuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
	RuleTypeId CreateMonitoringShardSizeRuleRequestRuleTypeId `json:"rule_type_id"`

	// Schedule The check interval, which specifies how frequently the rule conditions are checked. The interval is specified in seconds, minutes, hours, or days.
	Schedule Schedule `json:"schedule"`

	// Tags The tags for the rule.
	Tags Tags `json:"tags,omitempty"`

	// Throttle Deprecated in 8.13.0. Use the `throttle` property in the action `frequency` object instead. The throttle interval, which defines how often an alert generates repeated actions. NOTE: You cannot specify the throttle interval at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	Throttle *Throttle `json:"throttle"`
}

// CreateMonitoringShardSizeRuleRequestRuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
type CreateMonitoringShardSizeRuleRequestRuleTypeId string

// CreateMonitoringThreadPoolSearchRejectionsRuleRequest A rule that detects when the number of rejections in the thread pool exceeds a threshold.
type CreateMonitoringThreadPoolSearchRejectionsRuleRequest struct {
	Actions Actions `json:"actions"`

	// Consumer The name of the application or feature that owns the rule. For example: `alerts`, `apm`, `discover`, `infrastructure`, `logs`, `metrics`, `ml`, `monitoring`, `securitySolution`, `siem`, `stackAlerts`, or `uptime`.
	Consumer Consumer `json:"consumer"`

	// Enabled Indicates whether you want to run the rule on an interval basis after it is created.
	Enabled *EnabledRule `json:"enabled,omitempty"`

	// Name The name of the rule. While this name does not have to be unique, a distinctive name can help you identify a rule.
	Name NameRule `json:"name"`

	// NotifyWhen Deprecated in 8.13.0. Use the `notify_when` property in the action `frequency` object instead. Indicates how often alerts generate actions. NOTE: You cannot specify `notify_when` at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	NotifyWhen *NotifyWhen `json:"notify_when,omitempty"`

	// Params The parameters for a thread pool search rejections rule.
	Params map[string]interface{} `json:"params"`

	// RuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
	RuleTypeId CreateMonitoringThreadPoolSearchRejectionsRuleRequestRuleTypeId `json:"rule_type_id"`

	// Schedule The check interval, which specifies how frequently the rule conditions are checked. The interval is specified in seconds, minutes, hours, or days.
	Schedule Schedule `json:"schedule"`

	// Tags The tags for the rule.
	Tags Tags `json:"tags,omitempty"`

	// Throttle Deprecated in 8.13.0. Use the `throttle` property in the action `frequency` object instead. The throttle interval, which defines how often an alert generates repeated actions. NOTE: You cannot specify the throttle interval at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	Throttle *Throttle `json:"throttle"`
}

// CreateMonitoringThreadPoolSearchRejectionsRuleRequestRuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
type CreateMonitoringThreadPoolSearchRejectionsRuleRequestRuleTypeId string

// CreateMonitoringThreadPoolWriteRejectionsRuleRequest A rule that detects when the number of rejections in the write thread pool exceeds a threshold.
type CreateMonitoringThreadPoolWriteRejectionsRuleRequest struct {
	Actions Actions `json:"actions"`

	// Consumer The name of the application or feature that owns the rule. For example: `alerts`, `apm`, `discover`, `infrastructure`, `logs`, `metrics`, `ml`, `monitoring`, `securitySolution`, `siem`, `stackAlerts`, or `uptime`.
	Consumer Consumer `json:"consumer"`

	// Enabled Indicates whether you want to run the rule on an interval basis after it is created.
	Enabled *EnabledRule `json:"enabled,omitempty"`

	// Name The name of the rule. While this name does not have to be unique, a distinctive name can help you identify a rule.
	Name NameRule `json:"name"`

	// NotifyWhen Deprecated in 8.13.0. Use the `notify_when` property in the action `frequency` object instead. Indicates how often alerts generate actions. NOTE: You cannot specify `notify_when` at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	NotifyWhen *NotifyWhen `json:"notify_when,omitempty"`

	// Params The parameters for a thread pool write rejections rule.
	Params map[string]interface{} `json:"params"`

	// RuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
	RuleTypeId CreateMonitoringThreadPoolWriteRejectionsRuleRequestRuleTypeId `json:"rule_type_id"`

	// Schedule The check interval, which specifies how frequently the rule conditions are checked. The interval is specified in seconds, minutes, hours, or days.
	Schedule Schedule `json:"schedule"`

	// Tags The tags for the rule.
	Tags Tags `json:"tags,omitempty"`

	// Throttle Deprecated in 8.13.0. Use the `throttle` property in the action `frequency` object instead. The throttle interval, which defines how often an alert generates repeated actions. NOTE: You cannot specify the throttle interval at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	Throttle *Throttle `json:"throttle"`
}

// CreateMonitoringThreadPoolWriteRejectionsRuleRequestRuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
type CreateMonitoringThreadPoolWriteRejectionsRuleRequestRuleTypeId string

// CreateRuleRequest The properties vary depending on the rule type.
type CreateRuleRequest struct {
	union json.RawMessage
}

// CreateSiemEqlRuleRequest A rule that uses Event Query Language (EQL) to match events, generate sequences, and stack data.
type CreateSiemEqlRuleRequest struct {
	Actions Actions `json:"actions"`

	// Consumer The name of the application or feature that owns the rule. For example: `alerts`, `apm`, `discover`, `infrastructure`, `logs`, `metrics`, `ml`, `monitoring`, `securitySolution`, `siem`, `stackAlerts`, or `uptime`.
	Consumer Consumer `json:"consumer"`

	// Enabled Indicates whether you want to run the rule on an interval basis after it is created.
	Enabled *EnabledRule `json:"enabled,omitempty"`

	// Name The name of the rule. While this name does not have to be unique, a distinctive name can help you identify a rule.
	Name NameRule `json:"name"`

	// NotifyWhen Deprecated in 8.13.0. Use the `notify_when` property in the action `frequency` object instead. Indicates how often alerts generate actions. NOTE: You cannot specify `notify_when` at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	NotifyWhen *NotifyWhen `json:"notify_when,omitempty"`

	// Params The parameters for an event correlation rule.
	Params map[string]interface{} `json:"params"`

	// RuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
	RuleTypeId CreateSiemEqlRuleRequestRuleTypeId `json:"rule_type_id"`

	// Schedule The check interval, which specifies how frequently the rule conditions are checked. The interval is specified in seconds, minutes, hours, or days.
	Schedule Schedule `json:"schedule"`

	// Tags The tags for the rule.
	Tags Tags `json:"tags,omitempty"`

	// Throttle Deprecated in 8.13.0. Use the `throttle` property in the action `frequency` object instead. The throttle interval, which defines how often an alert generates repeated actions. NOTE: You cannot specify the throttle interval at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	Throttle *Throttle `json:"throttle"`
}

// CreateSiemEqlRuleRequestRuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
type CreateSiemEqlRuleRequestRuleTypeId string

// CreateSiemIndicatorRuleRequest A rule that uses indicators from intelligence sources to detect matching events and alerts.
type CreateSiemIndicatorRuleRequest struct {
	Actions Actions `json:"actions"`

	// Consumer The name of the application or feature that owns the rule. For example: `alerts`, `apm`, `discover`, `infrastructure`, `logs`, `metrics`, `ml`, `monitoring`, `securitySolution`, `siem`, `stackAlerts`, or `uptime`.
	Consumer Consumer `json:"consumer"`

	// Enabled Indicates whether you want to run the rule on an interval basis after it is created.
	Enabled *EnabledRule `json:"enabled,omitempty"`

	// Name The name of the rule. While this name does not have to be unique, a distinctive name can help you identify a rule.
	Name NameRule `json:"name"`

	// NotifyWhen Deprecated in 8.13.0. Use the `notify_when` property in the action `frequency` object instead. Indicates how often alerts generate actions. NOTE: You cannot specify `notify_when` at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	NotifyWhen *NotifyWhen `json:"notify_when,omitempty"`

	// Params The parameters for an indicator match rule.
	Params map[string]interface{} `json:"params"`

	// RuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
	RuleTypeId CreateSiemIndicatorRuleRequestRuleTypeId `json:"rule_type_id"`

	// Schedule The check interval, which specifies how frequently the rule conditions are checked. The interval is specified in seconds, minutes, hours, or days.
	Schedule Schedule `json:"schedule"`

	// Tags The tags for the rule.
	Tags Tags `json:"tags,omitempty"`

	// Throttle Deprecated in 8.13.0. Use the `throttle` property in the action `frequency` object instead. The throttle interval, which defines how often an alert generates repeated actions. NOTE: You cannot specify the throttle interval at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	Throttle *Throttle `json:"throttle"`
}

// CreateSiemIndicatorRuleRequestRuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
type CreateSiemIndicatorRuleRequestRuleTypeId string

// CreateSiemMlRuleRequest A rule that detects when a machine learning job discovers an anomaly above the defined threshold.
type CreateSiemMlRuleRequest struct {
	Actions Actions `json:"actions"`

	// Consumer The name of the application or feature that owns the rule. For example: `alerts`, `apm`, `discover`, `infrastructure`, `logs`, `metrics`, `ml`, `monitoring`, `securitySolution`, `siem`, `stackAlerts`, or `uptime`.
	Consumer Consumer `json:"consumer"`

	// Enabled Indicates whether you want to run the rule on an interval basis after it is created.
	Enabled *EnabledRule `json:"enabled,omitempty"`

	// Name The name of the rule. While this name does not have to be unique, a distinctive name can help you identify a rule.
	Name NameRule `json:"name"`

	// NotifyWhen Deprecated in 8.13.0. Use the `notify_when` property in the action `frequency` object instead. Indicates how often alerts generate actions. NOTE: You cannot specify `notify_when` at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	NotifyWhen *NotifyWhen `json:"notify_when,omitempty"`

	// Params The parameters for a machine learning rule.
	Params map[string]interface{} `json:"params"`

	// RuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
	RuleTypeId CreateSiemMlRuleRequestRuleTypeId `json:"rule_type_id"`

	// Schedule The check interval, which specifies how frequently the rule conditions are checked. The interval is specified in seconds, minutes, hours, or days.
	Schedule Schedule `json:"schedule"`

	// Tags The tags for the rule.
	Tags Tags `json:"tags,omitempty"`

	// Throttle Deprecated in 8.13.0. Use the `throttle` property in the action `frequency` object instead. The throttle interval, which defines how often an alert generates repeated actions. NOTE: You cannot specify the throttle interval at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	Throttle *Throttle `json:"throttle"`
}

// CreateSiemMlRuleRequestRuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
type CreateSiemMlRuleRequestRuleTypeId string

// CreateSiemNewTermsRuleRequest A rule that finds documents with values that appear for the first time.
type CreateSiemNewTermsRuleRequest struct {
	Actions Actions `json:"actions"`

	// Consumer The name of the application or feature that owns the rule. For example: `alerts`, `apm`, `discover`, `infrastructure`, `logs`, `metrics`, `ml`, `monitoring`, `securitySolution`, `siem`, `stackAlerts`, or `uptime`.
	Consumer Consumer `json:"consumer"`

	// Enabled Indicates whether you want to run the rule on an interval basis after it is created.
	Enabled *EnabledRule `json:"enabled,omitempty"`

	// Name The name of the rule. While this name does not have to be unique, a distinctive name can help you identify a rule.
	Name NameRule `json:"name"`

	// NotifyWhen Deprecated in 8.13.0. Use the `notify_when` property in the action `frequency` object instead. Indicates how often alerts generate actions. NOTE: You cannot specify `notify_when` at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	NotifyWhen *NotifyWhen `json:"notify_when,omitempty"`

	// Params The parameters for a new terms rule.
	Params map[string]interface{} `json:"params"`

	// RuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
	RuleTypeId CreateSiemNewTermsRuleRequestRuleTypeId `json:"rule_type_id"`

	// Schedule The check interval, which specifies how frequently the rule conditions are checked. The interval is specified in seconds, minutes, hours, or days.
	Schedule Schedule `json:"schedule"`

	// Tags The tags for the rule.
	Tags Tags `json:"tags,omitempty"`

	// Throttle Deprecated in 8.13.0. Use the `throttle` property in the action `frequency` object instead. The throttle interval, which defines how often an alert generates repeated actions. NOTE: You cannot specify the throttle interval at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	Throttle *Throttle `json:"throttle"`
}

// CreateSiemNewTermsRuleRequestRuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
type CreateSiemNewTermsRuleRequestRuleTypeId string

// CreateSiemNotificationsRuleRequest defines model for create_siem_notifications_rule_request.
type CreateSiemNotificationsRuleRequest struct {
	Actions Actions `json:"actions"`

	// Consumer The name of the application or feature that owns the rule. For example: `alerts`, `apm`, `discover`, `infrastructure`, `logs`, `metrics`, `ml`, `monitoring`, `securitySolution`, `siem`, `stackAlerts`, or `uptime`.
	Consumer Consumer `json:"consumer"`

	// Enabled Indicates whether you want to run the rule on an interval basis after it is created.
	Enabled *EnabledRule `json:"enabled,omitempty"`

	// Name The name of the rule. While this name does not have to be unique, a distinctive name can help you identify a rule.
	Name NameRule `json:"name"`

	// NotifyWhen Deprecated in 8.13.0. Use the `notify_when` property in the action `frequency` object instead. Indicates how often alerts generate actions. NOTE: You cannot specify `notify_when` at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	NotifyWhen *NotifyWhen `json:"notify_when,omitempty"`

	// Params The parameters for a notification rule.
	Params map[string]interface{} `json:"params"`

	// RuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
	RuleTypeId CreateSiemNotificationsRuleRequestRuleTypeId `json:"rule_type_id"`

	// Schedule The check interval, which specifies how frequently the rule conditions are checked. The interval is specified in seconds, minutes, hours, or days.
	Schedule Schedule `json:"schedule"`

	// Tags The tags for the rule.
	Tags Tags `json:"tags,omitempty"`

	// Throttle Deprecated in 8.13.0. Use the `throttle` property in the action `frequency` object instead. The throttle interval, which defines how often an alert generates repeated actions. NOTE: You cannot specify the throttle interval at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	Throttle *Throttle `json:"throttle"`
}

// CreateSiemNotificationsRuleRequestRuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
type CreateSiemNotificationsRuleRequestRuleTypeId string

// CreateSiemQueryRuleRequest A rule that uses KQL or Lucene to detect issues across indices.
type CreateSiemQueryRuleRequest struct {
	Actions Actions `json:"actions"`

	// Consumer The name of the application or feature that owns the rule. For example: `alerts`, `apm`, `discover`, `infrastructure`, `logs`, `metrics`, `ml`, `monitoring`, `securitySolution`, `siem`, `stackAlerts`, or `uptime`.
	Consumer Consumer `json:"consumer"`

	// Enabled Indicates whether you want to run the rule on an interval basis after it is created.
	Enabled *EnabledRule `json:"enabled,omitempty"`

	// Name The name of the rule. While this name does not have to be unique, a distinctive name can help you identify a rule.
	Name NameRule `json:"name"`

	// NotifyWhen Deprecated in 8.13.0. Use the `notify_when` property in the action `frequency` object instead. Indicates how often alerts generate actions. NOTE: You cannot specify `notify_when` at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	NotifyWhen *NotifyWhen `json:"notify_when,omitempty"`

	// Params The parameters for a custom query rule.
	Params map[string]interface{} `json:"params"`

	// RuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
	RuleTypeId CreateSiemQueryRuleRequestRuleTypeId `json:"rule_type_id"`

	// Schedule The check interval, which specifies how frequently the rule conditions are checked. The interval is specified in seconds, minutes, hours, or days.
	Schedule Schedule `json:"schedule"`

	// Tags The tags for the rule.
	Tags Tags `json:"tags,omitempty"`

	// Throttle Deprecated in 8.13.0. Use the `throttle` property in the action `frequency` object instead. The throttle interval, which defines how often an alert generates repeated actions. NOTE: You cannot specify the throttle interval at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	Throttle *Throttle `json:"throttle"`
}

// CreateSiemQueryRuleRequestRuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
type CreateSiemQueryRuleRequestRuleTypeId string

// CreateSiemSavedQueryRuleRequest A rule that searches the defined indices and creates an alert when a document matches the saved search.
type CreateSiemSavedQueryRuleRequest struct {
	Actions Actions `json:"actions"`

	// Consumer The name of the application or feature that owns the rule. For example: `alerts`, `apm`, `discover`, `infrastructure`, `logs`, `metrics`, `ml`, `monitoring`, `securitySolution`, `siem`, `stackAlerts`, or `uptime`.
	Consumer Consumer `json:"consumer"`

	// Enabled Indicates whether you want to run the rule on an interval basis after it is created.
	Enabled *EnabledRule `json:"enabled,omitempty"`

	// Name The name of the rule. While this name does not have to be unique, a distinctive name can help you identify a rule.
	Name NameRule `json:"name"`

	// NotifyWhen Deprecated in 8.13.0. Use the `notify_when` property in the action `frequency` object instead. Indicates how often alerts generate actions. NOTE: You cannot specify `notify_when` at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	NotifyWhen *NotifyWhen `json:"notify_when,omitempty"`

	// Params The parameters for a saved query rule.
	Params map[string]interface{} `json:"params"`

	// RuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
	RuleTypeId CreateSiemSavedQueryRuleRequestRuleTypeId `json:"rule_type_id"`

	// Schedule The check interval, which specifies how frequently the rule conditions are checked. The interval is specified in seconds, minutes, hours, or days.
	Schedule Schedule `json:"schedule"`

	// Tags The tags for the rule.
	Tags Tags `json:"tags,omitempty"`

	// Throttle Deprecated in 8.13.0. Use the `throttle` property in the action `frequency` object instead. The throttle interval, which defines how often an alert generates repeated actions. NOTE: You cannot specify the throttle interval at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	Throttle *Throttle `json:"throttle"`
}

// CreateSiemSavedQueryRuleRequestRuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
type CreateSiemSavedQueryRuleRequestRuleTypeId string

// CreateSiemThresholdRuleRequest A rule that aggregates query results to detect when the number of matches exceeds a threshold.
type CreateSiemThresholdRuleRequest struct {
	Actions Actions `json:"actions"`

	// Consumer The name of the application or feature that owns the rule. For example: `alerts`, `apm`, `discover`, `infrastructure`, `logs`, `metrics`, `ml`, `monitoring`, `securitySolution`, `siem`, `stackAlerts`, or `uptime`.
	Consumer Consumer `json:"consumer"`

	// Enabled Indicates whether you want to run the rule on an interval basis after it is created.
	Enabled *EnabledRule `json:"enabled,omitempty"`

	// Name The name of the rule. While this name does not have to be unique, a distinctive name can help you identify a rule.
	Name NameRule `json:"name"`

	// NotifyWhen Deprecated in 8.13.0. Use the `notify_when` property in the action `frequency` object instead. Indicates how often alerts generate actions. NOTE: You cannot specify `notify_when` at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	NotifyWhen *NotifyWhen `json:"notify_when,omitempty"`

	// Params The parameters for a threshold rule.
	Params map[string]interface{} `json:"params"`

	// RuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
	RuleTypeId CreateSiemThresholdRuleRequestRuleTypeId `json:"rule_type_id"`

	// Schedule The check interval, which specifies how frequently the rule conditions are checked. The interval is specified in seconds, minutes, hours, or days.
	Schedule Schedule `json:"schedule"`

	// Tags The tags for the rule.
	Tags Tags `json:"tags,omitempty"`

	// Throttle Deprecated in 8.13.0. Use the `throttle` property in the action `frequency` object instead. The throttle interval, which defines how often an alert generates repeated actions. NOTE: You cannot specify the throttle interval at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	Throttle *Throttle `json:"throttle"`
}

// CreateSiemThresholdRuleRequestRuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
type CreateSiemThresholdRuleRequestRuleTypeId string

// CreateSloBurnRateRuleRequest A rule that detects when the burn rate is above a defined threshold for two different lookback periods. The two periods are a long period and a short period that is 1/12th of the long period. For each lookback period, the burn rate is computed as the error rate divided by the error budget. When the burn rates for both periods surpass the threshold, an alert occurs.
type CreateSloBurnRateRuleRequest struct {
	Actions Actions `json:"actions"`

	// AlertDelay Indicates that an alert occurs only when the specified number of consecutive runs met the rule conditions.
	AlertDelay *AlertDelay `json:"alert_delay,omitempty"`

	// Consumer The name of the application or feature that owns the rule. For example: `alerts`, `apm`, `discover`, `infrastructure`, `logs`, `metrics`, `ml`, `monitoring`, `securitySolution`, `siem`, `stackAlerts`, or `uptime`.
	Consumer Consumer `json:"consumer"`

	// Enabled Indicates whether you want to run the rule on an interval basis after it is created.
	Enabled *EnabledRule `json:"enabled,omitempty"`

	// Name The name of the rule. While this name does not have to be unique, a distinctive name can help you identify a rule.
	Name NameRule `json:"name"`

	// NotifyWhen Deprecated in 8.13.0. Use the `notify_when` property in the action `frequency` object instead. Indicates how often alerts generate actions. NOTE: You cannot specify `notify_when` at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	NotifyWhen *NotifyWhen               `json:"notify_when,omitempty"`
	Params     ParamsPropertySloBurnRate `json:"params"`

	// RuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
	RuleTypeId CreateSloBurnRateRuleRequestRuleTypeId `json:"rule_type_id"`

	// Schedule The check interval, which specifies how frequently the rule conditions are checked. The interval is specified in seconds, minutes, hours, or days.
	Schedule Schedule `json:"schedule"`

	// Tags The tags for the rule.
	Tags Tags `json:"tags,omitempty"`

	// Throttle Deprecated in 8.13.0. Use the `throttle` property in the action `frequency` object instead. The throttle interval, which defines how often an alert generates repeated actions. NOTE: You cannot specify the throttle interval at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	Throttle *Throttle `json:"throttle"`
}

// CreateSloBurnRateRuleRequestRuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
type CreateSloBurnRateRuleRequestRuleTypeId string

// CreateSloRequest The create SLO API request body varies depending on the type of indicator, time window and budgeting method.
type CreateSloRequest struct {
	// BudgetingMethod The budgeting method to use when computing the rollup data.
	BudgetingMethod BudgetingMethod `json:"budgetingMethod"`

	// Description A description for the SLO.
	Description string `json:"description"`

	// GroupBy optional group by field to use to generate an SLO per distinct value
	GroupBy *string `json:"groupBy,omitempty"`

	// Id A optional and unique identifier for the SLO. Must be between 8 and 36 chars
	Id        *string                    `json:"id,omitempty"`
	Indicator CreateSloRequest_Indicator `json:"indicator"`

	// Name A name for the SLO.
	Name string `json:"name"`

	// Objective Defines properties for the SLO objective
	Objective Objective `json:"objective"`

	// Settings Defines properties for SLO settings.
	Settings *Settings `json:"settings,omitempty"`

	// Tags List of tags
	Tags []string `json:"tags,omitempty"`

	// TimeWindow Defines properties for the SLO time window
	TimeWindow TimeWindow `json:"timeWindow"`
}

// CreateSloRequest_Indicator defines model for CreateSloRequest.Indicator.
type CreateSloRequest_Indicator struct {
	union json.RawMessage
}

// CreateSloResponse defines model for create_slo_response.
type CreateSloResponse struct {
	Id string `json:"id"`
}

// CreateSyntheticsMonitorStatusRuleRequest A rule that detects when a monitor is down or an availability threshold is breached.
type CreateSyntheticsMonitorStatusRuleRequest struct {
	Actions Actions `json:"actions"`

	// AlertDelay Indicates that an alert occurs only when the specified number of consecutive runs met the rule conditions.
	AlertDelay *AlertDelay `json:"alert_delay,omitempty"`

	// Consumer The name of the application or feature that owns the rule. For example: `alerts`, `apm`, `discover`, `infrastructure`, `logs`, `metrics`, `ml`, `monitoring`, `securitySolution`, `siem`, `stackAlerts`, or `uptime`.
	Consumer Consumer `json:"consumer"`

	// Enabled Indicates whether you want to run the rule on an interval basis after it is created.
	Enabled *EnabledRule `json:"enabled,omitempty"`

	// Name The name of the rule. While this name does not have to be unique, a distinctive name can help you identify a rule.
	Name NameRule `json:"name"`

	// NotifyWhen Deprecated in 8.13.0. Use the `notify_when` property in the action `frequency` object instead. Indicates how often alerts generate actions. NOTE: You cannot specify `notify_when` at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	NotifyWhen *NotifyWhen `json:"notify_when,omitempty"`

	// Params The parameters for the synthetics monitor status rule.
	Params map[string]interface{} `json:"params"`

	// RuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
	RuleTypeId CreateSyntheticsMonitorStatusRuleRequestRuleTypeId `json:"rule_type_id"`

	// Schedule The check interval, which specifies how frequently the rule conditions are checked. The interval is specified in seconds, minutes, hours, or days.
	Schedule Schedule `json:"schedule"`

	// Tags The tags for the rule.
	Tags Tags `json:"tags,omitempty"`

	// Throttle Deprecated in 8.13.0. Use the `throttle` property in the action `frequency` object instead. The throttle interval, which defines how often an alert generates repeated actions. NOTE: You cannot specify the throttle interval at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	Throttle *Throttle `json:"throttle"`
}

// CreateSyntheticsMonitorStatusRuleRequestRuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
type CreateSyntheticsMonitorStatusRuleRequestRuleTypeId string

// CreateSyntheticsUptimeDurationAnomalyRuleRequest A rule that detects response durations for all of the geographic locations of each monitor. When a monitor runs for an unusual amount of time, at a particular time, an anomaly is recorded.
type CreateSyntheticsUptimeDurationAnomalyRuleRequest struct {
	Actions Actions `json:"actions"`

	// AlertDelay Indicates that an alert occurs only when the specified number of consecutive runs met the rule conditions.
	AlertDelay *AlertDelay `json:"alert_delay,omitempty"`

	// Consumer The name of the application or feature that owns the rule. For example: `alerts`, `apm`, `discover`, `infrastructure`, `logs`, `metrics`, `ml`, `monitoring`, `securitySolution`, `siem`, `stackAlerts`, or `uptime`.
	Consumer Consumer `json:"consumer"`

	// Enabled Indicates whether you want to run the rule on an interval basis after it is created.
	Enabled *EnabledRule `json:"enabled,omitempty"`

	// Name The name of the rule. While this name does not have to be unique, a distinctive name can help you identify a rule.
	Name NameRule `json:"name"`

	// NotifyWhen Deprecated in 8.13.0. Use the `notify_when` property in the action `frequency` object instead. Indicates how often alerts generate actions. NOTE: You cannot specify `notify_when` at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	NotifyWhen *NotifyWhen `json:"notify_when,omitempty"`

	// Params The parameters for the uptime duration anomaly rule.
	Params map[string]interface{} `json:"params"`

	// RuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
	RuleTypeId CreateSyntheticsUptimeDurationAnomalyRuleRequestRuleTypeId `json:"rule_type_id"`

	// Schedule The check interval, which specifies how frequently the rule conditions are checked. The interval is specified in seconds, minutes, hours, or days.
	Schedule Schedule `json:"schedule"`

	// Tags The tags for the rule.
	Tags Tags `json:"tags,omitempty"`

	// Throttle Deprecated in 8.13.0. Use the `throttle` property in the action `frequency` object instead. The throttle interval, which defines how often an alert generates repeated actions. NOTE: You cannot specify the throttle interval at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	Throttle *Throttle `json:"throttle"`
}

// CreateSyntheticsUptimeDurationAnomalyRuleRequestRuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
type CreateSyntheticsUptimeDurationAnomalyRuleRequestRuleTypeId string

// CreateSyntheticsUptimeTlsCertificateRuleRequest A rule that detects when a monitor has a TLS certificate expiring or when it exceeds an age limit.
type CreateSyntheticsUptimeTlsCertificateRuleRequest struct {
	Actions Actions `json:"actions"`

	// AlertDelay Indicates that an alert occurs only when the specified number of consecutive runs met the rule conditions.
	AlertDelay *AlertDelay `json:"alert_delay,omitempty"`

	// Consumer The name of the application or feature that owns the rule. For example: `alerts`, `apm`, `discover`, `infrastructure`, `logs`, `metrics`, `ml`, `monitoring`, `securitySolution`, `siem`, `stackAlerts`, or `uptime`.
	Consumer Consumer `json:"consumer"`

	// Enabled Indicates whether you want to run the rule on an interval basis after it is created.
	Enabled *EnabledRule `json:"enabled,omitempty"`

	// Name The name of the rule. While this name does not have to be unique, a distinctive name can help you identify a rule.
	Name NameRule `json:"name"`

	// NotifyWhen Deprecated in 8.13.0. Use the `notify_when` property in the action `frequency` object instead. Indicates how often alerts generate actions. NOTE: You cannot specify `notify_when` at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	NotifyWhen *NotifyWhen `json:"notify_when,omitempty"`

	// Params The parameters for a TLS certificate rule.
	Params map[string]interface{} `json:"params"`

	// RuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
	RuleTypeId CreateSyntheticsUptimeTlsCertificateRuleRequestRuleTypeId `json:"rule_type_id"`

	// Schedule The check interval, which specifies how frequently the rule conditions are checked. The interval is specified in seconds, minutes, hours, or days.
	Schedule Schedule `json:"schedule"`

	// Tags The tags for the rule.
	Tags Tags `json:"tags,omitempty"`

	// Throttle Deprecated in 8.13.0. Use the `throttle` property in the action `frequency` object instead. The throttle interval, which defines how often an alert generates repeated actions. NOTE: You cannot specify the throttle interval at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	Throttle *Throttle `json:"throttle"`
}

// CreateSyntheticsUptimeTlsCertificateRuleRequestRuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
type CreateSyntheticsUptimeTlsCertificateRuleRequestRuleTypeId string

// CreateSyntheticsUptimeTlsRuleRequest defines model for create_synthetics_uptime_tls_rule_request.
type CreateSyntheticsUptimeTlsRuleRequest struct {
	Actions Actions `json:"actions"`

	// Consumer The name of the application or feature that owns the rule. For example: `alerts`, `apm`, `discover`, `infrastructure`, `logs`, `metrics`, `ml`, `monitoring`, `securitySolution`, `siem`, `stackAlerts`, or `uptime`.
	Consumer Consumer `json:"consumer"`

	// Enabled Indicates whether you want to run the rule on an interval basis after it is created.
	Enabled *EnabledRule `json:"enabled,omitempty"`

	// Name The name of the rule. While this name does not have to be unique, a distinctive name can help you identify a rule.
	Name NameRule `json:"name"`

	// NotifyWhen Deprecated in 8.13.0. Use the `notify_when` property in the action `frequency` object instead. Indicates how often alerts generate actions. NOTE: You cannot specify `notify_when` at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	NotifyWhen *NotifyWhen                       `json:"notify_when,omitempty"`
	Params     ParamsPropertySyntheticsUptimeTls `json:"params"`

	// RuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
	RuleTypeId CreateSyntheticsUptimeTlsRuleRequestRuleTypeId `json:"rule_type_id"`

	// Schedule The check interval, which specifies how frequently the rule conditions are checked. The interval is specified in seconds, minutes, hours, or days.
	Schedule Schedule `json:"schedule"`

	// Tags The tags for the rule.
	Tags Tags `json:"tags,omitempty"`

	// Throttle Deprecated in 8.13.0. Use the `throttle` property in the action `frequency` object instead. The throttle interval, which defines how often an alert generates repeated actions. NOTE: You cannot specify the throttle interval at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	Throttle *Throttle `json:"throttle"`
}

// CreateSyntheticsUptimeTlsRuleRequestRuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
type CreateSyntheticsUptimeTlsRuleRequestRuleTypeId string

// CreateTransformHealthRuleRequest A rule that monitors transforms health and alerts if an operational issue occurred.
type CreateTransformHealthRuleRequest struct {
	Actions Actions `json:"actions"`

	// AlertDelay Indicates that an alert occurs only when the specified number of consecutive runs met the rule conditions.
	AlertDelay *AlertDelay `json:"alert_delay,omitempty"`

	// Consumer The name of the application or feature that owns the rule. For example: `alerts`, `apm`, `discover`, `infrastructure`, `logs`, `metrics`, `ml`, `monitoring`, `securitySolution`, `siem`, `stackAlerts`, or `uptime`.
	Consumer Consumer `json:"consumer"`

	// Enabled Indicates whether you want to run the rule on an interval basis after it is created.
	Enabled *EnabledRule `json:"enabled,omitempty"`

	// Name The name of the rule. While this name does not have to be unique, a distinctive name can help you identify a rule.
	Name NameRule `json:"name"`

	// NotifyWhen Deprecated in 8.13.0. Use the `notify_when` property in the action `frequency` object instead. Indicates how often alerts generate actions. NOTE: You cannot specify `notify_when` at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	NotifyWhen *NotifyWhen `json:"notify_when,omitempty"`

	// Params The parameters for a transform health rule.
	Params map[string]interface{} `json:"params"`

	// RuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
	RuleTypeId CreateTransformHealthRuleRequestRuleTypeId `json:"rule_type_id"`

	// Schedule The check interval, which specifies how frequently the rule conditions are checked. The interval is specified in seconds, minutes, hours, or days.
	Schedule Schedule `json:"schedule"`

	// Tags The tags for the rule.
	Tags Tags `json:"tags,omitempty"`

	// Throttle Deprecated in 8.13.0. Use the `throttle` property in the action `frequency` object instead. The throttle interval, which defines how often an alert generates repeated actions. NOTE: You cannot specify the throttle interval at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	Throttle *Throttle `json:"throttle"`
}

// CreateTransformHealthRuleRequestRuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
type CreateTransformHealthRuleRequestRuleTypeId string

// CreateUptimeMonitorStatusRuleRequest A rule that detects monitor errors and outages.
type CreateUptimeMonitorStatusRuleRequest struct {
	Actions Actions `json:"actions"`

	// AlertDelay Indicates that an alert occurs only when the specified number of consecutive runs met the rule conditions.
	AlertDelay *AlertDelay `json:"alert_delay,omitempty"`

	// Consumer The name of the application or feature that owns the rule. For example: `alerts`, `apm`, `discover`, `infrastructure`, `logs`, `metrics`, `ml`, `monitoring`, `securitySolution`, `siem`, `stackAlerts`, or `uptime`.
	Consumer Consumer `json:"consumer"`

	// Enabled Indicates whether you want to run the rule on an interval basis after it is created.
	Enabled *EnabledRule `json:"enabled,omitempty"`

	// Name The name of the rule. While this name does not have to be unique, a distinctive name can help you identify a rule.
	Name NameRule `json:"name"`

	// NotifyWhen Deprecated in 8.13.0. Use the `notify_when` property in the action `frequency` object instead. Indicates how often alerts generate actions. NOTE: You cannot specify `notify_when` at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	NotifyWhen *NotifyWhen                           `json:"notify_when,omitempty"`
	Params     ParamsPropertySyntheticsMonitorStatus `json:"params"`

	// RuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
	RuleTypeId CreateUptimeMonitorStatusRuleRequestRuleTypeId `json:"rule_type_id"`

	// Schedule The check interval, which specifies how frequently the rule conditions are checked. The interval is specified in seconds, minutes, hours, or days.
	Schedule Schedule `json:"schedule"`

	// Tags The tags for the rule.
	Tags Tags `json:"tags,omitempty"`

	// Throttle Deprecated in 8.13.0. Use the `throttle` property in the action `frequency` object instead. The throttle interval, which defines how often an alert generates repeated actions. NOTE: You cannot specify the throttle interval at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	Throttle *Throttle `json:"throttle"`
}

// CreateUptimeMonitorStatusRuleRequestRuleTypeId The ID of the rule type that you want to call when the rule is scheduled to run.
type CreateUptimeMonitorStatusRuleRequestRuleTypeId string

// DataViewResponseObject defines model for data_view_response_object.
type DataViewResponseObject struct {
	DataView *struct {
		// AllowNoIndex Allows the data view saved object to exist before the data is available.
		AllowNoIndex *Allownoindex         `json:"allowNoIndex,omitempty"`
		FieldAttrs   map[string]Fieldattrs `json:"fieldAttrs,omitempty"`

		// FieldFormats A map of field formats by field name.
		FieldFormats Fieldformats           `json:"fieldFormats,omitempty"`
		Fields       map[string]interface{} `json:"fields,omitempty"`
		Id           *string                `json:"id,omitempty"`

		// Name The data view name.
		Name *string `json:"name,omitempty"`

		// Namespaces An array of space identifiers for sharing the data view between multiple spaces.
		Namespaces      Namespaces                 `json:"namespaces,omitempty"`
		RuntimeFieldMap map[string]Runtimefieldmap `json:"runtimeFieldMap,omitempty"`

		// SourceFilters The array of field names you want to filter out in Discover.
		SourceFilters Sourcefilters `json:"sourceFilters,omitempty"`

		// TimeFieldName The timestamp field name, which you use for time-based data views.
		TimeFieldName *Timefieldname `json:"timeFieldName,omitempty"`

		// Title Comma-separated list of data streams, indices, and aliases that you want to search. Supports wildcards (`*`).
		Title *Title `json:"title,omitempty"`

		// TypeMeta When you use rollup indices, contains the field list for the rollup data view API endpoints.
		TypeMeta *TypemetaResponse `json:"typeMeta"`
		Version  *string           `json:"version,omitempty"`
	} `json:"data_view,omitempty"`
}

// ElasticsearchAssetType defines model for elasticsearch_asset_type.
type ElasticsearchAssetType string

// EnabledRule Indicates whether you want to run the rule on an interval basis after it is created.
type EnabledRule = bool

// EnrollmentApiKey defines model for enrollment_api_key.
type EnrollmentApiKey struct {
	Active    bool    `json:"active"`
	ApiKey    string  `json:"api_key"`
	ApiKeyId  string  `json:"api_key_id"`
	CreatedAt string  `json:"created_at"`
	Id        string  `json:"id"`
	Name      *string `json:"name,omitempty"`
	PolicyId  *string `json:"policy_id,omitempty"`
}

// ErrorBudget defines model for error_budget.
type ErrorBudget struct {
	// Consumed The error budget consummed, as a percentage of the initial value.
	Consumed float32 `json:"consumed"`

	// Initial The initial error budget, as 1 - objective
	Initial float32 `json:"initial"`

	// IsEstimated Only for SLO defined with occurrences budgeting method and calendar aligned time window.
	IsEstimated bool `json:"isEstimated"`

	// Remaining The error budget remaining, as a percentage of the initial value.
	Remaining float32 `json:"remaining"`
}

// Excludehitsfrompreviousrun Indicates whether to exclude matches from previous runs. If `true`, you can avoid alert duplication by excluding documents that have already been detected by the previous rule run. This option is not available when a grouping field is specified.
type Excludehitsfrompreviousrun = bool

// Fieldattrs A map of field attributes by field name.
type Fieldattrs struct {
	// Count Popularity count for the field.
	Count *int `json:"count,omitempty"`

	// CustomDescription Custom description for the field.
	CustomDescription *string `json:"customDescription,omitempty"`

	// CustomLabel Custom label for the field.
	CustomLabel *string `json:"customLabel,omitempty"`
}

// Fieldformats A map of field formats by field name.
type Fieldformats = map[string]interface{}

// Filter Defines properties for a filter
type Filter struct {
	// Meta Defines properties for a filter
	Meta  *FilterMeta            `json:"meta,omitempty"`
	Query map[string]interface{} `json:"query,omitempty"`
}

// FilterMeta Defines properties for a filter
type FilterMeta struct {
	Alias        *string                `json:"alias"`
	ControlledBy *string                `json:"controlledBy,omitempty"`
	Disabled     *bool                  `json:"disabled,omitempty"`
	Field        *string                `json:"field,omitempty"`
	Group        *string                `json:"group,omitempty"`
	Index        *string                `json:"index,omitempty"`
	IsMultiIndex *bool                  `json:"isMultiIndex,omitempty"`
	Key          *string                `json:"key,omitempty"`
	Negate       *bool                  `json:"negate,omitempty"`
	Params       map[string]interface{} `json:"params,omitempty"`
	Type         *string                `json:"type,omitempty"`
	Value        *string                `json:"value,omitempty"`
}

// FindSloResponse A paginated response of SLOs matching the query.
type FindSloResponse struct {
	Page    *float32                 `json:"page,omitempty"`
	PerPage *float32                 `json:"perPage,omitempty"`
	Results []SloWithSummaryResponse `json:"results,omitempty"`
	Total   *float32                 `json:"total,omitempty"`
}

// FleetServerHost defines model for fleet_server_host.
type FleetServerHost struct {
	HostUrls        []string `json:"host_urls"`
	Id              string   `json:"id"`
	IsDefault       bool     `json:"is_default"`
	IsInternal      *bool    `json:"is_internal,omitempty"`
	IsPreconfigured bool     `json:"is_preconfigured"`
	Name            *string  `json:"name,omitempty"`
	ProxyId         *string  `json:"proxy_id,omitempty"`
}

// GetPackagesResponse defines model for get_packages_response.
type GetPackagesResponse struct {
	Items []SearchResult `json:"items"`
	// Deprecated:
	Response []SearchResult `json:"response,omitempty"`
}

// Groupby Indicates whether the aggregation is applied over all documents (`all`) or split into groups (`top`) using a grouping field (`termField`). If grouping is used, an alert will be created for each group when it exceeds the threshold; only the top groups (up to `termSize` number of groups) are checked.
type Groupby string

// IndicatorPropertiesApmAvailability Defines properties for the APM availability indicator type
type IndicatorPropertiesApmAvailability struct {
	// Params An object containing the indicator parameters.
	Params struct {
		// Environment The APM service environment or "*"
		Environment string `json:"environment"`

		// Filter KQL query used for filtering the data
		Filter *string `json:"filter,omitempty"`

		// Index The index used by APM metrics
		Index string `json:"index"`

		// Service The APM service name
		Service string `json:"service"`

		// TransactionName The APM transaction name or "*"
		TransactionName string `json:"transactionName"`

		// TransactionType The APM transaction type or "*"
		TransactionType string `json:"transactionType"`
	} `json:"params"`

	// Type The type of indicator.
	Type string `json:"type"`
}

// IndicatorPropertiesApmLatency Defines properties for the APM latency indicator type
type IndicatorPropertiesApmLatency struct {
	// Params An object containing the indicator parameters.
	Params struct {
		// Environment The APM service environment or "*"
		Environment string `json:"environment"`

		// Filter KQL query used for filtering the data
		Filter *string `json:"filter,omitempty"`

		// Index The index used by APM metrics
		Index string `json:"index"`

		// Service The APM service name
		Service string `json:"service"`

		// Threshold The latency threshold in milliseconds
		Threshold float32 `json:"threshold"`

		// TransactionName The APM transaction name or "*"
		TransactionName string `json:"transactionName"`

		// TransactionType The APM transaction type or "*"
		TransactionType string `json:"transactionType"`
	} `json:"params"`

	// Type The type of indicator.
	Type string `json:"type"`
}

// IndicatorPropertiesCustomKql Defines properties for a custom query indicator type
type IndicatorPropertiesCustomKql struct {
	// Params An object containing the indicator parameters.
	Params struct {
		// DataViewId The kibana data view id to use, primarily used to include data view runtime mappings. Make sure to save SLO again if you add/update run time fields to the data view and if those fields are being used in slo queries.
		DataViewId *string `json:"dataViewId,omitempty"`

		// Filter Defines properties for a filter
		Filter *KqlWithFilters `json:"filter,omitempty"`

		// Good The KQL query used to define the good events.
		Good KqlWithFiltersGood `json:"good"`

		// Index The index or index pattern to use
		Index string `json:"index"`

		// TimestampField The timestamp field used in the source indice.
		TimestampField string `json:"timestampField"`

		// Total The KQL query used to define all events.
		Total KqlWithFiltersTotal `json:"total"`
	} `json:"params"`

	// Type The type of indicator.
	Type string `json:"type"`
}

// IndicatorPropertiesCustomMetric Defines properties for a custom metric indicator type
type IndicatorPropertiesCustomMetric struct {
	// Params An object containing the indicator parameters.
	Params struct {
		// DataViewId The kibana data view id to use, primarily used to include data view runtime mappings. Make sure to save SLO again if you add/update run time fields to the data view and if those fields are being used in slo queries.
		DataViewId *string `json:"dataViewId,omitempty"`

		// Filter the KQL query to filter the documents with.
		Filter *string `json:"filter,omitempty"`

		// Good An object defining the "good" metrics and equation
		Good struct {
			// Equation The equation to calculate the "good" metric.
			Equation string `json:"equation"`

			// Metrics List of metrics with their name, aggregation type, and field.
			Metrics []struct {
				// Aggregation The aggregation type of the metric. Only valid option is "sum"
				Aggregation IndicatorPropertiesCustomMetricParamsGoodMetricsAggregation `json:"aggregation"`

				// Field The field of the metric.
				Field string `json:"field"`

				// Filter The filter to apply to the metric.
				Filter *string `json:"filter,omitempty"`

				// Name The name of the metric. Only valid options are A-Z
				Name string `json:"name"`
			} `json:"metrics"`
		} `json:"good"`

		// Index The index or index pattern to use
		Index string `json:"index"`

		// TimestampField The timestamp field used in the source indice.
		TimestampField string `json:"timestampField"`

		// Total An object defining the "total" metrics and equation
		Total struct {
			// Equation The equation to calculate the "total" metric.
			Equation string `json:"equation"`

			// Metrics List of metrics with their name, aggregation type, and field.
			Metrics []struct {
				// Aggregation The aggregation type of the metric. Only valid option is "sum"
				Aggregation IndicatorPropertiesCustomMetricParamsTotalMetricsAggregation `json:"aggregation"`

				// Field The field of the metric.
				Field string `json:"field"`

				// Filter The filter to apply to the metric.
				Filter *string `json:"filter,omitempty"`

				// Name The name of the metric. Only valid options are A-Z
				Name string `json:"name"`
			} `json:"metrics"`
		} `json:"total"`
	} `json:"params"`

	// Type The type of indicator.
	Type string `json:"type"`
}

// IndicatorPropertiesCustomMetricParamsGoodMetricsAggregation The aggregation type of the metric. Only valid option is "sum"
type IndicatorPropertiesCustomMetricParamsGoodMetricsAggregation string

// IndicatorPropertiesCustomMetricParamsTotalMetricsAggregation The aggregation type of the metric. Only valid option is "sum"
type IndicatorPropertiesCustomMetricParamsTotalMetricsAggregation string

// IndicatorPropertiesHistogram Defines properties for a histogram indicator type
type IndicatorPropertiesHistogram struct {
	// Params An object containing the indicator parameters.
	Params struct {
		// DataViewId The kibana data view id to use, primarily used to include data view runtime mappings. Make sure to save SLO again if you add/update run time fields to the data view and if those fields are being used in slo queries.
		DataViewId *string `json:"dataViewId,omitempty"`

		// Filter the KQL query to filter the documents with.
		Filter *string `json:"filter,omitempty"`

		// Good An object defining the "good" events
		Good struct {
			// Aggregation The type of aggregation to use.
			Aggregation IndicatorPropertiesHistogramParamsGoodAggregation `json:"aggregation"`

			// Field The field use to aggregate the good events.
			Field string `json:"field"`

			// Filter The filter for good events.
			Filter *string `json:"filter,omitempty"`

			// From The starting value of the range. Only required for "range" aggregations.
			From *float32 `json:"from,omitempty"`

			// To The ending value of the range. Only required for "range" aggregations.
			To *float32 `json:"to,omitempty"`
		} `json:"good"`

		// Index The index or index pattern to use
		Index string `json:"index"`

		// TimestampField The timestamp field used in the source indice.
		TimestampField string `json:"timestampField"`

		// Total An object defining the "total" events
		Total struct {
			// Aggregation The type of aggregation to use.
			Aggregation IndicatorPropertiesHistogramParamsTotalAggregation `json:"aggregation"`

			// Field The field use to aggregate the good events.
			Field string `json:"field"`

			// Filter The filter for total events.
			Filter *string `json:"filter,omitempty"`

			// From The starting value of the range. Only required for "range" aggregations.
			From *float32 `json:"from,omitempty"`

			// To The ending value of the range. Only required for "range" aggregations.
			To *float32 `json:"to,omitempty"`
		} `json:"total"`
	} `json:"params"`

	// Type The type of indicator.
	Type string `json:"type"`
}

// IndicatorPropertiesHistogramParamsGoodAggregation The type of aggregation to use.
type IndicatorPropertiesHistogramParamsGoodAggregation string

// IndicatorPropertiesHistogramParamsTotalAggregation The type of aggregation to use.
type IndicatorPropertiesHistogramParamsTotalAggregation string

// IndicatorPropertiesTimesliceMetric Defines properties for a timeslice metric indicator type
type IndicatorPropertiesTimesliceMetric struct {
	// Params An object containing the indicator parameters.
	Params struct {
		// DataViewId The kibana data view id to use, primarily used to include data view runtime mappings. Make sure to save SLO again if you add/update run time fields to the data view and if those fields are being used in slo queries.
		DataViewId *string `json:"dataViewId,omitempty"`

		// Filter the KQL query to filter the documents with.
		Filter *string `json:"filter,omitempty"`

		// Index The index or index pattern to use
		Index string `json:"index"`

		// Metric An object defining the metrics, equation, and threshold to determine if it's a good slice or not
		Metric struct {
			// Comparator The comparator to use to compare the equation to the threshold.
			Comparator IndicatorPropertiesTimesliceMetricParamsMetricComparator `json:"comparator"`

			// Equation The equation to calculate the metric.
			Equation string `json:"equation"`

			// Metrics List of metrics with their name, aggregation type, and field.
			Metrics []IndicatorPropertiesTimesliceMetric_Params_Metric_Metrics_Item `json:"metrics"`

			// Threshold The threshold used to determine if the metric is a good slice or not.
			Threshold float32 `json:"threshold"`
		} `json:"metric"`

		// TimestampField The timestamp field used in the source indice.
		TimestampField string `json:"timestampField"`
	} `json:"params"`

	// Type The type of indicator.
	Type string `json:"type"`
}

// IndicatorPropertiesTimesliceMetricParamsMetricComparator The comparator to use to compare the equation to the threshold.
type IndicatorPropertiesTimesliceMetricParamsMetricComparator string

// IndicatorPropertiesTimesliceMetric_Params_Metric_Metrics_Item defines model for IndicatorPropertiesTimesliceMetric.Params.Metric.metrics.Item.
type IndicatorPropertiesTimesliceMetric_Params_Metric_Metrics_Item struct {
	union json.RawMessage
}

// InstallationInfo defines model for installation_info.
type InstallationInfo struct {
	CreatedAt                      *string                       `json:"created_at,omitempty"`
	ExperimentalDataStreamFeatures []interface{}                 `json:"experimental_data_stream_features,omitempty"`
	InstallFormatSchemaVersion     *string                       `json:"install_format_schema_version,omitempty"`
	InstallKibanaSpaceId           *string                       `json:"install_kibana_space_id,omitempty"`
	InstallSource                  InstallationInfoInstallSource `json:"install_source"`
	InstallStatus                  InstallationInfoInstallStatus `json:"install_status"`
	InstalledEs                    struct {
		Deferred *bool                   `json:"deferred,omitempty"`
		Id       *string                 `json:"id,omitempty"`
		Type     *ElasticsearchAssetType `json:"type,omitempty"`
	} `json:"installed_es"`
	InstalledKibana struct {
		Id   *string                `json:"id,omitempty"`
		Type *KibanaSavedObjectType `json:"type,omitempty"`
	} `json:"installed_kibana"`

	// LatestExecutedState Latest successfully executed state in package install state machine
	LatestExecutedState *struct {
		Error     *string                                  `json:"error,omitempty"`
		Name      *InstallationInfoLatestExecutedStateName `json:"name,omitempty"`
		StartedAt *string                                  `json:"started_at,omitempty"`
	} `json:"latest_executed_state,omitempty"`

	// LatestInstallFailedAttempts Latest failed install errors
	LatestInstallFailedAttempts []struct {
		CreatedAt *string `json:"created_at,omitempty"`
		Error     *struct {
			Message *string `json:"message,omitempty"`
			Name    *string `json:"name,omitempty"`
			Stack   *string `json:"stack,omitempty"`
		} `json:"error,omitempty"`
		TargetVersion *string `json:"target_version,omitempty"`
	} `json:"latest_install_failed_attempts"`
	Name               string                             `json:"name"`
	Namespaces         []string                           `json:"namespaces,omitempty"`
	Type               *string                            `json:"type,omitempty"`
	UpdatedAt          *string                            `json:"updated_at,omitempty"`
	VerificationKeyId  *string                            `json:"verification_key_id"`
	VerificationStatus InstallationInfoVerificationStatus `json:"verification_status"`
	Version            string                             `json:"version"`
}

// InstallationInfoInstallSource defines model for InstallationInfo.InstallSource.
type InstallationInfoInstallSource string

// InstallationInfoInstallStatus defines model for InstallationInfo.InstallStatus.
type InstallationInfoInstallStatus string

// InstallationInfoLatestExecutedStateName defines model for InstallationInfo.LatestExecutedState.Name.
type InstallationInfoLatestExecutedStateName string

// InstallationInfoVerificationStatus defines model for InstallationInfo.VerificationStatus.
type InstallationInfoVerificationStatus string

// KibanaSavedObjectType defines model for kibana_saved_object_type.
type KibanaSavedObjectType string

// KqlWithFilters Defines properties for a filter
type KqlWithFilters struct {
	union json.RawMessage
}

// KqlWithFilters0 the KQL query to filter the documents with.
type KqlWithFilters0 = string

// KqlWithFilters1 defines model for .
type KqlWithFilters1 struct {
	Filters  []Filter `json:"filters,omitempty"`
	KqlQuery *string  `json:"kqlQuery,omitempty"`
}

// KqlWithFiltersGood The KQL query used to define the good events.
type KqlWithFiltersGood struct {
	union json.RawMessage
}

// KqlWithFiltersGood0 the KQL query to filter the documents with.
type KqlWithFiltersGood0 = string

// KqlWithFiltersGood1 defines model for .
type KqlWithFiltersGood1 struct {
	Filters  []Filter `json:"filters,omitempty"`
	KqlQuery *string  `json:"kqlQuery,omitempty"`
}

// KqlWithFiltersTotal The KQL query used to define all events.
type KqlWithFiltersTotal struct {
	union json.RawMessage
}

// KqlWithFiltersTotal0 the KQL query to filter the documents with.
type KqlWithFiltersTotal0 = string

// KqlWithFiltersTotal1 defines model for .
type KqlWithFiltersTotal1 struct {
	Filters  []Filter `json:"filters,omitempty"`
	KqlQuery *string  `json:"kqlQuery,omitempty"`
}

// NameRule The name of the rule. While this name does not have to be unique, a distinctive name can help you identify a rule.
type NameRule = string

// Namespaces An array of space identifiers for sharing the data view between multiple spaces.
type Namespaces = []string

// NewPackagePolicy defines model for new_package_policy.
type NewPackagePolicy struct {
	Description *string                          `json:"description,omitempty"`
	Enabled     *bool                            `json:"enabled,omitempty"`
	Inputs      map[string]NewPackagePolicyInput `json:"inputs"`
	Name        string                           `json:"name"`
	Namespace   *string                          `json:"namespace,omitempty"`
	// Deprecated:
	OutputId  *string                   `json:"output_id,omitempty"`
	Overrides map[string]interface{}    `json:"overrides,omitempty"`
	Package   *PackagePolicyPackageInfo `json:"package,omitempty"`
	// Deprecated:
	PolicyId         *string  `json:"policy_id,omitempty"`
	PolicyIds        []string `json:"policy_ids,omitempty"`
	SecretReferences []struct {
		Id *string `json:"id,omitempty"`
	} `json:"secret_references,omitempty"`
	Vars map[string]interface{} `json:"vars,omitempty"`
}

// NewPackagePolicyInput defines model for new_package_policy_input.
type NewPackagePolicyInput struct {
	Config     map[string]interface{}                 `json:"config,omitempty"`
	Enabled    bool                                   `json:"enabled"`
	Processors []string                               `json:"processors,omitempty"`
	Streams    map[string]NewPackagePolicyInputStream `json:"streams,omitempty"`
	Type       string                                 `json:"type"`
	Vars       map[string]interface{}                 `json:"vars,omitempty"`
}

// NewPackagePolicyInputStream defines model for new_package_policy_input_stream.
type NewPackagePolicyInputStream struct {
	Enabled *bool                  `json:"enabled,omitempty"`
	Vars    map[string]interface{} `json:"vars,omitempty"`
}

// NotifyWhen Deprecated in 8.13.0. Use the `notify_when` property in the action `frequency` object instead. Indicates how often alerts generate actions. NOTE: You cannot specify `notify_when` at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
type NotifyWhen string

// NotifyWhenAction Indicates how often alerts generate actions. Valid values include: `onActionGroupChange`: Actions run when the alert status changes; `onActiveAlert`: Actions run when the alert becomes active and at each check interval while the rule conditions are met; `onThrottleInterval`: Actions run when the alert becomes active and at the interval specified in the throttle property while the rule conditions are met. NOTE: You cannot specify `notify_when` at both the rule and action level. The recommended method is to set it for each action. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
type NotifyWhenAction string

// Objective Defines properties for the SLO objective
type Objective struct {
	// Target the target objective between 0 and 1 excluded
	Target float32 `json:"target"`

	// TimesliceTarget the target objective for each slice when using a timeslices budgeting method
	TimesliceTarget *float32 `json:"timesliceTarget,omitempty"`

	// TimesliceWindow the duration of each slice when using a timeslices budgeting method, as {duraton}{unit}
	TimesliceWindow *string `json:"timesliceWindow,omitempty"`
}

// OutputCreateRequest defines model for output_create_request.
type OutputCreateRequest struct {
	union json.RawMessage
}

// OutputCreateRequestElasticsearch defines model for output_create_request_elasticsearch.
type OutputCreateRequestElasticsearch struct {
	CaSha256             *string                                 `json:"ca_sha256,omitempty"`
	CaTrustedFingerprint *string                                 `json:"ca_trusted_fingerprint,omitempty"`
	Config               map[string]interface{}                  `json:"config,omitempty"`
	ConfigYaml           *string                                 `json:"config_yaml,omitempty"`
	Hosts                []string                                `json:"hosts,omitempty"`
	Id                   *string                                 `json:"id,omitempty"`
	IsDefault            *bool                                   `json:"is_default,omitempty"`
	IsDefaultMonitoring  *bool                                   `json:"is_default_monitoring,omitempty"`
	IsInternal           *bool                                   `json:"is_internal,omitempty"`
	Name                 string                                  `json:"name"`
	Preset               *OutputCreateRequestElasticsearchPreset `json:"preset,omitempty"`
	ProxyId              *string                                 `json:"proxy_id,omitempty"`
	Shipper              *struct {
		CompressionLevel            *float32 `json:"compression_level,omitempty"`
		DiskQueueCompressionEnabled *bool    `json:"disk_queue_compression_enabled,omitempty"`
		DiskQueueEnabled            *bool    `json:"disk_queue_enabled,omitempty"`
		DiskQueueEncryptionEnabled  *bool    `json:"disk_queue_encryption_enabled,omitempty"`
		DiskQueueMaxSize            *float32 `json:"disk_queue_max_size,omitempty"`
		DiskQueuePath               *string  `json:"disk_queue_path,omitempty"`
		Loadbalance                 *bool    `json:"loadbalance,omitempty"`
	} `json:"shipper,omitempty"`
	Ssl *struct {
		Certificate            *string  `json:"certificate,omitempty"`
		CertificateAuthorities []string `json:"certificate_authorities,omitempty"`
		Key                    *string  `json:"key,omitempty"`
	} `json:"ssl,omitempty"`
	Type OutputCreateRequestElasticsearchType `json:"type"`
}

// OutputCreateRequestElasticsearchPreset defines model for OutputCreateRequestElasticsearch.Preset.
type OutputCreateRequestElasticsearchPreset string

// OutputCreateRequestElasticsearchType defines model for OutputCreateRequestElasticsearch.Type.
type OutputCreateRequestElasticsearchType string

// OutputCreateRequestKafka defines model for output_create_request_kafka.
type OutputCreateRequestKafka struct {
	AuthType             string                                  `json:"auth_type"`
	BrokerTimeout        *float32                                `json:"broker_timeout,omitempty"`
	CaSha256             *string                                 `json:"ca_sha256,omitempty"`
	CaTrustedFingerprint *string                                 `json:"ca_trusted_fingerprint,omitempty"`
	ClientId             *string                                 `json:"client_id,omitempty"`
	Compression          *string                                 `json:"compression,omitempty"`
	CompressionLevel     *float32                                `json:"compression_level,omitempty"`
	Config               map[string]interface{}                  `json:"config,omitempty"`
	ConfigYaml           *string                                 `json:"config_yaml,omitempty"`
	ConnectionType       *OutputCreateRequestKafkaConnectionType `json:"connection_type,omitempty"`
	Headers              []struct {
		Key   *string `json:"key,omitempty"`
		Value *string `json:"value,omitempty"`
	} `json:"headers,omitempty"`
	Hosts               []string `json:"hosts"`
	Id                  *string  `json:"id,omitempty"`
	IsDefault           *bool    `json:"is_default,omitempty"`
	IsDefaultMonitoring *bool    `json:"is_default_monitoring,omitempty"`
	IsInternal          *bool    `json:"is_internal,omitempty"`
	Key                 *string  `json:"key,omitempty"`
	Name                string   `json:"name"`
	Partition           *string  `json:"partition,omitempty"`
	Password            *string  `json:"password,omitempty"`
	ProxyId             *string  `json:"proxy_id,omitempty"`
	Random              *struct {
		GroupEvents *float32 `json:"group_events,omitempty"`
	} `json:"random,omitempty"`
	RequiredAcks *float32 `json:"required_acks,omitempty"`
	RoundRobin   *struct {
		GroupEvents *float32 `json:"group_events,omitempty"`
	} `json:"round_robin,omitempty"`
	Sasl *struct {
		Mechanism *string `json:"mechanism,omitempty"`
	} `json:"sasl,omitempty"`
	Secrets *struct {
		Password *string `json:"password,omitempty"`
		Ssl      *struct {
			Key *string `json:"key,omitempty"`
		} `json:"ssl,omitempty"`
	} `json:"secrets,omitempty"`
	Shipper *struct {
		CompressionLevel            *float32 `json:"compression_level,omitempty"`
		DiskQueueCompressionEnabled *bool    `json:"disk_queue_compression_enabled,omitempty"`
		DiskQueueEnabled            *bool    `json:"disk_queue_enabled,omitempty"`
		DiskQueueEncryptionEnabled  *bool    `json:"disk_queue_encryption_enabled,omitempty"`
		DiskQueueMaxSize            *float32 `json:"disk_queue_max_size,omitempty"`
		DiskQueuePath               *string  `json:"disk_queue_path,omitempty"`
		Loadbalance                 *bool    `json:"loadbalance,omitempty"`
	} `json:"shipper,omitempty"`
	Ssl *struct {
		Certificate            *string                                      `json:"certificate,omitempty"`
		CertificateAuthorities []string                                     `json:"certificate_authorities,omitempty"`
		Key                    *string                                      `json:"key,omitempty"`
		VerificationMode       *OutputCreateRequestKafkaSslVerificationMode `json:"verification_mode,omitempty"`
	} `json:"ssl,omitempty"`
	Timeout *float32 `json:"timeout,omitempty"`
	Topic   *string  `json:"topic,omitempty"`

	// Topics Use topic instead.
	// Deprecated:
	Topics []struct {
		Topic *string `json:"topic,omitempty"`

		// When Deprecated, kafka output do not support conditionnal topics anymore.
		// Deprecated:
		When *struct {
			Condition *string `json:"condition,omitempty"`
			Type      *string `json:"type,omitempty"`
		} `json:"when,omitempty"`
	} `json:"topics"`
	Type     OutputCreateRequestKafkaType `json:"type"`
	Username *string                      `json:"username,omitempty"`
	Version  *string                      `json:"version,omitempty"`
}

// OutputCreateRequestKafkaConnectionType defines model for OutputCreateRequestKafka.ConnectionType.
type OutputCreateRequestKafkaConnectionType string

// OutputCreateRequestKafkaSslVerificationMode defines model for OutputCreateRequestKafka.Ssl.VerificationMode.
type OutputCreateRequestKafkaSslVerificationMode string

// OutputCreateRequestKafkaType defines model for OutputCreateRequestKafka.Type.
type OutputCreateRequestKafkaType string

// OutputCreateRequestLogstash defines model for output_create_request_logstash.
type OutputCreateRequestLogstash struct {
	CaSha256             *string                `json:"ca_sha256,omitempty"`
	CaTrustedFingerprint *string                `json:"ca_trusted_fingerprint,omitempty"`
	Config               map[string]interface{} `json:"config,omitempty"`
	ConfigYaml           *string                `json:"config_yaml,omitempty"`
	Hosts                []string               `json:"hosts"`
	Id                   *string                `json:"id,omitempty"`
	IsDefault            *bool                  `json:"is_default,omitempty"`
	IsDefaultMonitoring  *bool                  `json:"is_default_monitoring,omitempty"`
	IsInternal           *bool                  `json:"is_internal,omitempty"`
	Name                 string                 `json:"name"`
	ProxyId              *string                `json:"proxy_id,omitempty"`
	Secrets              *struct {
		Ssl *struct {
			Key *string `json:"key,omitempty"`
		} `json:"ssl,omitempty"`
	} `json:"secrets,omitempty"`
	Shipper *struct {
		CompressionLevel            *float32 `json:"compression_level,omitempty"`
		DiskQueueCompressionEnabled *bool    `json:"disk_queue_compression_enabled,omitempty"`
		DiskQueueEnabled            *bool    `json:"disk_queue_enabled,omitempty"`
		DiskQueueEncryptionEnabled  *bool    `json:"disk_queue_encryption_enabled,omitempty"`
		DiskQueueMaxSize            *float32 `json:"disk_queue_max_size,omitempty"`
		DiskQueuePath               *string  `json:"disk_queue_path,omitempty"`
		Loadbalance                 *bool    `json:"loadbalance,omitempty"`
	} `json:"shipper,omitempty"`
	Ssl *struct {
		Certificate            *string  `json:"certificate,omitempty"`
		CertificateAuthorities []string `json:"certificate_authorities,omitempty"`
		Key                    *string  `json:"key,omitempty"`
	} `json:"ssl,omitempty"`
	Type OutputCreateRequestLogstashType `json:"type"`
}

// OutputCreateRequestLogstashType defines model for OutputCreateRequestLogstash.Type.
type OutputCreateRequestLogstashType string

// OutputCreateRequestRemoteElasticsearch defines model for output_create_request_remote_elasticsearch.
type OutputCreateRequestRemoteElasticsearch struct {
	Hosts               []string `json:"hosts,omitempty"`
	Id                  *string  `json:"id,omitempty"`
	IsDefault           *bool    `json:"is_default,omitempty"`
	IsDefaultMonitoring *bool    `json:"is_default_monitoring,omitempty"`
	IsInternal          *bool    `json:"is_internal,omitempty"`
	Name                string   `json:"name"`
	Secrets             *struct {
		ServiceToken *string `json:"service_token,omitempty"`
	} `json:"secrets,omitempty"`
	ServiceToken *string                                    `json:"service_token,omitempty"`
	Type         OutputCreateRequestRemoteElasticsearchType `json:"type"`
}

// OutputCreateRequestRemoteElasticsearchType defines model for OutputCreateRequestRemoteElasticsearch.Type.
type OutputCreateRequestRemoteElasticsearchType string

// OutputUpdateRequest defines model for output_update_request.
type OutputUpdateRequest struct {
	union json.RawMessage
}

// OutputUpdateRequestElasticsearch defines model for output_update_request_elasticsearch.
type OutputUpdateRequestElasticsearch struct {
	CaSha256             *string                                 `json:"ca_sha256,omitempty"`
	CaTrustedFingerprint *string                                 `json:"ca_trusted_fingerprint,omitempty"`
	Config               map[string]interface{}                  `json:"config,omitempty"`
	ConfigYaml           *string                                 `json:"config_yaml,omitempty"`
	Hosts                []string                                `json:"hosts"`
	Id                   *string                                 `json:"id,omitempty"`
	IsDefault            *bool                                   `json:"is_default,omitempty"`
	IsDefaultMonitoring  *bool                                   `json:"is_default_monitoring,omitempty"`
	IsInternal           *bool                                   `json:"is_internal,omitempty"`
	Name                 string                                  `json:"name"`
	Preset               *OutputUpdateRequestElasticsearchPreset `json:"preset,omitempty"`
	ProxyId              *string                                 `json:"proxy_id,omitempty"`
	Shipper              *struct {
		CompressionLevel            *float32 `json:"compression_level,omitempty"`
		DiskQueueCompressionEnabled *bool    `json:"disk_queue_compression_enabled,omitempty"`
		DiskQueueEnabled            *bool    `json:"disk_queue_enabled,omitempty"`
		DiskQueueEncryptionEnabled  *bool    `json:"disk_queue_encryption_enabled,omitempty"`
		DiskQueueMaxSize            *float32 `json:"disk_queue_max_size,omitempty"`
		DiskQueuePath               *string  `json:"disk_queue_path,omitempty"`
		Loadbalance                 *bool    `json:"loadbalance,omitempty"`
	} `json:"shipper,omitempty"`
	Ssl *struct {
		Certificate            *string  `json:"certificate,omitempty"`
		CertificateAuthorities []string `json:"certificate_authorities,omitempty"`
		Key                    *string  `json:"key,omitempty"`
	} `json:"ssl,omitempty"`
	Type OutputUpdateRequestElasticsearchType `json:"type"`
}

// OutputUpdateRequestElasticsearchPreset defines model for OutputUpdateRequestElasticsearch.Preset.
type OutputUpdateRequestElasticsearchPreset string

// OutputUpdateRequestElasticsearchType defines model for OutputUpdateRequestElasticsearch.Type.
type OutputUpdateRequestElasticsearchType string

// OutputUpdateRequestKafka defines model for output_update_request_kafka.
type OutputUpdateRequestKafka struct {
	AuthType             *string                                 `json:"auth_type,omitempty"`
	BrokerTimeout        *float32                                `json:"broker_timeout,omitempty"`
	CaSha256             *string                                 `json:"ca_sha256,omitempty"`
	CaTrustedFingerprint *string                                 `json:"ca_trusted_fingerprint,omitempty"`
	ClientId             *string                                 `json:"client_id,omitempty"`
	Compression          *string                                 `json:"compression,omitempty"`
	CompressionLevel     *float32                                `json:"compression_level,omitempty"`
	Config               map[string]interface{}                  `json:"config,omitempty"`
	ConfigYaml           *string                                 `json:"config_yaml,omitempty"`
	ConnectionType       *OutputUpdateRequestKafkaConnectionType `json:"connection_type,omitempty"`
	Headers              []struct {
		Key   *string `json:"key,omitempty"`
		Value *string `json:"value,omitempty"`
	} `json:"headers,omitempty"`
	Hosts               []string `json:"hosts,omitempty"`
	Id                  *string  `json:"id,omitempty"`
	IsDefault           *bool    `json:"is_default,omitempty"`
	IsDefaultMonitoring *bool    `json:"is_default_monitoring,omitempty"`
	IsInternal          *bool    `json:"is_internal,omitempty"`
	Key                 *string  `json:"key,omitempty"`
	Name                string   `json:"name"`
	Partition           *string  `json:"partition,omitempty"`
	Password            *string  `json:"password,omitempty"`
	ProxyId             *string  `json:"proxy_id,omitempty"`
	Random              *struct {
		GroupEvents *float32 `json:"group_events,omitempty"`
	} `json:"random,omitempty"`
	RequiredAcks *float32 `json:"required_acks,omitempty"`
	RoundRobin   *struct {
		GroupEvents *float32 `json:"group_events,omitempty"`
	} `json:"round_robin,omitempty"`
	Sasl *struct {
		Mechanism *string `json:"mechanism,omitempty"`
	} `json:"sasl,omitempty"`
	Shipper *struct {
		CompressionLevel            *float32 `json:"compression_level,omitempty"`
		DiskQueueCompressionEnabled *bool    `json:"disk_queue_compression_enabled,omitempty"`
		DiskQueueEnabled            *bool    `json:"disk_queue_enabled,omitempty"`
		DiskQueueEncryptionEnabled  *bool    `json:"disk_queue_encryption_enabled,omitempty"`
		DiskQueueMaxSize            *float32 `json:"disk_queue_max_size,omitempty"`
		DiskQueuePath               *string  `json:"disk_queue_path,omitempty"`
		Loadbalance                 *bool    `json:"loadbalance,omitempty"`
	} `json:"shipper,omitempty"`
	Ssl *struct {
		Certificate            *string                                      `json:"certificate,omitempty"`
		CertificateAuthorities []string                                     `json:"certificate_authorities,omitempty"`
		Key                    *string                                      `json:"key,omitempty"`
		VerificationMode       *OutputUpdateRequestKafkaSslVerificationMode `json:"verification_mode,omitempty"`
	} `json:"ssl,omitempty"`
	Timeout *float32 `json:"timeout,omitempty"`
	Topic   *string  `json:"topic,omitempty"`

	// Topics Use topic instead.
	// Deprecated:
	Topics []struct {
		Topic *string `json:"topic,omitempty"`

		// When Deprecated, kafka output do not support conditionnal topics anymore.
		// Deprecated:
		When *struct {
			Condition *string `json:"condition,omitempty"`
			Type      *string `json:"type,omitempty"`
		} `json:"when,omitempty"`
	} `json:"topics,omitempty"`
	Type     OutputUpdateRequestKafkaType `json:"type"`
	Username *string                      `json:"username,omitempty"`
	Version  *string                      `json:"version,omitempty"`
}

// OutputUpdateRequestKafkaConnectionType defines model for OutputUpdateRequestKafka.ConnectionType.
type OutputUpdateRequestKafkaConnectionType string

// OutputUpdateRequestKafkaSslVerificationMode defines model for OutputUpdateRequestKafka.Ssl.VerificationMode.
type OutputUpdateRequestKafkaSslVerificationMode string

// OutputUpdateRequestKafkaType defines model for OutputUpdateRequestKafka.Type.
type OutputUpdateRequestKafkaType string

// OutputUpdateRequestLogstash defines model for output_update_request_logstash.
type OutputUpdateRequestLogstash struct {
	CaSha256             *string                `json:"ca_sha256,omitempty"`
	CaTrustedFingerprint *string                `json:"ca_trusted_fingerprint,omitempty"`
	Config               map[string]interface{} `json:"config,omitempty"`
	ConfigYaml           *string                `json:"config_yaml,omitempty"`
	Hosts                []string               `json:"hosts,omitempty"`
	Id                   *string                `json:"id,omitempty"`
	IsDefault            *bool                  `json:"is_default,omitempty"`
	IsDefaultMonitoring  *bool                  `json:"is_default_monitoring,omitempty"`
	IsInternal           *bool                  `json:"is_internal,omitempty"`
	Name                 string                 `json:"name"`
	ProxyId              *string                `json:"proxy_id,omitempty"`
	Shipper              *struct {
		CompressionLevel            *float32 `json:"compression_level,omitempty"`
		DiskQueueCompressionEnabled *bool    `json:"disk_queue_compression_enabled,omitempty"`
		DiskQueueEnabled            *bool    `json:"disk_queue_enabled,omitempty"`
		DiskQueueEncryptionEnabled  *bool    `json:"disk_queue_encryption_enabled,omitempty"`
		DiskQueueMaxSize            *float32 `json:"disk_queue_max_size,omitempty"`
		DiskQueuePath               *string  `json:"disk_queue_path,omitempty"`
		Loadbalance                 *bool    `json:"loadbalance,omitempty"`
	} `json:"shipper,omitempty"`
	Ssl *struct {
		Certificate            *string  `json:"certificate,omitempty"`
		CertificateAuthorities []string `json:"certificate_authorities,omitempty"`
		Key                    *string  `json:"key,omitempty"`
	} `json:"ssl,omitempty"`
	Type OutputUpdateRequestLogstashType `json:"type"`
}

// OutputUpdateRequestLogstashType defines model for OutputUpdateRequestLogstash.Type.
type OutputUpdateRequestLogstashType string

// PackageInfo defines model for package_info.
type PackageInfo struct {
	Assets     []string `json:"assets"`
	Categories []string `json:"categories"`
	Conditions struct {
		Elasticsearch *struct {
			Subscription *PackageInfoConditionsElasticsearchSubscription `json:"subscription,omitempty"`
		} `json:"elasticsearch,omitempty"`
		Kibana *struct {
			Versions *string `json:"versions,omitempty"`
		} `json:"kibana,omitempty"`
	} `json:"conditions"`
	DataStreams []struct {
		IngesetPipeline string `json:"ingeset_pipeline"`
		Name            string `json:"name"`
		Package         string `json:"package"`
		Release         string `json:"release"`
		Title           string `json:"title"`
		Type            string `json:"type"`
		Vars            []struct {
			Default string `json:"default"`
			Name    string `json:"name"`
		} `json:"vars,omitempty"`
	} `json:"data_streams,omitempty"`
	Description   string `json:"description"`
	Download      string `json:"download"`
	Elasticsearch *struct {
		Privileges *struct {
			Cluster []string `json:"cluster,omitempty"`
		} `json:"privileges,omitempty"`
	} `json:"elasticsearch,omitempty"`
	FormatVersion string   `json:"format_version"`
	Icons         []string `json:"icons,omitempty"`
	Internal      *bool    `json:"internal,omitempty"`
	Name          string   `json:"name"`
	Path          string   `json:"path"`
	Readme        *string  `json:"readme,omitempty"`

	// Release release label is deprecated, derive from the version instead (packages follow semver)
	// Deprecated:
	Release     *PackageInfoRelease `json:"release,omitempty"`
	Screenshots []struct {
		Path  string  `json:"path"`
		Size  *string `json:"size,omitempty"`
		Src   string  `json:"src"`
		Title *string `json:"title,omitempty"`
		Type  *string `json:"type,omitempty"`
	} `json:"screenshots,omitempty"`
	Source *struct {
		License *PackageInfoSourceLicense `json:"license,omitempty"`
	} `json:"source,omitempty"`
	Title   string `json:"title"`
	Type    string `json:"type"`
	Version string `json:"version"`
}

// PackageInfoConditionsElasticsearchSubscription defines model for PackageInfo.Conditions.Elasticsearch.Subscription.
type PackageInfoConditionsElasticsearchSubscription string

// PackageInfoRelease release label is deprecated, derive from the version instead (packages follow semver)
type PackageInfoRelease string

// PackageInfoSourceLicense defines model for PackageInfo.Source.License.
type PackageInfoSourceLicense string

// PackageInstallSource defines model for package_install_source.
type PackageInstallSource string

// PackageItem defines model for package_item.
type PackageItem = []struct {
	Id   string          `json:"id"`
	Type PackageItemType `json:"type"`
}

// PackageItemType defines model for package_item_type.
type PackageItemType struct {
	union json.RawMessage
}

// PackagePolicy defines model for package_policy.
type PackagePolicy struct {
	Description *string                          `json:"description,omitempty"`
	Enabled     *bool                            `json:"enabled,omitempty"`
	Id          string                           `json:"id"`
	Inputs      map[string]NewPackagePolicyInput `json:"inputs"`
	Name        string                           `json:"name"`
	Namespace   *string                          `json:"namespace,omitempty"`
	// Deprecated:
	OutputId  *string                   `json:"output_id,omitempty"`
	Overrides map[string]interface{}    `json:"overrides,omitempty"`
	Package   *PackagePolicyPackageInfo `json:"package,omitempty"`
	// Deprecated:
	PolicyId         *string  `json:"policy_id,omitempty"`
	PolicyIds        []string `json:"policy_ids,omitempty"`
	Revision         float32  `json:"revision"`
	SecretReferences []struct {
		Id *string `json:"id,omitempty"`
	} `json:"secret_references,omitempty"`
	Vars map[string]interface{} `json:"vars,omitempty"`
}

// PackagePolicyPackageInfo defines model for package_policy_package_info.
type PackagePolicyPackageInfo struct {
	Name         string  `json:"name"`
	RequiresRoot *bool   `json:"requires_root,omitempty"`
	Title        *string `json:"title,omitempty"`
	Version      string  `json:"version"`
}

// PackagePolicyRequest defines model for package_policy_request.
type PackagePolicyRequest struct {
	// Description Package policy description
	Description *string `json:"description,omitempty"`

	// Force Force package policy creation even if package is not verified, or if the agent policy is managed.
	Force *bool `json:"force,omitempty"`

	// Id Package policy unique identifier
	Id *string `json:"id,omitempty"`

	// Inputs Package policy inputs (see integration documentation to know what inputs are available)
	Inputs map[string]PackagePolicyRequestInput `json:"inputs,omitempty"`

	// Name Package policy name (should be unique)
	Name string `json:"name"`

	// Namespace The package policy namespace. Leave blank to inherit the agent policy's namespace.
	Namespace *string `json:"namespace,omitempty"`

	// Overrides Override settings that are defined in the package policy. The override option should be used only in unusual circumstances and not as a routine procedure.
	Overrides *struct {
		Inputs map[string]interface{} `json:"inputs,omitempty"`
	} `json:"overrides"`
	Package struct {
		// Name Package name
		Name string `json:"name"`

		// Version Package version
		Version string `json:"version"`
	} `json:"package"`

	// PolicyId Agent policy ID where that package policy will be added
	// Deprecated:
	PolicyId *string `json:"policy_id,omitempty"`

	// PolicyIds Agent policy IDs where that package policy will be added
	PolicyIds []string `json:"policy_ids,omitempty"`

	// Vars Package root level variable (see integration documentation for more information)
	Vars map[string]interface{} `json:"vars,omitempty"`
}

// PackagePolicyRequestInput defines model for package_policy_request_input.
type PackagePolicyRequestInput struct {
	// Enabled enable or disable that input, (default to true)
	Enabled *bool `json:"enabled,omitempty"`

	// Streams Input streams (see integration documentation to know what streams are available)
	Streams map[string]PackagePolicyRequestInputStream `json:"streams,omitempty"`

	// Vars Input level variable (see integration documentation for more information)
	Vars map[string]interface{} `json:"vars,omitempty"`
}

// PackagePolicyRequestInputStream defines model for package_policy_request_input_stream.
type PackagePolicyRequestInputStream struct {
	// Enabled enable or disable that stream, (default to true)
	Enabled *bool `json:"enabled,omitempty"`

	// Vars Stream level variable (see integration documentation for more information)
	Vars map[string]interface{} `json:"vars,omitempty"`
}

// PackageStatus defines model for package_status.
type PackageStatus string

// ParamsEsQueryRule defines model for params_es_query_rule.
type ParamsEsQueryRule struct {
	union json.RawMessage
}

// ParamsEsQueryRule0 The parameters for an Elasticsearch query rule that uses ES|QL to define the query. This functionality is in technical pre view and may be changed or removed in a future release. Elastic will work to fix any issues, but features in technical preview are not subject to the support SLA of official GA features.
type ParamsEsQueryRule0 struct {
	// AggField The name of the numeric field that is used in the aggregation. This property is required when `aggType` is `avg`, `max`, `min` or `sum`.
	AggField *Aggfield `json:"aggField,omitempty"`

	// AggType The type of aggregation to perform.
	AggType   *Aggtype `json:"aggType,omitempty"`
	EsqlQuery struct {
		// Esql The query definition, which uses Elasticsearch Query Language.
		Esql string `json:"esql"`
	} `json:"esqlQuery"`

	// ExcludeHitsFromPreviousRun Indicates whether to exclude matches from previous runs. If `true`, you can avoid alert duplication by excluding documents that have already been detected by the previous rule run. This option is not available when a grouping field is specified.
	ExcludeHitsFromPreviousRun *Excludehitsfrompreviousrun `json:"excludeHitsFromPreviousRun,omitempty"`

	// GroupBy Indicates whether the aggregation is applied over all documents (`all`) or split into groups (`top`) using a grouping field (`termField`). If grouping is used, an alert will be created for each group when it exceeds the threshold; only the top groups (up to `termSize` number of groups) are checked.
	GroupBy *Groupby `json:"groupBy,omitempty"`

	// SearchType The type of query, in this case a query that uses Elasticsearch Query Language (ES|QL).
	SearchType ParamsEsQueryRule0SearchType `json:"searchType"`

	// Size When `searchType` is `esqlQuery`, this property is required but it does not affect the rule behavior.
	Size int `json:"size"`

	// TermSize This property is required when `groupBy` is `top`. It specifies the number of groups to check against the threshold and therefore limits the number of alerts on high cardinality fields.
	TermSize *Termsize `json:"termSize,omitempty"`

	// Threshold The threshold value that is used with the `thresholdComparator`. When `searchType` is `esqlQuery`, this property is required and must be set to zero.
	Threshold []int `json:"threshold"`

	// ThresholdComparator The comparison function for the threshold. When `searchType` is `esqlQuery`, this property is required and must be set to ">". Since the `threshold` value must be `0`, the result is that an alert occurs whenever the query returns results.
	ThresholdComparator ParamsEsQueryRule0ThresholdComparator `json:"thresholdComparator"`

	// TimeField The field that is used to calculate the time window.
	TimeField *Timefield `json:"timeField,omitempty"`

	// TimeWindowSize The size of the time window (in `timeWindowUnit` units), which determines how far back to search for documents. Generally it should be a value higher than the rule check interval to avoid gaps in detection.
	TimeWindowSize Timewindowsize `json:"timeWindowSize"`

	// TimeWindowUnit The type of units for the time window: seconds, minutes, hours, or days.
	TimeWindowUnit Timewindowunit `json:"timeWindowUnit"`
}

// ParamsEsQueryRule0SearchType The type of query, in this case a query that uses Elasticsearch Query Language (ES|QL).
type ParamsEsQueryRule0SearchType string

// ParamsEsQueryRule0ThresholdComparator The comparison function for the threshold. When `searchType` is `esqlQuery`, this property is required and must be set to ">". Since the `threshold` value must be `0`, the result is that an alert occurs whenever the query returns results.
type ParamsEsQueryRule0ThresholdComparator string

// ParamsEsQueryRule1 The parameters for an Elasticsearch query rule that uses KQL or Lucene to define the query.
type ParamsEsQueryRule1 struct {
	// AggField The name of the numeric field that is used in the aggregation. This property is required when `aggType` is `avg`, `max`, `min` or `sum`.
	AggField *Aggfield `json:"aggField,omitempty"`

	// AggType The type of aggregation to perform.
	AggType *Aggtype `json:"aggType,omitempty"`

	// ExcludeHitsFromPreviousRun Indicates whether to exclude matches from previous runs. If `true`, you can avoid alert duplication by excluding documents that have already been detected by the previous rule run. This option is not available when a grouping field is specified.
	ExcludeHitsFromPreviousRun *Excludehitsfrompreviousrun `json:"excludeHitsFromPreviousRun,omitempty"`

	// GroupBy Indicates whether the aggregation is applied over all documents (`all`) or split into groups (`top`) using a grouping field (`termField`). If grouping is used, an alert will be created for each group when it exceeds the threshold; only the top groups (up to `termSize` number of groups) are checked.
	GroupBy *Groupby `json:"groupBy,omitempty"`

	// SearchConfiguration The query definition, which uses KQL or Lucene to fetch the documents from Elasticsearch.
	SearchConfiguration *struct {
		Filter []Filter `json:"filter,omitempty"`

		// Index The indices to query.
		Index *ParamsEsQueryRule_1_SearchConfiguration_Index `json:"index,omitempty"`
		Query *struct {
			Language *string `json:"language,omitempty"`
			Query    *string `json:"query,omitempty"`
		} `json:"query,omitempty"`
	} `json:"searchConfiguration,omitempty"`

	// SearchType The type of query, in this case a text-based query that uses KQL or Lucene.
	SearchType ParamsEsQueryRule1SearchType `json:"searchType"`

	// Size The number of documents to pass to the configured actions when the threshold condition is met.
	Size Size `json:"size"`

	// TermField The names of up to four fields that are used for grouping the aggregation. This property is required when `groupBy` is `top`.
	TermField *Termfield `json:"termField,omitempty"`

	// TermSize This property is required when `groupBy` is `top`. It specifies the number of groups to check against the threshold and therefore limits the number of alerts on high cardinality fields.
	TermSize *Termsize `json:"termSize,omitempty"`

	// Threshold The threshold value that is used with the `thresholdComparator`. If the `thresholdComparator` is `between` or `notBetween`, you must specify the boundary values.
	Threshold Threshold `json:"threshold"`

	// ThresholdComparator The comparison function for the threshold. For example, "is above", "is above or equals", "is below", "is below or equals", "is between", and "is not between".
	ThresholdComparator Thresholdcomparator `json:"thresholdComparator"`

	// TimeField The field that is used to calculate the time window.
	TimeField *Timefield `json:"timeField,omitempty"`

	// TimeWindowSize The size of the time window (in `timeWindowUnit` units), which determines how far back to search for documents. Generally it should be a value higher than the rule check interval to avoid gaps in detection.
	TimeWindowSize Timewindowsize `json:"timeWindowSize"`

	// TimeWindowUnit The type of units for the time window: seconds, minutes, hours, or days.
	TimeWindowUnit Timewindowunit `json:"timeWindowUnit"`
}

// ParamsEsQueryRule1SearchConfigurationIndex0 defines model for .
type ParamsEsQueryRule1SearchConfigurationIndex0 = string

// ParamsEsQueryRule1SearchConfigurationIndex1 defines model for .
type ParamsEsQueryRule1SearchConfigurationIndex1 = []string

// ParamsEsQueryRule_1_SearchConfiguration_Index The indices to query.
type ParamsEsQueryRule_1_SearchConfiguration_Index struct {
	union json.RawMessage
}

// ParamsEsQueryRule1SearchType The type of query, in this case a text-based query that uses KQL or Lucene.
type ParamsEsQueryRule1SearchType string

// ParamsEsQueryRule2 The parameters for an Elasticsearch query rule that uses Elasticsearch Query DSL to define the query.
type ParamsEsQueryRule2 struct {
	// AggField The name of the numeric field that is used in the aggregation. This property is required when `aggType` is `avg`, `max`, `min` or `sum`.
	AggField *Aggfield `json:"aggField,omitempty"`

	// AggType The type of aggregation to perform.
	AggType *Aggtype `json:"aggType,omitempty"`

	// EsQuery The query definition, which uses Elasticsearch Query DSL.
	EsQuery string `json:"esQuery"`

	// ExcludeHitsFromPreviousRun Indicates whether to exclude matches from previous runs. If `true`, you can avoid alert duplication by excluding documents that have already been detected by the previous rule run. This option is not available when a grouping field is specified.
	ExcludeHitsFromPreviousRun *Excludehitsfrompreviousrun `json:"excludeHitsFromPreviousRun,omitempty"`

	// GroupBy Indicates whether the aggregation is applied over all documents (`all`) or split into groups (`top`) using a grouping field (`termField`). If grouping is used, an alert will be created for each group when it exceeds the threshold; only the top groups (up to `termSize` number of groups) are checked.
	GroupBy *Groupby `json:"groupBy,omitempty"`

	// Index The indices to query.
	Index ParamsEsQueryRule_2_Index `json:"index"`

	// SearchType The type of query, in this case a query that uses Elasticsearch Query DSL.
	SearchType *ParamsEsQueryRule2SearchType `json:"searchType,omitempty"`

	// Size The number of documents to pass to the configured actions when the threshold condition is met.
	Size *Size `json:"size,omitempty"`

	// TermField The names of up to four fields that are used for grouping the aggregation. This property is required when `groupBy` is `top`.
	TermField *Termfield `json:"termField,omitempty"`

	// TermSize This property is required when `groupBy` is `top`. It specifies the number of groups to check against the threshold and therefore limits the number of alerts on high cardinality fields.
	TermSize *Termsize `json:"termSize,omitempty"`

	// Threshold The threshold value that is used with the `thresholdComparator`. If the `thresholdComparator` is `between` or `notBetween`, you must specify the boundary values.
	Threshold Threshold `json:"threshold"`

	// ThresholdComparator The comparison function for the threshold. For example, "is above", "is above or equals", "is below", "is below or equals", "is between", and "is not between".
	ThresholdComparator Thresholdcomparator `json:"thresholdComparator"`

	// TimeField The field that is used to calculate the time window.
	TimeField Timefield `json:"timeField"`

	// TimeWindowSize The size of the time window (in `timeWindowUnit` units), which determines how far back to search for documents. Generally it should be a value higher than the rule check interval to avoid gaps in detection.
	TimeWindowSize Timewindowsize `json:"timeWindowSize"`

	// TimeWindowUnit The type of units for the time window: seconds, minutes, hours, or days.
	TimeWindowUnit Timewindowunit `json:"timeWindowUnit"`
}

// ParamsEsQueryRule2Index0 defines model for .
type ParamsEsQueryRule2Index0 = []string

// ParamsEsQueryRule2Index1 defines model for .
type ParamsEsQueryRule2Index1 = string

// ParamsEsQueryRule_2_Index The indices to query.
type ParamsEsQueryRule_2_Index struct {
	union json.RawMessage
}

// ParamsEsQueryRule2SearchType The type of query, in this case a query that uses Elasticsearch Query DSL.
type ParamsEsQueryRule2SearchType string

// ParamsIndexThresholdRule The parameters for an index threshold rule.
type ParamsIndexThresholdRule struct {
	// AggField The name of the numeric field that is used in the aggregation. This property is required when `aggType` is `avg`, `max`, `min` or `sum`.
	AggField *Aggfield `json:"aggField,omitempty"`

	// AggType The type of aggregation to perform.
	AggType *Aggtype `json:"aggType,omitempty"`

	// FilterKuery A KQL expression thats limits the scope of alerts.
	FilterKuery *string `json:"filterKuery,omitempty"`

	// GroupBy Indicates whether the aggregation is applied over all documents (`all`) or split into groups (`top`) using a grouping field (`termField`). If grouping is used, an alert will be created for each group when it exceeds the threshold; only the top groups (up to `termSize` number of groups) are checked.
	GroupBy *Groupby `json:"groupBy,omitempty"`

	// Index The indices to query.
	Index []string `json:"index"`

	// TermField The names of up to four fields that are used for grouping the aggregation. This property is required when `groupBy` is `top`.
	TermField *Termfield `json:"termField,omitempty"`

	// TermSize This property is required when `groupBy` is `top`. It specifies the number of groups to check against the threshold and therefore limits the number of alerts on high cardinality fields.
	TermSize *Termsize `json:"termSize,omitempty"`

	// Threshold The threshold value that is used with the `thresholdComparator`. If the `thresholdComparator` is `between` or `notBetween`, you must specify the boundary values.
	Threshold Threshold `json:"threshold"`

	// ThresholdComparator The comparison function for the threshold. For example, "is above", "is above or equals", "is below", "is below or equals", "is between", and "is not between".
	ThresholdComparator Thresholdcomparator `json:"thresholdComparator"`

	// TimeField The field that is used to calculate the time window.
	TimeField Timefield `json:"timeField"`

	// TimeWindowSize The size of the time window (in `timeWindowUnit` units), which determines how far back to search for documents. Generally it should be a value higher than the rule check interval to avoid gaps in detection.
	TimeWindowSize Timewindowsize `json:"timeWindowSize"`

	// TimeWindowUnit The type of units for the time window: seconds, minutes, hours, or days.
	TimeWindowUnit Timewindowunit `json:"timeWindowUnit"`
}

// ParamsPropertyApmAnomaly defines model for params_property_apm_anomaly.
type ParamsPropertyApmAnomaly struct {
	// AnomalySeverityType The anomaly threshold value
	AnomalySeverityType ParamsPropertyApmAnomalyAnomalySeverityType `json:"anomalySeverityType"`

	// Environment The environment from APM
	Environment string `json:"environment"`

	// ServiceName The service name from APM
	ServiceName *string `json:"serviceName,omitempty"`

	// TransactionType The transaction type from APM
	TransactionType *string `json:"transactionType,omitempty"`

	// WindowSize The window size
	WindowSize float32 `json:"windowSize"`

	// WindowUnit The window size unit
	WindowUnit ParamsPropertyApmAnomalyWindowUnit `json:"windowUnit"`
}

// ParamsPropertyApmAnomalyAnomalySeverityType The anomaly threshold value
type ParamsPropertyApmAnomalyAnomalySeverityType string

// ParamsPropertyApmAnomalyWindowUnit The window size unit
type ParamsPropertyApmAnomalyWindowUnit string

// ParamsPropertyApmErrorCount defines model for params_property_apm_error_count.
type ParamsPropertyApmErrorCount struct {
	// Environment The environment from APM
	Environment      string                               `json:"environment"`
	ErrorGroupingKey *string                              `json:"errorGroupingKey,omitempty"`
	GroupBy          []ParamsPropertyApmErrorCountGroupBy `json:"groupBy,omitempty"`

	// ServiceName The service name from APM
	ServiceName *string `json:"serviceName,omitempty"`

	// Threshold The error count threshold value
	Threshold float32 `json:"threshold"`

	// WindowSize The window size
	WindowSize float32 `json:"windowSize"`

	// WindowUnit The window size unit
	WindowUnit ParamsPropertyApmErrorCountWindowUnit `json:"windowUnit"`
}

// ParamsPropertyApmErrorCountGroupBy defines model for ParamsPropertyApmErrorCount.GroupBy.
type ParamsPropertyApmErrorCountGroupBy string

// ParamsPropertyApmErrorCountWindowUnit The window size unit
type ParamsPropertyApmErrorCountWindowUnit string

// ParamsPropertyApmTransactionDuration defines model for params_property_apm_transaction_duration.
type ParamsPropertyApmTransactionDuration struct {
	AggregationType ParamsPropertyApmTransactionDurationAggregationType `json:"aggregationType"`
	Environment     string                                              `json:"environment"`
	GroupBy         []ParamsPropertyApmTransactionDurationGroupBy       `json:"groupBy,omitempty"`

	// ServiceName The service name from APM
	ServiceName *string `json:"serviceName,omitempty"`

	// Threshold The latency threshold value
	Threshold float32 `json:"threshold"`

	// TransactionName The transaction name from APM
	TransactionName *string `json:"transactionName,omitempty"`

	// TransactionType The transaction type from APM
	TransactionType *string `json:"transactionType,omitempty"`

	// WindowSize The window size
	WindowSize float32 `json:"windowSize"`

	// WindowUnit ç
	WindowUnit ParamsPropertyApmTransactionDurationWindowUnit `json:"windowUnit"`
}

// ParamsPropertyApmTransactionDurationAggregationType defines model for ParamsPropertyApmTransactionDuration.AggregationType.
type ParamsPropertyApmTransactionDurationAggregationType string

// ParamsPropertyApmTransactionDurationGroupBy defines model for ParamsPropertyApmTransactionDuration.GroupBy.
type ParamsPropertyApmTransactionDurationGroupBy string

// ParamsPropertyApmTransactionDurationWindowUnit ç
type ParamsPropertyApmTransactionDurationWindowUnit string

// ParamsPropertyApmTransactionErrorRate defines model for params_property_apm_transaction_error_rate.
type ParamsPropertyApmTransactionErrorRate struct {
	// Environment The environment from APM
	Environment string                                         `json:"environment"`
	GroupBy     []ParamsPropertyApmTransactionErrorRateGroupBy `json:"groupBy,omitempty"`

	// ServiceName The service name from APM
	ServiceName *string `json:"serviceName,omitempty"`

	// Threshold The error rate threshold value
	Threshold float32 `json:"threshold"`

	// TransactionName The transaction name from APM
	TransactionName *string `json:"transactionName,omitempty"`

	// TransactionType The transaction type from APM
	TransactionType *string `json:"transactionType,omitempty"`

	// WindowSize The window size
	WindowSize float32 `json:"windowSize"`

	// WindowUnit The window size unit
	WindowUnit ParamsPropertyApmTransactionErrorRateWindowUnit `json:"windowUnit"`
}

// ParamsPropertyApmTransactionErrorRateGroupBy defines model for ParamsPropertyApmTransactionErrorRate.GroupBy.
type ParamsPropertyApmTransactionErrorRateGroupBy string

// ParamsPropertyApmTransactionErrorRateWindowUnit The window size unit
type ParamsPropertyApmTransactionErrorRateWindowUnit string

// ParamsPropertyInfraInventory defines model for params_property_infra_inventory.
type ParamsPropertyInfraInventory struct {
	AlertOnNoData *bool `json:"alertOnNoData,omitempty"`
	Criteria      []struct {
		Comparator   *ParamsPropertyInfraInventoryCriteriaComparator `json:"comparator,omitempty"`
		CustomMetric *struct {
			Aggregation *ParamsPropertyInfraInventoryCriteriaCustomMetricAggregation `json:"aggregation,omitempty"`
			Field       *string                                                      `json:"field,omitempty"`
			Id          *string                                                      `json:"id,omitempty"`
			Label       *string                                                      `json:"label,omitempty"`
			Type        *ParamsPropertyInfraInventoryCriteriaCustomMetricType        `json:"type,omitempty"`
		} `json:"customMetric,omitempty"`
		Metric            *ParamsPropertyInfraInventoryCriteriaMetric            `json:"metric,omitempty"`
		SourceId          *string                                                `json:"sourceId,omitempty"`
		Threshold         []float32                                              `json:"threshold,omitempty"`
		TimeSize          *float32                                               `json:"timeSize,omitempty"`
		TimeUnit          *ParamsPropertyInfraInventoryCriteriaTimeUnit          `json:"timeUnit,omitempty"`
		WarningComparator *ParamsPropertyInfraInventoryCriteriaWarningComparator `json:"warningComparator,omitempty"`
		WarningThreshold  []float32                                              `json:"warningThreshold,omitempty"`
	} `json:"criteria,omitempty"`
	FilterQuery     *string                               `json:"filterQuery,omitempty"`
	FilterQueryText *string                               `json:"filterQueryText,omitempty"`
	NodeType        *ParamsPropertyInfraInventoryNodeType `json:"nodeType,omitempty"`
	SourceId        *string                               `json:"sourceId,omitempty"`
}

// ParamsPropertyInfraInventoryCriteriaComparator defines model for ParamsPropertyInfraInventory.Criteria.Comparator.
type ParamsPropertyInfraInventoryCriteriaComparator string

// ParamsPropertyInfraInventoryCriteriaCustomMetricAggregation defines model for ParamsPropertyInfraInventory.Criteria.CustomMetric.Aggregation.
type ParamsPropertyInfraInventoryCriteriaCustomMetricAggregation string

// ParamsPropertyInfraInventoryCriteriaCustomMetricType defines model for ParamsPropertyInfraInventory.Criteria.CustomMetric.Type.
type ParamsPropertyInfraInventoryCriteriaCustomMetricType string

// ParamsPropertyInfraInventoryCriteriaMetric defines model for ParamsPropertyInfraInventory.Criteria.Metric.
type ParamsPropertyInfraInventoryCriteriaMetric string

// ParamsPropertyInfraInventoryCriteriaTimeUnit defines model for ParamsPropertyInfraInventory.Criteria.TimeUnit.
type ParamsPropertyInfraInventoryCriteriaTimeUnit string

// ParamsPropertyInfraInventoryCriteriaWarningComparator defines model for ParamsPropertyInfraInventory.Criteria.WarningComparator.
type ParamsPropertyInfraInventoryCriteriaWarningComparator string

// ParamsPropertyInfraInventoryNodeType defines model for ParamsPropertyInfraInventory.NodeType.
type ParamsPropertyInfraInventoryNodeType string

// ParamsPropertyInfraMetricThreshold defines model for params_property_infra_metric_threshold.
type ParamsPropertyInfraMetricThreshold struct {
	AlertOnGroupDisappear *bool                                              `json:"alertOnGroupDisappear,omitempty"`
	AlertOnNoData         *bool                                              `json:"alertOnNoData,omitempty"`
	Criteria              []ParamsPropertyInfraMetricThreshold_Criteria_Item `json:"criteria,omitempty"`
	FilterQuery           *string                                            `json:"filterQuery,omitempty"`
	GroupBy               *ParamsPropertyInfraMetricThreshold_GroupBy        `json:"groupBy,omitempty"`
	SourceId              *string                                            `json:"sourceId,omitempty"`
}

// ParamsPropertyInfraMetricThresholdCriteria0 defines model for .
type ParamsPropertyInfraMetricThresholdCriteria0 struct {
	AggType           *ParamsPropertyInfraMetricThresholdCriteria0AggType           `json:"aggType,omitempty"`
	Comparator        *ParamsPropertyInfraMetricThresholdCriteria0Comparator        `json:"comparator,omitempty"`
	Metric            *string                                                       `json:"metric,omitempty"`
	Threshold         []float32                                                     `json:"threshold,omitempty"`
	TimeSize          *float32                                                      `json:"timeSize,omitempty"`
	TimeUnit          *string                                                       `json:"timeUnit,omitempty"`
	WarningComparator *ParamsPropertyInfraMetricThresholdCriteria0WarningComparator `json:"warningComparator,omitempty"`
	WarningThreshold  []float32                                                     `json:"warningThreshold,omitempty"`
}

// ParamsPropertyInfraMetricThresholdCriteria0AggType defines model for ParamsPropertyInfraMetricThreshold.Criteria.0.AggType.
type ParamsPropertyInfraMetricThresholdCriteria0AggType string

// ParamsPropertyInfraMetricThresholdCriteria0Comparator defines model for ParamsPropertyInfraMetricThreshold.Criteria.0.Comparator.
type ParamsPropertyInfraMetricThresholdCriteria0Comparator string

// ParamsPropertyInfraMetricThresholdCriteria0WarningComparator defines model for ParamsPropertyInfraMetricThreshold.Criteria.0.WarningComparator.
type ParamsPropertyInfraMetricThresholdCriteria0WarningComparator string

// ParamsPropertyInfraMetricThresholdCriteria1 defines model for .
type ParamsPropertyInfraMetricThresholdCriteria1 struct {
	AggType           *ParamsPropertyInfraMetricThresholdCriteria1AggType           `json:"aggType,omitempty"`
	Comparator        *ParamsPropertyInfraMetricThresholdCriteria1Comparator        `json:"comparator,omitempty"`
	Threshold         []float32                                                     `json:"threshold,omitempty"`
	TimeSize          *float32                                                      `json:"timeSize,omitempty"`
	TimeUnit          *string                                                       `json:"timeUnit,omitempty"`
	WarningComparator *ParamsPropertyInfraMetricThresholdCriteria1WarningComparator `json:"warningComparator,omitempty"`
	WarningThreshold  []float32                                                     `json:"warningThreshold,omitempty"`
}

// ParamsPropertyInfraMetricThresholdCriteria1AggType defines model for ParamsPropertyInfraMetricThreshold.Criteria.1.AggType.
type ParamsPropertyInfraMetricThresholdCriteria1AggType string

// ParamsPropertyInfraMetricThresholdCriteria1Comparator defines model for ParamsPropertyInfraMetricThreshold.Criteria.1.Comparator.
type ParamsPropertyInfraMetricThresholdCriteria1Comparator string

// ParamsPropertyInfraMetricThresholdCriteria1WarningComparator defines model for ParamsPropertyInfraMetricThreshold.Criteria.1.WarningComparator.
type ParamsPropertyInfraMetricThresholdCriteria1WarningComparator string

// ParamsPropertyInfraMetricThresholdCriteria2 defines model for .
type ParamsPropertyInfraMetricThresholdCriteria2 struct {
	AggType           *ParamsPropertyInfraMetricThresholdCriteria2AggType               `json:"aggType,omitempty"`
	Comparator        *ParamsPropertyInfraMetricThresholdCriteria2Comparator            `json:"comparator,omitempty"`
	CustomMetric      []ParamsPropertyInfraMetricThreshold_Criteria_2_CustomMetric_Item `json:"customMetric,omitempty"`
	Equation          *string                                                           `json:"equation,omitempty"`
	Label             *string                                                           `json:"label,omitempty"`
	Threshold         []float32                                                         `json:"threshold,omitempty"`
	TimeSize          *float32                                                          `json:"timeSize,omitempty"`
	TimeUnit          *string                                                           `json:"timeUnit,omitempty"`
	WarningComparator *ParamsPropertyInfraMetricThresholdCriteria2WarningComparator     `json:"warningComparator,omitempty"`
	WarningThreshold  []float32                                                         `json:"warningThreshold,omitempty"`
}

// ParamsPropertyInfraMetricThresholdCriteria2AggType defines model for ParamsPropertyInfraMetricThreshold.Criteria.2.AggType.
type ParamsPropertyInfraMetricThresholdCriteria2AggType string

// ParamsPropertyInfraMetricThresholdCriteria2Comparator defines model for ParamsPropertyInfraMetricThreshold.Criteria.2.Comparator.
type ParamsPropertyInfraMetricThresholdCriteria2Comparator string

// ParamsPropertyInfraMetricThresholdCriteria2CustomMetric0 defines model for .
type ParamsPropertyInfraMetricThresholdCriteria2CustomMetric0 struct {
	AggType *ParamsPropertyInfraMetricThresholdCriteria2CustomMetric0AggType `json:"aggType,omitempty"`
	Field   *string                                                          `json:"field,omitempty"`
	Name    *string                                                          `json:"name,omitempty"`
}

// ParamsPropertyInfraMetricThresholdCriteria2CustomMetric0AggType defines model for ParamsPropertyInfraMetricThreshold.Criteria.2.CustomMetric.0.AggType.
type ParamsPropertyInfraMetricThresholdCriteria2CustomMetric0AggType string

// ParamsPropertyInfraMetricThresholdCriteria2CustomMetric1 defines model for .
type ParamsPropertyInfraMetricThresholdCriteria2CustomMetric1 struct {
	AggType *ParamsPropertyInfraMetricThresholdCriteria2CustomMetric1AggType `json:"aggType,omitempty"`
	Filter  *string                                                          `json:"filter,omitempty"`
	Name    *string                                                          `json:"name,omitempty"`
}

// ParamsPropertyInfraMetricThresholdCriteria2CustomMetric1AggType defines model for ParamsPropertyInfraMetricThreshold.Criteria.2.CustomMetric.1.AggType.
type ParamsPropertyInfraMetricThresholdCriteria2CustomMetric1AggType string

// ParamsPropertyInfraMetricThreshold_Criteria_2_CustomMetric_Item defines model for ParamsPropertyInfraMetricThreshold.Criteria.2.customMetric.Item.
type ParamsPropertyInfraMetricThreshold_Criteria_2_CustomMetric_Item struct {
	union json.RawMessage
}

// ParamsPropertyInfraMetricThresholdCriteria2WarningComparator defines model for ParamsPropertyInfraMetricThreshold.Criteria.2.WarningComparator.
type ParamsPropertyInfraMetricThresholdCriteria2WarningComparator string

// ParamsPropertyInfraMetricThreshold_Criteria_Item defines model for params_property_infra_metric_threshold.criteria.Item.
type ParamsPropertyInfraMetricThreshold_Criteria_Item struct {
	union json.RawMessage
}

// ParamsPropertyInfraMetricThresholdGroupBy0 defines model for .
type ParamsPropertyInfraMetricThresholdGroupBy0 = string

// ParamsPropertyInfraMetricThresholdGroupBy1 defines model for .
type ParamsPropertyInfraMetricThresholdGroupBy1 = []string

// ParamsPropertyInfraMetricThreshold_GroupBy defines model for ParamsPropertyInfraMetricThreshold.GroupBy.
type ParamsPropertyInfraMetricThreshold_GroupBy struct {
	union json.RawMessage
}

// ParamsPropertyLogThreshold defines model for params_property_log_threshold.
type ParamsPropertyLogThreshold struct {
	union json.RawMessage
}

// ParamsPropertyLogThreshold0 defines model for .
type ParamsPropertyLogThreshold0 struct {
	Count struct {
		Comparator *ParamsPropertyLogThreshold0CountComparator `json:"comparator,omitempty"`
		Value      *float32                                    `json:"value,omitempty"`
	} `json:"count"`
	Criteria []struct {
		Comparator *ParamsPropertyLogThreshold0CriteriaComparator `json:"comparator,omitempty"`
		Field      *string                                        `json:"field,omitempty"`
		Value      *ParamsPropertyLogThreshold_0_Criteria_Value   `json:"value,omitempty"`
	} `json:"criteria,omitempty"`
	GroupBy []string `json:"groupBy,omitempty"`
	LogView struct {
		LogViewId *string                                 `json:"logViewId,omitempty"`
		Type      *ParamsPropertyLogThreshold0LogViewType `json:"type,omitempty"`
	} `json:"logView"`
	TimeSize float32                             `json:"timeSize"`
	TimeUnit ParamsPropertyLogThreshold0TimeUnit `json:"timeUnit"`
}

// ParamsPropertyLogThreshold0CountComparator defines model for ParamsPropertyLogThreshold.0.Count.Comparator.
type ParamsPropertyLogThreshold0CountComparator string

// ParamsPropertyLogThreshold0CriteriaComparator defines model for ParamsPropertyLogThreshold.0.Criteria.Comparator.
type ParamsPropertyLogThreshold0CriteriaComparator string

// ParamsPropertyLogThreshold0CriteriaValue0 defines model for .
type ParamsPropertyLogThreshold0CriteriaValue0 = float32

// ParamsPropertyLogThreshold0CriteriaValue1 defines model for .
type ParamsPropertyLogThreshold0CriteriaValue1 = string

// ParamsPropertyLogThreshold_0_Criteria_Value defines model for ParamsPropertyLogThreshold.0.Criteria.Value.
type ParamsPropertyLogThreshold_0_Criteria_Value struct {
	union json.RawMessage
}

// ParamsPropertyLogThreshold0LogViewType defines model for ParamsPropertyLogThreshold.0.LogView.Type.
type ParamsPropertyLogThreshold0LogViewType string

// ParamsPropertyLogThreshold0TimeUnit defines model for ParamsPropertyLogThreshold.0.TimeUnit.
type ParamsPropertyLogThreshold0TimeUnit string

// ParamsPropertyLogThreshold1 defines model for .
type ParamsPropertyLogThreshold1 struct {
	Count struct {
		Comparator *ParamsPropertyLogThreshold1CountComparator `json:"comparator,omitempty"`
		Value      *float32                                    `json:"value,omitempty"`
	} `json:"count"`
	Criteria [][]struct {
		Comparator *ParamsPropertyLogThreshold1CriteriaComparator `json:"comparator,omitempty"`
		Field      *string                                        `json:"field,omitempty"`
		Value      *ParamsPropertyLogThreshold_1_Criteria_Value   `json:"value,omitempty"`
	} `json:"criteria,omitempty"`
	GroupBy []string `json:"groupBy,omitempty"`
	LogView struct {
		LogViewId *string                                 `json:"logViewId,omitempty"`
		Type      *ParamsPropertyLogThreshold1LogViewType `json:"type,omitempty"`
	} `json:"logView"`
	TimeSize float32                             `json:"timeSize"`
	TimeUnit ParamsPropertyLogThreshold1TimeUnit `json:"timeUnit"`
}

// ParamsPropertyLogThreshold1CountComparator defines model for ParamsPropertyLogThreshold.1.Count.Comparator.
type ParamsPropertyLogThreshold1CountComparator string

// ParamsPropertyLogThreshold1CriteriaComparator defines model for ParamsPropertyLogThreshold.1.Criteria.Comparator.
type ParamsPropertyLogThreshold1CriteriaComparator string

// ParamsPropertyLogThreshold1CriteriaValue0 defines model for .
type ParamsPropertyLogThreshold1CriteriaValue0 = float32

// ParamsPropertyLogThreshold1CriteriaValue1 defines model for .
type ParamsPropertyLogThreshold1CriteriaValue1 = string

// ParamsPropertyLogThreshold_1_Criteria_Value defines model for ParamsPropertyLogThreshold.1.Criteria.Value.
type ParamsPropertyLogThreshold_1_Criteria_Value struct {
	union json.RawMessage
}

// ParamsPropertyLogThreshold1LogViewType defines model for ParamsPropertyLogThreshold.1.LogView.Type.
type ParamsPropertyLogThreshold1LogViewType string

// ParamsPropertyLogThreshold1TimeUnit defines model for ParamsPropertyLogThreshold.1.TimeUnit.
type ParamsPropertyLogThreshold1TimeUnit string

// ParamsPropertySloBurnRate defines model for params_property_slo_burn_rate.
type ParamsPropertySloBurnRate struct {
	// BurnRateThreshold The burn rate threshold used to trigger the alert
	BurnRateThreshold *float32 `json:"burnRateThreshold,omitempty"`

	// LongWindow The duration of the long window used to compute the burn rate
	LongWindow *struct {
		// Unit The duration unit
		Unit *string `json:"unit,omitempty"`

		// Value The duration value
		Value *float32 `json:"value,omitempty"`
	} `json:"longWindow,omitempty"`

	// MaxBurnRateThreshold The maximum burn rate threshold value defined by the SLO error budget
	MaxBurnRateThreshold *float32 `json:"maxBurnRateThreshold,omitempty"`

	// ShortWindow The duration of the short window used to compute the burn rate
	ShortWindow *struct {
		// Unit The duration unit
		Unit *string `json:"unit,omitempty"`

		// Value The duration value
		Value *float32 `json:"value,omitempty"`
	} `json:"shortWindow,omitempty"`

	// SloId The SLO identifier used by the rule
	SloId *string `json:"sloId,omitempty"`
}

// ParamsPropertySyntheticsMonitorStatus defines model for params_property_synthetics_monitor_status.
type ParamsPropertySyntheticsMonitorStatus struct {
	Availability *struct {
		Range     *float32 `json:"range,omitempty"`
		RangeUnit *string  `json:"rangeUnit,omitempty"`
		Threshold *string  `json:"threshold,omitempty"`
	} `json:"availability,omitempty"`
	Filters         *ParamsPropertySyntheticsMonitorStatus_Filters `json:"filters,omitempty"`
	IsAutoGenerated *bool                                          `json:"isAutoGenerated,omitempty"`
	// Deprecated:
	Locations               []string `json:"locations,omitempty"`
	NumTimes                float32  `json:"numTimes"`
	Search                  *string  `json:"search,omitempty"`
	ShouldCheckAvailability bool     `json:"shouldCheckAvailability"`
	ShouldCheckStatus       bool     `json:"shouldCheckStatus"`
	// Deprecated:
	Timerange *struct {
		From *string `json:"from,omitempty"`
		To   *string `json:"to,omitempty"`
	} `json:"timerange,omitempty"`
	TimerangeCount *float32 `json:"timerangeCount,omitempty"`
	TimerangeUnit  *string  `json:"timerangeUnit,omitempty"`
	Version        *float32 `json:"version,omitempty"`
}

// ParamsPropertySyntheticsMonitorStatusFilters0 defines model for .
type ParamsPropertySyntheticsMonitorStatusFilters0 = string

// ParamsPropertySyntheticsMonitorStatusFilters1 defines model for .
type ParamsPropertySyntheticsMonitorStatusFilters1 struct {
	MonitorType     []string `json:"monitor.type,omitempty"`
	ObserverGeoName []string `json:"observer.geo.name,omitempty"`
	Tags            []string `json:"tags,omitempty"`
	UrlPort         []string `json:"url.port,omitempty"`
}

// ParamsPropertySyntheticsMonitorStatus_Filters defines model for ParamsPropertySyntheticsMonitorStatus.Filters.
type ParamsPropertySyntheticsMonitorStatus_Filters struct {
	union json.RawMessage
}

// ParamsPropertySyntheticsUptimeTls defines model for params_property_synthetics_uptime_tls.
type ParamsPropertySyntheticsUptimeTls struct {
	CertAgeThreshold        *float32 `json:"certAgeThreshold,omitempty"`
	CertExpirationThreshold *float32 `json:"certExpirationThreshold,omitempty"`
	Search                  *string  `json:"search,omitempty"`
}

// RuleResponseProperties defines model for rule_response_properties.
type RuleResponseProperties struct {
	Actions Actions `json:"actions"`

	// AlertDelay Indicates that an alert occurs only when the specified number of consecutive runs met the rule conditions.
	AlertDelay *AlertDelay `json:"alert_delay,omitempty"`

	// ApiKeyCreatedByUser Indicates whether the API key that is associated with the rule was created by the user.
	ApiKeyCreatedByUser *bool `json:"api_key_created_by_user,omitempty"`

	// ApiKeyOwner The owner of the API key that is associated with the rule and used to run background tasks.
	ApiKeyOwner *string `json:"api_key_owner"`

	// Consumer The application or feature that owns the rule. For example, `alerts`, `apm`, `discover`, `infrastructure`, `logs`, `metrics`, `ml`, `monitoring`, `securitySolution`, `siem`, `stackAlerts`, or `uptime`.
	Consumer string `json:"consumer"`

	// CreatedAt The date and time that the rule was created.
	CreatedAt time.Time `json:"created_at"`

	// CreatedBy The identifier for the user that created the rule.
	CreatedBy *string `json:"created_by"`

	// Enabled Indicates whether the rule is currently enabled.
	Enabled         bool `json:"enabled"`
	ExecutionStatus struct {
		LastDuration      *int       `json:"last_duration,omitempty"`
		LastExecutionDate *time.Time `json:"last_execution_date,omitempty"`
		Status            *string    `json:"status,omitempty"`
	} `json:"execution_status"`

	// Id The identifier for the rule.
	Id      string `json:"id"`
	LastRun *struct {
		AlertsCount *struct {
			Active    *int `json:"active,omitempty"`
			Ignored   *int `json:"ignored,omitempty"`
			New       *int `json:"new,omitempty"`
			Recovered *int `json:"recovered,omitempty"`
		} `json:"alerts_count,omitempty"`
		Outcome      *string  `json:"outcome,omitempty"`
		OutcomeMsg   []string `json:"outcome_msg"`
		OutcomeOrder *int     `json:"outcome_order,omitempty"`
		Warning      *string  `json:"warning"`
	} `json:"last_run,omitempty"`
	MuteAll       bool     `json:"mute_all"`
	MutedAlertIds []string `json:"muted_alert_ids"`

	// Name The name of the rule.
	Name    string     `json:"name"`
	NextRun *time.Time `json:"next_run"`

	// NotifyWhen Indicates how often alerts generate actions.
	NotifyWhen *string `json:"notify_when"`

	// Params The parameters for the rule.
	Params map[string]interface{} `json:"params"`

	// Revision The rule revision number.
	Revision *int `json:"revision,omitempty"`

	// RuleTypeId The identifier for the type of rule. For example, `.es-query`, `.index-threshold`, `logs.alert.document.count`, `monitoring_alert_cluster_health`, `siem.thresholdRule`, or `xpack.ml.anomaly_detection_alert`.
	RuleTypeId string `json:"rule_type_id"`

	// Running Indicates whether the rule is running.
	Running *bool `json:"running,omitempty"`

	// Schedule The check interval, which specifies how frequently the rule conditions are checked. The interval is specified in seconds, minutes, hours, or days.
	Schedule        Schedule `json:"schedule"`
	ScheduledTaskId *string  `json:"scheduled_task_id,omitempty"`

	// Tags The tags for the rule.
	Tags Tags `json:"tags"`

	// Throttle Deprecated in 8.13.0. Use the `throttle` property in the action `frequency` object instead. The throttle interval, which defines how often an alert generates repeated actions. NOTE: You cannot specify the throttle interval at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	Throttle *Throttle `json:"throttle"`

	// UpdatedAt The date and time that the rule was updated most recently.
	UpdatedAt string `json:"updated_at"`

	// UpdatedBy The identifier for the user that updated this rule most recently.
	UpdatedBy *string `json:"updated_by"`
}

// Runtimefieldmap A map of runtime field definitions by field name.
type Runtimefieldmap struct {
	Script struct {
		// Source Script for the runtime field.
		Source *string `json:"source,omitempty"`
	} `json:"script"`

	// Type Mapping type of the runtime field.
	Type string `json:"type"`
}

// Schedule The check interval, which specifies how frequently the rule conditions are checked. The interval is specified in seconds, minutes, hours, or days.
type Schedule struct {
	Interval *string `json:"interval,omitempty"`
}

// SearchResult defines model for search_result.
type SearchResult struct {
	Description      string            `json:"description"`
	Download         string            `json:"download"`
	Icons            string            `json:"icons"`
	InstallationInfo *InstallationInfo `json:"installationInfo,omitempty"`
	Name             string            `json:"name"`
	Path             string            `json:"path"`
	// Deprecated:
	SavedObject map[string]interface{} `json:"savedObject,omitempty"`
	Status      string                 `json:"status"`
	Title       string                 `json:"title"`
	Type        string                 `json:"type"`
	Version     string                 `json:"version"`
}

// Settings Defines properties for SLO settings.
type Settings struct {
	// Frequency Configure how often the transform runs, default 1m
	Frequency *string `json:"frequency,omitempty"`

	// PreventInitialBackfill Prevents the transform from backfilling data when it starts.
	PreventInitialBackfill *bool `json:"preventInitialBackfill,omitempty"`

	// SyncDelay The synch delay to apply to the transform. Default 1m
	SyncDelay *string `json:"syncDelay,omitempty"`
}

// Size The number of documents to pass to the configured actions when the threshold condition is met.
type Size = int

// SloDefinitionResponse defines model for slo_definition_response.
type SloDefinitionResponse struct {
	// BudgetingMethod The budgeting method to use when computing the rollup data.
	BudgetingMethod BudgetingMethod `json:"budgetingMethod"`

	// CreatedAt The creation date
	CreatedAt string `json:"createdAt"`

	// Description The description of the SLO.
	Description string `json:"description"`

	// Enabled Indicate if the SLO is enabled
	Enabled bool `json:"enabled"`

	// GroupBy optional group by field to use to generate an SLO per distinct value
	GroupBy string `json:"groupBy"`

	// Id The identifier of the SLO.
	Id        string                          `json:"id"`
	Indicator SloDefinitionResponse_Indicator `json:"indicator"`

	// Name The name of the SLO.
	Name string `json:"name"`

	// Objective Defines properties for the SLO objective
	Objective Objective `json:"objective"`

	// Revision The SLO revision
	Revision float32 `json:"revision"`

	// Settings Defines properties for SLO settings.
	Settings Settings `json:"settings"`

	// Tags List of tags
	Tags []string `json:"tags"`

	// TimeWindow Defines properties for the SLO time window
	TimeWindow TimeWindow `json:"timeWindow"`

	// UpdatedAt The last update date
	UpdatedAt string `json:"updatedAt"`

	// Version The internal SLO version
	Version float32 `json:"version"`
}

// SloDefinitionResponse_Indicator defines model for SloDefinitionResponse.Indicator.
type SloDefinitionResponse_Indicator struct {
	union json.RawMessage
}

// SloWithSummaryResponse defines model for slo_with_summary_response.
type SloWithSummaryResponse struct {
	// BudgetingMethod The budgeting method to use when computing the rollup data.
	BudgetingMethod BudgetingMethod `json:"budgetingMethod"`

	// CreatedAt The creation date
	CreatedAt string `json:"createdAt"`

	// Description The description of the SLO.
	Description string `json:"description"`

	// Enabled Indicate if the SLO is enabled
	Enabled bool `json:"enabled"`

	// GroupBy optional group by field to use to generate an SLO per distinct value
	GroupBy string `json:"groupBy"`

	// Id The identifier of the SLO.
	Id        string                           `json:"id"`
	Indicator SloWithSummaryResponse_Indicator `json:"indicator"`

	// InstanceId the value derived from the groupBy field, if present, otherwise '*'
	InstanceId string `json:"instanceId"`

	// Name The name of the SLO.
	Name string `json:"name"`

	// Objective Defines properties for the SLO objective
	Objective Objective `json:"objective"`

	// Revision The SLO revision
	Revision float32 `json:"revision"`

	// Settings Defines properties for SLO settings.
	Settings Settings `json:"settings"`

	// Summary The SLO computed data
	Summary Summary `json:"summary"`

	// Tags List of tags
	Tags []string `json:"tags"`

	// TimeWindow Defines properties for the SLO time window
	TimeWindow TimeWindow `json:"timeWindow"`

	// UpdatedAt The last update date
	UpdatedAt string `json:"updatedAt"`

	// Version The internal SLO version
	Version float32 `json:"version"`
}

// SloWithSummaryResponse_Indicator defines model for SloWithSummaryResponse.Indicator.
type SloWithSummaryResponse_Indicator struct {
	union json.RawMessage
}

// Sourcefilters The array of field names you want to filter out in Discover.
type Sourcefilters = []struct {
	Value string `json:"value"`
}

// Summary The SLO computed data
type Summary struct {
	ErrorBudget ErrorBudget   `json:"errorBudget"`
	SliValue    float32       `json:"sliValue"`
	Status      SummaryStatus `json:"status"`
}

// SummaryStatus defines model for summary_status.
type SummaryStatus string

// Tags The tags for the rule.
type Tags = []string

// Termfield The names of up to four fields that are used for grouping the aggregation. This property is required when `groupBy` is `top`.
type Termfield struct {
	union json.RawMessage
}

// Termfield0 defines model for .
type Termfield0 = string

// Termfield1 defines model for .
type Termfield1 = []string

// Termsize This property is required when `groupBy` is `top`. It specifies the number of groups to check against the threshold and therefore limits the number of alerts on high cardinality fields.
type Termsize = int

// Threshold The threshold value that is used with the `thresholdComparator`. If the `thresholdComparator` is `between` or `notBetween`, you must specify the boundary values.
type Threshold = []int

// Thresholdcomparator The comparison function for the threshold. For example, "is above", "is above or equals", "is below", "is below or equals", "is between", and "is not between".
type Thresholdcomparator string

// Throttle Deprecated in 8.13.0. Use the `throttle` property in the action `frequency` object instead. The throttle interval, which defines how often an alert generates repeated actions. NOTE: You cannot specify the throttle interval at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
type Throttle = string

// ThrottleAction The throttle interval, which defines how often an alert generates repeated actions. It is specified in seconds, minutes, hours, or days and is applicable only if `notify_when` is set to `onThrottleInterval`. NOTE: You cannot specify the throttle interval at both the rule and action level. The recommended method is to set it for each action. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
type ThrottleAction = string

// TimeWindow Defines properties for the SLO time window
type TimeWindow struct {
	// Duration the duration formatted as {duration}{unit}. Accepted values for rolling: 7d, 30d, 90d. Accepted values for calendar aligned: 1w (weekly) or 1M (monthly)
	Duration string `json:"duration"`

	// Type Indicates weither the time window is a rolling or a calendar aligned time window.
	Type TimeWindowType `json:"type"`
}

// TimeWindowType Indicates weither the time window is a rolling or a calendar aligned time window.
type TimeWindowType string

// Timefield The field that is used to calculate the time window.
type Timefield = string

// Timefieldname The timestamp field name, which you use for time-based data views.
type Timefieldname = string

// TimesliceMetricBasicMetricWithField defines model for timeslice_metric_basic_metric_with_field.
type TimesliceMetricBasicMetricWithField struct {
	// Aggregation The aggregation type of the metric.
	Aggregation TimesliceMetricBasicMetricWithFieldAggregation `json:"aggregation"`

	// Field The field of the metric.
	Field string `json:"field"`

	// Filter The filter to apply to the metric.
	Filter *string `json:"filter,omitempty"`

	// Name The name of the metric. Only valid options are A-Z
	Name string `json:"name"`
}

// TimesliceMetricBasicMetricWithFieldAggregation The aggregation type of the metric.
type TimesliceMetricBasicMetricWithFieldAggregation string

// TimesliceMetricDocCountMetric defines model for timeslice_metric_doc_count_metric.
type TimesliceMetricDocCountMetric struct {
	// Aggregation The aggregation type of the metric. Only valid option is "doc_count"
	Aggregation TimesliceMetricDocCountMetricAggregation `json:"aggregation"`

	// Filter The filter to apply to the metric.
	Filter *string `json:"filter,omitempty"`

	// Name The name of the metric. Only valid options are A-Z
	Name string `json:"name"`
}

// TimesliceMetricDocCountMetricAggregation The aggregation type of the metric. Only valid option is "doc_count"
type TimesliceMetricDocCountMetricAggregation string

// TimesliceMetricPercentileMetric defines model for timeslice_metric_percentile_metric.
type TimesliceMetricPercentileMetric struct {
	// Aggregation The aggregation type of the metric. Only valid option is "percentile"
	Aggregation TimesliceMetricPercentileMetricAggregation `json:"aggregation"`

	// Field The field of the metric.
	Field string `json:"field"`

	// Filter The filter to apply to the metric.
	Filter *string `json:"filter,omitempty"`

	// Name The name of the metric. Only valid options are A-Z
	Name string `json:"name"`

	// Percentile The percentile value.
	Percentile float32 `json:"percentile"`
}

// TimesliceMetricPercentileMetricAggregation The aggregation type of the metric. Only valid option is "percentile"
type TimesliceMetricPercentileMetricAggregation string

// Timewindowsize The size of the time window (in `timeWindowUnit` units), which determines how far back to search for documents. Generally it should be a value higher than the rule check interval to avoid gaps in detection.
type Timewindowsize = int

// Timewindowunit The type of units for the time window: seconds, minutes, hours, or days.
type Timewindowunit string

// Title Comma-separated list of data streams, indices, and aliases that you want to search. Supports wildcards (`*`).
type Title = string

// Type When set to `rollup`, identifies the rollup data views.
type Type = string

// Typemeta When you use rollup indices, contains the field list for the rollup data view API endpoints.
type Typemeta struct {
	// Aggs A map of rollup restrictions by aggregation type and field name.
	Aggs map[string]interface{} `json:"aggs"`

	// Params Properties for retrieving rollup fields.
	Params map[string]interface{} `json:"params"`
}

// TypemetaResponse When you use rollup indices, contains the field list for the rollup data view API endpoints.
type TypemetaResponse struct {
	// Aggs A map of rollup restrictions by aggregation type and field name.
	Aggs map[string]interface{} `json:"aggs,omitempty"`

	// Params Properties for retrieving rollup fields.
	Params map[string]interface{} `json:"params,omitempty"`
}

// UpdateDataViewRequestObject defines model for update_data_view_request_object.
type UpdateDataViewRequestObject struct {
	// DataView The data view properties you want to update. Only the specified properties are updated in the data view. Unspecified fields stay as they are persisted.
	DataView struct {
		// AllowNoIndex Allows the data view saved object to exist before the data is available.
		AllowNoIndex *Allownoindex `json:"allowNoIndex,omitempty"`

		// FieldFormats A map of field formats by field name.
		FieldFormats    Fieldformats               `json:"fieldFormats,omitempty"`
		Fields          map[string]interface{}     `json:"fields,omitempty"`
		Name            *string                    `json:"name,omitempty"`
		RuntimeFieldMap map[string]Runtimefieldmap `json:"runtimeFieldMap,omitempty"`

		// SourceFilters The array of field names you want to filter out in Discover.
		SourceFilters Sourcefilters `json:"sourceFilters,omitempty"`

		// TimeFieldName The timestamp field name, which you use for time-based data views.
		TimeFieldName *Timefieldname `json:"timeFieldName,omitempty"`

		// Title Comma-separated list of data streams, indices, and aliases that you want to search. Supports wildcards (`*`).
		Title *Title `json:"title,omitempty"`

		// Type When set to `rollup`, identifies the rollup data views.
		Type *Type `json:"type,omitempty"`

		// TypeMeta When you use rollup indices, contains the field list for the rollup data view API endpoints.
		TypeMeta *Typemeta `json:"typeMeta,omitempty"`
	} `json:"data_view"`

	// RefreshFields Reloads the data view fields after the data view is updated.
	RefreshFields *bool `json:"refresh_fields,omitempty"`
}

// UpdateRuleRequest The update rule API request body varies depending on the type of rule and actions.
type UpdateRuleRequest struct {
	Actions Actions `json:"actions"`

	// AlertDelay Indicates that an alert occurs only when the specified number of consecutive runs met the rule conditions.
	AlertDelay *AlertDelay `json:"alert_delay,omitempty"`

	// Name The name of the rule.
	Name string `json:"name"`

	// NotifyWhen Deprecated in 8.13.0. Use the `notify_when` property in the action `frequency` object instead. Indicates how often alerts generate actions. NOTE: You cannot specify `notify_when` at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	NotifyWhen *NotifyWhen `json:"notify_when,omitempty"`

	// Params The parameters for the rule.
	Params map[string]interface{} `json:"params"`

	// Schedule The check interval, which specifies how frequently the rule conditions are checked. The interval is specified in seconds, minutes, hours, or days.
	Schedule Schedule `json:"schedule"`

	// Tags The tags for the rule.
	Tags Tags `json:"tags,omitempty"`

	// Throttle Deprecated in 8.13.0. Use the `throttle` property in the action `frequency` object instead. The throttle interval, which defines how often an alert generates repeated actions. NOTE: You cannot specify the throttle interval at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	Throttle *Throttle `json:"throttle"`
}

// UpdateSloRequest The update SLO API request body varies depending on the type of indicator, time window and budgeting method. Partial update is handled.
type UpdateSloRequest struct {
	// BudgetingMethod The budgeting method to use when computing the rollup data.
	BudgetingMethod *BudgetingMethod `json:"budgetingMethod,omitempty"`

	// Description A description for the SLO.
	Description *string                     `json:"description,omitempty"`
	Indicator   *UpdateSloRequest_Indicator `json:"indicator,omitempty"`

	// Name A name for the SLO.
	Name *string `json:"name,omitempty"`

	// Objective Defines properties for the SLO objective
	Objective *Objective `json:"objective,omitempty"`

	// Settings Defines properties for SLO settings.
	Settings *Settings `json:"settings,omitempty"`

	// Tags List of tags
	Tags []string `json:"tags,omitempty"`

	// TimeWindow Defines properties for the SLO time window
	TimeWindow *TimeWindow `json:"timeWindow,omitempty"`
}

// UpdateSloRequest_Indicator defines model for UpdateSloRequest.Indicator.
type UpdateSloRequest_Indicator struct {
	union json.RawMessage
}

// Format defines model for format.
type Format string

// Kuery defines model for kuery.
type Kuery = string

// PageIndex defines model for page_index.
type PageIndex = int

// PageSize defines model for page_size.
type PageSize = int

// RuleId defines model for rule_id.
type RuleId = string

// SloId defines model for slo_id.
type SloId = string

// SpaceId defines model for space_id.
type SpaceId = string

// ViewId defines model for view_id.
type ViewId = string

// Error defines model for error.
type Error struct {
	Error      *string  `json:"error,omitempty"`
	Message    *string  `json:"message,omitempty"`
	StatusCode *float32 `json:"statusCode,omitempty"`
}

// AgentPolicyListParams defines parameters for AgentPolicyList.
type AgentPolicyListParams struct {
	// PerPage The number of items to return
	PerPage *PageSize  `form:"perPage,omitempty" json:"perPage,omitempty"`
	Page    *PageIndex `form:"page,omitempty" json:"page,omitempty"`
	Kuery   *Kuery     `form:"kuery,omitempty" json:"kuery,omitempty"`

	// Full When set to true, retrieve the related package policies for each agent policy.
	Full *bool `form:"full,omitempty" json:"full,omitempty"`

	// NoAgentCount When set to true, do not count how many agents are in the agent policy, this can improve performance if you are searching over a large number of agent policies. The "agents" property will always be 0 if set to true.
	NoAgentCount *bool `form:"noAgentCount,omitempty" json:"noAgentCount,omitempty"`
}

// DeleteAgentPolicyJSONBody defines parameters for DeleteAgentPolicy.
type DeleteAgentPolicyJSONBody struct {
	AgentPolicyId string `json:"agentPolicyId"`

	// Force bypass validation checks that can prevent agent policy deletion
	Force *bool `json:"force,omitempty"`
}

// FindRulesParams defines parameters for FindRules.
type FindRulesParams struct {
	// DefaultSearchOperator The default operator to use for the simple_query_string.
	DefaultSearchOperator *string `form:"default_search_operator,omitempty" json:"default_search_operator,omitempty"`

	// Fields The fields to return in the `attributes` key of the response.
	Fields []string `form:"fields,omitempty" json:"fields,omitempty"`

	// Filter A KQL string that you filter with an attribute from your saved object. It should look like `savedObjectType.attributes.title: "myTitle"`. However, if you used a direct attribute of a saved object, such as `updatedAt`, you must define your filter, for example, `savedObjectType.updatedAt > 2018-12-22`.
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// HasReference Filters the rules that have a relation with the reference objects with a specific type and identifier.
	HasReference *struct {
		Id   *string `json:"id,omitempty"`
		Type *string `json:"type,omitempty"`
	} `form:"has_reference,omitempty" json:"has_reference,omitempty"`

	// Page The page number to return.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage The number of rules to return per page.
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Search An Elasticsearch simple_query_string query that filters the objects in the response.
	Search *string `form:"search,omitempty" json:"search,omitempty"`

	// SearchFields The fields to perform the simple_query_string parsed query against.
	SearchFields *struct {
		union json.RawMessage
	} `form:"search_fields,omitempty" json:"search_fields,omitempty"`

	// SortField Determines which field is used to sort the results. The field must exist in the `attributes` key of the response.
	SortField *string `form:"sort_field,omitempty" json:"sort_field,omitempty"`

	// SortOrder Determines the sort order.
	SortOrder *FindRulesParamsSortOrder `form:"sort_order,omitempty" json:"sort_order,omitempty"`
}

// FindRulesParamsSearchFields0 defines parameters for FindRules.
type FindRulesParamsSearchFields0 = string

// FindRulesParamsSearchFields1 defines parameters for FindRules.
type FindRulesParamsSearchFields1 = []string

// FindRulesParamsSortOrder defines parameters for FindRules.
type FindRulesParamsSortOrder string

// ImportSavedObjectsDefaultMultipartBody defines parameters for ImportSavedObjectsDefault.
type ImportSavedObjectsDefaultMultipartBody struct {
	// File A file exported using the export API. NOTE: The `savedObjects.maxImportExportSize` configuration setting limits the number of saved objects which may be included in this file. Similarly, the `savedObjects.maxImportPayloadBytes` setting limits the overall size of the file that can be imported.
	File *interface{} `json:"file,omitempty"`
}

// ImportSavedObjectsDefaultParams defines parameters for ImportSavedObjectsDefault.
type ImportSavedObjectsDefaultParams struct {
	// CreateNewCopies Creates copies of saved objects, regenerates each object ID, and resets the origin. When used, potential conflict errors are avoided. NOTE: This option cannot be used with the `overwrite` and `compatibilityMode` options.
	CreateNewCopies *bool `form:"createNewCopies,omitempty" json:"createNewCopies,omitempty"`

	// Overwrite Overwrites saved objects when they already exist. When used, potential conflict errors are automatically resolved by overwriting the destination object. NOTE: This option cannot be used with the `createNewCopies` option.
	Overwrite *bool `form:"overwrite,omitempty" json:"overwrite,omitempty"`

	// CompatibilityMode Applies various adjustments to the saved objects that are being imported to maintain compatibility between different Kibana versions. Use this option only if you encounter issues with imported saved objects. NOTE: This option cannot be used with the `createNewCopies` option.
	CompatibilityMode *bool `form:"compatibilityMode,omitempty" json:"compatibilityMode,omitempty"`
}

// ListAllPackagesParams defines parameters for ListAllPackages.
type ListAllPackagesParams struct {
	// ExcludeInstallStatus Whether to exclude the install status of each package. Enabling this option will opt in to caching for the response via `cache-control` headers. If you don't need up-to-date installation info for a package, and are querying for a list of available packages, providing this flag can improve performance substantially.
	ExcludeInstallStatus *bool `form:"excludeInstallStatus,omitempty" json:"excludeInstallStatus,omitempty"`

	// Prerelease Whether to return prerelease versions of packages (e.g. beta, rc, preview)
	Prerelease   *bool   `form:"prerelease,omitempty" json:"prerelease,omitempty"`
	Experimental *bool   `form:"experimental,omitempty" json:"experimental,omitempty"`
	Category     *string `form:"category,omitempty" json:"category,omitempty"`
}

// InstallPackageByUploadParams defines parameters for InstallPackageByUpload.
type InstallPackageByUploadParams struct {
	// IgnoreMappingUpdateErrors avoid erroring out on unexpected mapping update errors
	IgnoreMappingUpdateErrors *bool `form:"ignoreMappingUpdateErrors,omitempty" json:"ignoreMappingUpdateErrors,omitempty"`

	// SkipDataStreamRollover Skip data stream rollover during index template mapping or settings update
	SkipDataStreamRollover *bool `form:"skipDataStreamRollover,omitempty" json:"skipDataStreamRollover,omitempty"`
}

// DeletePackageJSONBody defines parameters for DeletePackage.
type DeletePackageJSONBody struct {
	Force *bool `json:"force,omitempty"`
}

// DeletePackageParams defines parameters for DeletePackage.
type DeletePackageParams struct {
	// Force delete package even if policies used by agents
	Force *bool `form:"force,omitempty" json:"force,omitempty"`

	// IgnoreUnverified Ignore if the package is fails signature verification
	IgnoreUnverified *bool `form:"ignoreUnverified,omitempty" json:"ignoreUnverified,omitempty"`

	// Full Return all fields from the package manifest, not just those supported by the Elastic Package Registry
	Full *bool `form:"full,omitempty" json:"full,omitempty"`

	// Prerelease Whether to return prerelease versions of packages (e.g. beta, rc, preview)
	Prerelease *bool `form:"prerelease,omitempty" json:"prerelease,omitempty"`
}

// GetPackageParams defines parameters for GetPackage.
type GetPackageParams struct {
	// IgnoreUnverified Ignore if the package is fails signature verification
	IgnoreUnverified *bool `form:"ignoreUnverified,omitempty" json:"ignoreUnverified,omitempty"`

	// Full Return all fields from the package manifest, not just those supported by the Elastic Package Registry
	Full *bool `form:"full,omitempty" json:"full,omitempty"`

	// Prerelease Whether to return prerelease versions of packages (e.g. beta, rc, preview)
	Prerelease *bool `form:"prerelease,omitempty" json:"prerelease,omitempty"`
}

// InstallPackageJSONBody defines parameters for InstallPackage.
type InstallPackageJSONBody struct {
	Force             *bool `json:"force,omitempty"`
	IgnoreConstraints *bool `json:"ignore_constraints,omitempty"`
}

// InstallPackageParams defines parameters for InstallPackage.
type InstallPackageParams struct {
	// IgnoreMappingUpdateErrors avoid erroring out on unexpected mapping update errors
	IgnoreMappingUpdateErrors *bool `form:"ignoreMappingUpdateErrors,omitempty" json:"ignoreMappingUpdateErrors,omitempty"`

	// SkipDataStreamRollover Skip data stream rollover during index template mapping or settings update
	SkipDataStreamRollover *bool `form:"skipDataStreamRollover,omitempty" json:"skipDataStreamRollover,omitempty"`

	// IgnoreUnverified Ignore if the package is fails signature verification
	IgnoreUnverified *bool `form:"ignoreUnverified,omitempty" json:"ignoreUnverified,omitempty"`

	// Full Return all fields from the package manifest, not just those supported by the Elastic Package Registry
	Full *bool `form:"full,omitempty" json:"full,omitempty"`

	// Prerelease Whether to return prerelease versions of packages (e.g. beta, rc, preview)
	Prerelease *bool `form:"prerelease,omitempty" json:"prerelease,omitempty"`
}

// UpdatePackageJSONBody defines parameters for UpdatePackage.
type UpdatePackageJSONBody struct {
	KeepPoliciesUpToDate *bool `json:"keepPoliciesUpToDate,omitempty"`
}

// UpdatePackageParams defines parameters for UpdatePackage.
type UpdatePackageParams struct {
	// IgnoreUnverified Ignore if the package is fails signature verification
	IgnoreUnverified *bool `form:"ignoreUnverified,omitempty" json:"ignoreUnverified,omitempty"`

	// Full Return all fields from the package manifest, not just those supported by the Elastic Package Registry
	Full *bool `form:"full,omitempty" json:"full,omitempty"`

	// Prerelease Whether to return prerelease versions of packages (e.g. beta, rc, preview)
	Prerelease *bool `form:"prerelease,omitempty" json:"prerelease,omitempty"`
}

// PostFleetServerHostsJSONBody defines parameters for PostFleetServerHosts.
type PostFleetServerHostsJSONBody struct {
	HostUrls   []string `json:"host_urls"`
	Id         *string  `json:"id,omitempty"`
	IsDefault  *bool    `json:"is_default,omitempty"`
	IsInternal *bool    `json:"is_internal,omitempty"`
	Name       string   `json:"name"`

	// ProxyId The ID of the proxy to use for this fleet server host. See the proxies API for more information.
	ProxyId *string `json:"proxy_id,omitempty"`
}

// UpdateFleetServerHostsJSONBody defines parameters for UpdateFleetServerHosts.
type UpdateFleetServerHostsJSONBody struct {
	HostUrls   []string `json:"host_urls,omitempty"`
	IsDefault  *bool    `json:"is_default,omitempty"`
	IsInternal *bool    `json:"is_internal,omitempty"`
	Name       *string  `json:"name,omitempty"`

	// ProxyId The ID of the proxy to use for this fleet server host. See the proxies API for more information.
	ProxyId *string `json:"proxy_id"`
}

// GetPackagePoliciesParams defines parameters for GetPackagePolicies.
type GetPackagePoliciesParams struct {
	// PerPage The number of items to return
	PerPage *PageSize  `form:"perPage,omitempty" json:"perPage,omitempty"`
	Page    *PageIndex `form:"page,omitempty" json:"page,omitempty"`
	Kuery   *Kuery     `form:"kuery,omitempty" json:"kuery,omitempty"`

	// Format Simplified or legacy format for package inputs
	Format *GetPackagePoliciesParamsFormat `form:"format,omitempty" json:"format,omitempty"`
}

// GetPackagePoliciesParamsFormat defines parameters for GetPackagePolicies.
type GetPackagePoliciesParamsFormat string

// CreatePackagePolicyParams defines parameters for CreatePackagePolicy.
type CreatePackagePolicyParams struct {
	// Format Simplified or legacy format for package inputs
	Format *CreatePackagePolicyParamsFormat `form:"format,omitempty" json:"format,omitempty"`
}

// CreatePackagePolicyParamsFormat defines parameters for CreatePackagePolicy.
type CreatePackagePolicyParamsFormat string

// DeletePackagePolicyParams defines parameters for DeletePackagePolicy.
type DeletePackagePolicyParams struct {
	Force *bool `form:"force,omitempty" json:"force,omitempty"`
}

// GetPackagePolicyParams defines parameters for GetPackagePolicy.
type GetPackagePolicyParams struct {
	// Format Simplified or legacy format for package inputs
	Format *GetPackagePolicyParamsFormat `form:"format,omitempty" json:"format,omitempty"`
}

// GetPackagePolicyParamsFormat defines parameters for GetPackagePolicy.
type GetPackagePolicyParamsFormat string

// UpdatePackagePolicyParams defines parameters for UpdatePackagePolicy.
type UpdatePackagePolicyParams struct {
	// Format Simplified or legacy format for package inputs
	Format *UpdatePackagePolicyParamsFormat `form:"format,omitempty" json:"format,omitempty"`
}

// UpdatePackagePolicyParamsFormat defines parameters for UpdatePackagePolicy.
type UpdatePackagePolicyParamsFormat string

// FindSlosOpParams defines parameters for FindSlosOp.
type FindSlosOpParams struct {
	// KqlQuery A valid kql query to filter the SLO with
	KqlQuery *string `form:"kqlQuery,omitempty" json:"kqlQuery,omitempty"`

	// Page The page to use for pagination, must be greater or equal than 1
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of SLOs returned by page
	PerPage *int `form:"perPage,omitempty" json:"perPage,omitempty"`

	// SortBy Sort by field
	SortBy *FindSlosOpParamsSortBy `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// SortDirection Sort order
	SortDirection *FindSlosOpParamsSortDirection `form:"sortDirection,omitempty" json:"sortDirection,omitempty"`

	// HideStale Hide stale SLOs from the list as defined by stale SLO threshold in SLO settings
	HideStale *bool `form:"hideStale,omitempty" json:"hideStale,omitempty"`
}

// FindSlosOpParamsSortBy defines parameters for FindSlosOp.
type FindSlosOpParamsSortBy string

// FindSlosOpParamsSortDirection defines parameters for FindSlosOp.
type FindSlosOpParamsSortDirection string

// GetSloOpParams defines parameters for GetSloOp.
type GetSloOpParams struct {
	// InstanceId the specific instanceId used by the summary calculation
	InstanceId *string `form:"instanceId,omitempty" json:"instanceId,omitempty"`
}

// CreateAgentPolicyJSONRequestBody defines body for CreateAgentPolicy for application/json ContentType.
type CreateAgentPolicyJSONRequestBody = AgentPolicyCreateRequest

// DeleteAgentPolicyJSONRequestBody defines body for DeleteAgentPolicy for application/json ContentType.
type DeleteAgentPolicyJSONRequestBody DeleteAgentPolicyJSONBody

// UpdateAgentPolicyJSONRequestBody defines body for UpdateAgentPolicy for application/json ContentType.
type UpdateAgentPolicyJSONRequestBody = AgentPolicyUpdateRequest

// CreateRuleJSONRequestBody defines body for CreateRule for application/json ContentType.
type CreateRuleJSONRequestBody = CreateRuleRequest

// CreateRuleIdJSONRequestBody defines body for CreateRuleId for application/json ContentType.
type CreateRuleIdJSONRequestBody = CreateRuleRequest

// UpdateRuleJSONRequestBody defines body for UpdateRule for application/json ContentType.
type UpdateRuleJSONRequestBody = UpdateRuleRequest

// CreateDataViewDefaultwJSONRequestBody defines body for CreateDataViewDefaultw for application/json ContentType.
type CreateDataViewDefaultwJSONRequestBody = CreateDataViewRequestObject

// UpdateDataViewDefaultJSONRequestBody defines body for UpdateDataViewDefault for application/json ContentType.
type UpdateDataViewDefaultJSONRequestBody = UpdateDataViewRequestObject

// ImportSavedObjectsDefaultMultipartRequestBody defines body for ImportSavedObjectsDefault for multipart/form-data ContentType.
type ImportSavedObjectsDefaultMultipartRequestBody ImportSavedObjectsDefaultMultipartBody

// DeletePackageJSONRequestBody defines body for DeletePackage for application/json ContentType.
type DeletePackageJSONRequestBody DeletePackageJSONBody

// InstallPackageJSONRequestBody defines body for InstallPackage for application/json ContentType.
type InstallPackageJSONRequestBody InstallPackageJSONBody

// UpdatePackageJSONRequestBody defines body for UpdatePackage for application/json ContentType.
type UpdatePackageJSONRequestBody UpdatePackageJSONBody

// PostFleetServerHostsJSONRequestBody defines body for PostFleetServerHosts for application/json ContentType.
type PostFleetServerHostsJSONRequestBody PostFleetServerHostsJSONBody

// UpdateFleetServerHostsJSONRequestBody defines body for UpdateFleetServerHosts for application/json ContentType.
type UpdateFleetServerHostsJSONRequestBody UpdateFleetServerHostsJSONBody

// PostOutputsJSONRequestBody defines body for PostOutputs for application/json ContentType.
type PostOutputsJSONRequestBody = OutputCreateRequest

// UpdateOutputJSONRequestBody defines body for UpdateOutput for application/json ContentType.
type UpdateOutputJSONRequestBody = OutputUpdateRequest

// CreatePackagePolicyJSONRequestBody defines body for CreatePackagePolicy for application/json ContentType.
type CreatePackagePolicyJSONRequestBody = PackagePolicyRequest

// UpdatePackagePolicyJSONRequestBody defines body for UpdatePackagePolicy for application/json ContentType.
type UpdatePackagePolicyJSONRequestBody = PackagePolicyRequest

// CreateSloOpJSONRequestBody defines body for CreateSloOp for application/json ContentType.
type CreateSloOpJSONRequestBody = CreateSloRequest

// UpdateSloOpJSONRequestBody defines body for UpdateSloOp for application/json ContentType.
type UpdateSloOpJSONRequestBody = UpdateSloRequest

// AsAgentPolicyGlobalDataTags0 returns the union data inside the AgentPolicy_GlobalDataTags_AdditionalProperties as a AgentPolicyGlobalDataTags0
func (t AgentPolicy_GlobalDataTags_AdditionalProperties) AsAgentPolicyGlobalDataTags0() (AgentPolicyGlobalDataTags0, error) {
	var body AgentPolicyGlobalDataTags0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAgentPolicyGlobalDataTags0 overwrites any union data inside the AgentPolicy_GlobalDataTags_AdditionalProperties as the provided AgentPolicyGlobalDataTags0
func (t *AgentPolicy_GlobalDataTags_AdditionalProperties) FromAgentPolicyGlobalDataTags0(v AgentPolicyGlobalDataTags0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAgentPolicyGlobalDataTags0 performs a merge with any union data inside the AgentPolicy_GlobalDataTags_AdditionalProperties, using the provided AgentPolicyGlobalDataTags0
func (t *AgentPolicy_GlobalDataTags_AdditionalProperties) MergeAgentPolicyGlobalDataTags0(v AgentPolicyGlobalDataTags0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAgentPolicyGlobalDataTags1 returns the union data inside the AgentPolicy_GlobalDataTags_AdditionalProperties as a AgentPolicyGlobalDataTags1
func (t AgentPolicy_GlobalDataTags_AdditionalProperties) AsAgentPolicyGlobalDataTags1() (AgentPolicyGlobalDataTags1, error) {
	var body AgentPolicyGlobalDataTags1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAgentPolicyGlobalDataTags1 overwrites any union data inside the AgentPolicy_GlobalDataTags_AdditionalProperties as the provided AgentPolicyGlobalDataTags1
func (t *AgentPolicy_GlobalDataTags_AdditionalProperties) FromAgentPolicyGlobalDataTags1(v AgentPolicyGlobalDataTags1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAgentPolicyGlobalDataTags1 performs a merge with any union data inside the AgentPolicy_GlobalDataTags_AdditionalProperties, using the provided AgentPolicyGlobalDataTags1
func (t *AgentPolicy_GlobalDataTags_AdditionalProperties) MergeAgentPolicyGlobalDataTags1(v AgentPolicyGlobalDataTags1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t AgentPolicy_GlobalDataTags_AdditionalProperties) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AgentPolicy_GlobalDataTags_AdditionalProperties) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAgentPolicyCreateRequestGlobalDataTags0 returns the union data inside the AgentPolicyCreateRequest_GlobalDataTags_AdditionalProperties as a AgentPolicyCreateRequestGlobalDataTags0
func (t AgentPolicyCreateRequest_GlobalDataTags_AdditionalProperties) AsAgentPolicyCreateRequestGlobalDataTags0() (AgentPolicyCreateRequestGlobalDataTags0, error) {
	var body AgentPolicyCreateRequestGlobalDataTags0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAgentPolicyCreateRequestGlobalDataTags0 overwrites any union data inside the AgentPolicyCreateRequest_GlobalDataTags_AdditionalProperties as the provided AgentPolicyCreateRequestGlobalDataTags0
func (t *AgentPolicyCreateRequest_GlobalDataTags_AdditionalProperties) FromAgentPolicyCreateRequestGlobalDataTags0(v AgentPolicyCreateRequestGlobalDataTags0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAgentPolicyCreateRequestGlobalDataTags0 performs a merge with any union data inside the AgentPolicyCreateRequest_GlobalDataTags_AdditionalProperties, using the provided AgentPolicyCreateRequestGlobalDataTags0
func (t *AgentPolicyCreateRequest_GlobalDataTags_AdditionalProperties) MergeAgentPolicyCreateRequestGlobalDataTags0(v AgentPolicyCreateRequestGlobalDataTags0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAgentPolicyCreateRequestGlobalDataTags1 returns the union data inside the AgentPolicyCreateRequest_GlobalDataTags_AdditionalProperties as a AgentPolicyCreateRequestGlobalDataTags1
func (t AgentPolicyCreateRequest_GlobalDataTags_AdditionalProperties) AsAgentPolicyCreateRequestGlobalDataTags1() (AgentPolicyCreateRequestGlobalDataTags1, error) {
	var body AgentPolicyCreateRequestGlobalDataTags1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAgentPolicyCreateRequestGlobalDataTags1 overwrites any union data inside the AgentPolicyCreateRequest_GlobalDataTags_AdditionalProperties as the provided AgentPolicyCreateRequestGlobalDataTags1
func (t *AgentPolicyCreateRequest_GlobalDataTags_AdditionalProperties) FromAgentPolicyCreateRequestGlobalDataTags1(v AgentPolicyCreateRequestGlobalDataTags1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAgentPolicyCreateRequestGlobalDataTags1 performs a merge with any union data inside the AgentPolicyCreateRequest_GlobalDataTags_AdditionalProperties, using the provided AgentPolicyCreateRequestGlobalDataTags1
func (t *AgentPolicyCreateRequest_GlobalDataTags_AdditionalProperties) MergeAgentPolicyCreateRequestGlobalDataTags1(v AgentPolicyCreateRequestGlobalDataTags1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t AgentPolicyCreateRequest_GlobalDataTags_AdditionalProperties) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AgentPolicyCreateRequest_GlobalDataTags_AdditionalProperties) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCreateAnomalyDetectionAlertRuleRequest returns the union data inside the CreateRuleRequest as a CreateAnomalyDetectionAlertRuleRequest
func (t CreateRuleRequest) AsCreateAnomalyDetectionAlertRuleRequest() (CreateAnomalyDetectionAlertRuleRequest, error) {
	var body CreateAnomalyDetectionAlertRuleRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateAnomalyDetectionAlertRuleRequest overwrites any union data inside the CreateRuleRequest as the provided CreateAnomalyDetectionAlertRuleRequest
func (t *CreateRuleRequest) FromCreateAnomalyDetectionAlertRuleRequest(v CreateAnomalyDetectionAlertRuleRequest) error {
	v.RuleTypeId = "xpack.ml.anomaly_detection_alert"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateAnomalyDetectionAlertRuleRequest performs a merge with any union data inside the CreateRuleRequest, using the provided CreateAnomalyDetectionAlertRuleRequest
func (t *CreateRuleRequest) MergeCreateAnomalyDetectionAlertRuleRequest(v CreateAnomalyDetectionAlertRuleRequest) error {
	v.RuleTypeId = "xpack.ml.anomaly_detection_alert"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateAnomalyDetectionJobsHealthRuleRequest returns the union data inside the CreateRuleRequest as a CreateAnomalyDetectionJobsHealthRuleRequest
func (t CreateRuleRequest) AsCreateAnomalyDetectionJobsHealthRuleRequest() (CreateAnomalyDetectionJobsHealthRuleRequest, error) {
	var body CreateAnomalyDetectionJobsHealthRuleRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateAnomalyDetectionJobsHealthRuleRequest overwrites any union data inside the CreateRuleRequest as the provided CreateAnomalyDetectionJobsHealthRuleRequest
func (t *CreateRuleRequest) FromCreateAnomalyDetectionJobsHealthRuleRequest(v CreateAnomalyDetectionJobsHealthRuleRequest) error {
	v.RuleTypeId = "xpack.ml.anomaly_detection_jobs_health"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateAnomalyDetectionJobsHealthRuleRequest performs a merge with any union data inside the CreateRuleRequest, using the provided CreateAnomalyDetectionJobsHealthRuleRequest
func (t *CreateRuleRequest) MergeCreateAnomalyDetectionJobsHealthRuleRequest(v CreateAnomalyDetectionJobsHealthRuleRequest) error {
	v.RuleTypeId = "xpack.ml.anomaly_detection_jobs_health"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateApmAnomalyRuleRequest returns the union data inside the CreateRuleRequest as a CreateApmAnomalyRuleRequest
func (t CreateRuleRequest) AsCreateApmAnomalyRuleRequest() (CreateApmAnomalyRuleRequest, error) {
	var body CreateApmAnomalyRuleRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateApmAnomalyRuleRequest overwrites any union data inside the CreateRuleRequest as the provided CreateApmAnomalyRuleRequest
func (t *CreateRuleRequest) FromCreateApmAnomalyRuleRequest(v CreateApmAnomalyRuleRequest) error {
	v.RuleTypeId = "apm.anomaly"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateApmAnomalyRuleRequest performs a merge with any union data inside the CreateRuleRequest, using the provided CreateApmAnomalyRuleRequest
func (t *CreateRuleRequest) MergeCreateApmAnomalyRuleRequest(v CreateApmAnomalyRuleRequest) error {
	v.RuleTypeId = "apm.anomaly"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateApmErrorCountRuleRequest returns the union data inside the CreateRuleRequest as a CreateApmErrorCountRuleRequest
func (t CreateRuleRequest) AsCreateApmErrorCountRuleRequest() (CreateApmErrorCountRuleRequest, error) {
	var body CreateApmErrorCountRuleRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateApmErrorCountRuleRequest overwrites any union data inside the CreateRuleRequest as the provided CreateApmErrorCountRuleRequest
func (t *CreateRuleRequest) FromCreateApmErrorCountRuleRequest(v CreateApmErrorCountRuleRequest) error {
	v.RuleTypeId = "apm.error_rate"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateApmErrorCountRuleRequest performs a merge with any union data inside the CreateRuleRequest, using the provided CreateApmErrorCountRuleRequest
func (t *CreateRuleRequest) MergeCreateApmErrorCountRuleRequest(v CreateApmErrorCountRuleRequest) error {
	v.RuleTypeId = "apm.error_rate"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateApmTransactionDurationRuleRequest returns the union data inside the CreateRuleRequest as a CreateApmTransactionDurationRuleRequest
func (t CreateRuleRequest) AsCreateApmTransactionDurationRuleRequest() (CreateApmTransactionDurationRuleRequest, error) {
	var body CreateApmTransactionDurationRuleRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateApmTransactionDurationRuleRequest overwrites any union data inside the CreateRuleRequest as the provided CreateApmTransactionDurationRuleRequest
func (t *CreateRuleRequest) FromCreateApmTransactionDurationRuleRequest(v CreateApmTransactionDurationRuleRequest) error {
	v.RuleTypeId = "apm.transaction_duration"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateApmTransactionDurationRuleRequest performs a merge with any union data inside the CreateRuleRequest, using the provided CreateApmTransactionDurationRuleRequest
func (t *CreateRuleRequest) MergeCreateApmTransactionDurationRuleRequest(v CreateApmTransactionDurationRuleRequest) error {
	v.RuleTypeId = "apm.transaction_duration"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateApmTransactionErrorRateRuleRequest returns the union data inside the CreateRuleRequest as a CreateApmTransactionErrorRateRuleRequest
func (t CreateRuleRequest) AsCreateApmTransactionErrorRateRuleRequest() (CreateApmTransactionErrorRateRuleRequest, error) {
	var body CreateApmTransactionErrorRateRuleRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateApmTransactionErrorRateRuleRequest overwrites any union data inside the CreateRuleRequest as the provided CreateApmTransactionErrorRateRuleRequest
func (t *CreateRuleRequest) FromCreateApmTransactionErrorRateRuleRequest(v CreateApmTransactionErrorRateRuleRequest) error {
	v.RuleTypeId = "apm.transaction_error_rate"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateApmTransactionErrorRateRuleRequest performs a merge with any union data inside the CreateRuleRequest, using the provided CreateApmTransactionErrorRateRuleRequest
func (t *CreateRuleRequest) MergeCreateApmTransactionErrorRateRuleRequest(v CreateApmTransactionErrorRateRuleRequest) error {
	v.RuleTypeId = "apm.transaction_error_rate"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateEsQueryRuleRequest returns the union data inside the CreateRuleRequest as a CreateEsQueryRuleRequest
func (t CreateRuleRequest) AsCreateEsQueryRuleRequest() (CreateEsQueryRuleRequest, error) {
	var body CreateEsQueryRuleRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateEsQueryRuleRequest overwrites any union data inside the CreateRuleRequest as the provided CreateEsQueryRuleRequest
func (t *CreateRuleRequest) FromCreateEsQueryRuleRequest(v CreateEsQueryRuleRequest) error {
	v.RuleTypeId = ".es-query"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateEsQueryRuleRequest performs a merge with any union data inside the CreateRuleRequest, using the provided CreateEsQueryRuleRequest
func (t *CreateRuleRequest) MergeCreateEsQueryRuleRequest(v CreateEsQueryRuleRequest) error {
	v.RuleTypeId = ".es-query"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateGeoContainmentRuleRequest returns the union data inside the CreateRuleRequest as a CreateGeoContainmentRuleRequest
func (t CreateRuleRequest) AsCreateGeoContainmentRuleRequest() (CreateGeoContainmentRuleRequest, error) {
	var body CreateGeoContainmentRuleRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateGeoContainmentRuleRequest overwrites any union data inside the CreateRuleRequest as the provided CreateGeoContainmentRuleRequest
func (t *CreateRuleRequest) FromCreateGeoContainmentRuleRequest(v CreateGeoContainmentRuleRequest) error {
	v.RuleTypeId = ".geo-containment"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateGeoContainmentRuleRequest performs a merge with any union data inside the CreateRuleRequest, using the provided CreateGeoContainmentRuleRequest
func (t *CreateRuleRequest) MergeCreateGeoContainmentRuleRequest(v CreateGeoContainmentRuleRequest) error {
	v.RuleTypeId = ".geo-containment"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateIndexThresholdRuleRequest returns the union data inside the CreateRuleRequest as a CreateIndexThresholdRuleRequest
func (t CreateRuleRequest) AsCreateIndexThresholdRuleRequest() (CreateIndexThresholdRuleRequest, error) {
	var body CreateIndexThresholdRuleRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateIndexThresholdRuleRequest overwrites any union data inside the CreateRuleRequest as the provided CreateIndexThresholdRuleRequest
func (t *CreateRuleRequest) FromCreateIndexThresholdRuleRequest(v CreateIndexThresholdRuleRequest) error {
	v.RuleTypeId = ".index-threshold"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateIndexThresholdRuleRequest performs a merge with any union data inside the CreateRuleRequest, using the provided CreateIndexThresholdRuleRequest
func (t *CreateRuleRequest) MergeCreateIndexThresholdRuleRequest(v CreateIndexThresholdRuleRequest) error {
	v.RuleTypeId = ".index-threshold"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateInfraInventoryRuleRequest returns the union data inside the CreateRuleRequest as a CreateInfraInventoryRuleRequest
func (t CreateRuleRequest) AsCreateInfraInventoryRuleRequest() (CreateInfraInventoryRuleRequest, error) {
	var body CreateInfraInventoryRuleRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateInfraInventoryRuleRequest overwrites any union data inside the CreateRuleRequest as the provided CreateInfraInventoryRuleRequest
func (t *CreateRuleRequest) FromCreateInfraInventoryRuleRequest(v CreateInfraInventoryRuleRequest) error {
	v.RuleTypeId = "metrics.alert.inventory.threshold"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateInfraInventoryRuleRequest performs a merge with any union data inside the CreateRuleRequest, using the provided CreateInfraInventoryRuleRequest
func (t *CreateRuleRequest) MergeCreateInfraInventoryRuleRequest(v CreateInfraInventoryRuleRequest) error {
	v.RuleTypeId = "metrics.alert.inventory.threshold"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateInfraMetricAnomalyRuleRequest returns the union data inside the CreateRuleRequest as a CreateInfraMetricAnomalyRuleRequest
func (t CreateRuleRequest) AsCreateInfraMetricAnomalyRuleRequest() (CreateInfraMetricAnomalyRuleRequest, error) {
	var body CreateInfraMetricAnomalyRuleRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateInfraMetricAnomalyRuleRequest overwrites any union data inside the CreateRuleRequest as the provided CreateInfraMetricAnomalyRuleRequest
func (t *CreateRuleRequest) FromCreateInfraMetricAnomalyRuleRequest(v CreateInfraMetricAnomalyRuleRequest) error {
	v.RuleTypeId = "metrics.alert.anomaly"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateInfraMetricAnomalyRuleRequest performs a merge with any union data inside the CreateRuleRequest, using the provided CreateInfraMetricAnomalyRuleRequest
func (t *CreateRuleRequest) MergeCreateInfraMetricAnomalyRuleRequest(v CreateInfraMetricAnomalyRuleRequest) error {
	v.RuleTypeId = "metrics.alert.anomaly"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateInfraMetricThresholdRuleRequest returns the union data inside the CreateRuleRequest as a CreateInfraMetricThresholdRuleRequest
func (t CreateRuleRequest) AsCreateInfraMetricThresholdRuleRequest() (CreateInfraMetricThresholdRuleRequest, error) {
	var body CreateInfraMetricThresholdRuleRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateInfraMetricThresholdRuleRequest overwrites any union data inside the CreateRuleRequest as the provided CreateInfraMetricThresholdRuleRequest
func (t *CreateRuleRequest) FromCreateInfraMetricThresholdRuleRequest(v CreateInfraMetricThresholdRuleRequest) error {
	v.RuleTypeId = "metrics.alert.threshold"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateInfraMetricThresholdRuleRequest performs a merge with any union data inside the CreateRuleRequest, using the provided CreateInfraMetricThresholdRuleRequest
func (t *CreateRuleRequest) MergeCreateInfraMetricThresholdRuleRequest(v CreateInfraMetricThresholdRuleRequest) error {
	v.RuleTypeId = "metrics.alert.threshold"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateMonitoringJvmMemoryUsageRuleRequest returns the union data inside the CreateRuleRequest as a CreateMonitoringJvmMemoryUsageRuleRequest
func (t CreateRuleRequest) AsCreateMonitoringJvmMemoryUsageRuleRequest() (CreateMonitoringJvmMemoryUsageRuleRequest, error) {
	var body CreateMonitoringJvmMemoryUsageRuleRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateMonitoringJvmMemoryUsageRuleRequest overwrites any union data inside the CreateRuleRequest as the provided CreateMonitoringJvmMemoryUsageRuleRequest
func (t *CreateRuleRequest) FromCreateMonitoringJvmMemoryUsageRuleRequest(v CreateMonitoringJvmMemoryUsageRuleRequest) error {
	v.RuleTypeId = "monitoring_alert_jvm_memory_usage"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateMonitoringJvmMemoryUsageRuleRequest performs a merge with any union data inside the CreateRuleRequest, using the provided CreateMonitoringJvmMemoryUsageRuleRequest
func (t *CreateRuleRequest) MergeCreateMonitoringJvmMemoryUsageRuleRequest(v CreateMonitoringJvmMemoryUsageRuleRequest) error {
	v.RuleTypeId = "monitoring_alert_jvm_memory_usage"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateLogThresholdRuleRequest returns the union data inside the CreateRuleRequest as a CreateLogThresholdRuleRequest
func (t CreateRuleRequest) AsCreateLogThresholdRuleRequest() (CreateLogThresholdRuleRequest, error) {
	var body CreateLogThresholdRuleRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateLogThresholdRuleRequest overwrites any union data inside the CreateRuleRequest as the provided CreateLogThresholdRuleRequest
func (t *CreateRuleRequest) FromCreateLogThresholdRuleRequest(v CreateLogThresholdRuleRequest) error {
	v.RuleTypeId = "logs.alert.document.count"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateLogThresholdRuleRequest performs a merge with any union data inside the CreateRuleRequest, using the provided CreateLogThresholdRuleRequest
func (t *CreateRuleRequest) MergeCreateLogThresholdRuleRequest(v CreateLogThresholdRuleRequest) error {
	v.RuleTypeId = "logs.alert.document.count"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateMonitoringCcrExceptionsRuleRequest returns the union data inside the CreateRuleRequest as a CreateMonitoringCcrExceptionsRuleRequest
func (t CreateRuleRequest) AsCreateMonitoringCcrExceptionsRuleRequest() (CreateMonitoringCcrExceptionsRuleRequest, error) {
	var body CreateMonitoringCcrExceptionsRuleRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateMonitoringCcrExceptionsRuleRequest overwrites any union data inside the CreateRuleRequest as the provided CreateMonitoringCcrExceptionsRuleRequest
func (t *CreateRuleRequest) FromCreateMonitoringCcrExceptionsRuleRequest(v CreateMonitoringCcrExceptionsRuleRequest) error {
	v.RuleTypeId = "monitoring_ccr_read_exceptions"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateMonitoringCcrExceptionsRuleRequest performs a merge with any union data inside the CreateRuleRequest, using the provided CreateMonitoringCcrExceptionsRuleRequest
func (t *CreateRuleRequest) MergeCreateMonitoringCcrExceptionsRuleRequest(v CreateMonitoringCcrExceptionsRuleRequest) error {
	v.RuleTypeId = "monitoring_ccr_read_exceptions"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateMonitoringClusterHealthRuleRequest returns the union data inside the CreateRuleRequest as a CreateMonitoringClusterHealthRuleRequest
func (t CreateRuleRequest) AsCreateMonitoringClusterHealthRuleRequest() (CreateMonitoringClusterHealthRuleRequest, error) {
	var body CreateMonitoringClusterHealthRuleRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateMonitoringClusterHealthRuleRequest overwrites any union data inside the CreateRuleRequest as the provided CreateMonitoringClusterHealthRuleRequest
func (t *CreateRuleRequest) FromCreateMonitoringClusterHealthRuleRequest(v CreateMonitoringClusterHealthRuleRequest) error {
	v.RuleTypeId = "monitoring_alert_cluster_health"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateMonitoringClusterHealthRuleRequest performs a merge with any union data inside the CreateRuleRequest, using the provided CreateMonitoringClusterHealthRuleRequest
func (t *CreateRuleRequest) MergeCreateMonitoringClusterHealthRuleRequest(v CreateMonitoringClusterHealthRuleRequest) error {
	v.RuleTypeId = "monitoring_alert_cluster_health"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateMonitoringCpuUsageRuleRequest returns the union data inside the CreateRuleRequest as a CreateMonitoringCpuUsageRuleRequest
func (t CreateRuleRequest) AsCreateMonitoringCpuUsageRuleRequest() (CreateMonitoringCpuUsageRuleRequest, error) {
	var body CreateMonitoringCpuUsageRuleRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateMonitoringCpuUsageRuleRequest overwrites any union data inside the CreateRuleRequest as the provided CreateMonitoringCpuUsageRuleRequest
func (t *CreateRuleRequest) FromCreateMonitoringCpuUsageRuleRequest(v CreateMonitoringCpuUsageRuleRequest) error {
	v.RuleTypeId = "monitoring_alert_cpu_usage"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateMonitoringCpuUsageRuleRequest performs a merge with any union data inside the CreateRuleRequest, using the provided CreateMonitoringCpuUsageRuleRequest
func (t *CreateRuleRequest) MergeCreateMonitoringCpuUsageRuleRequest(v CreateMonitoringCpuUsageRuleRequest) error {
	v.RuleTypeId = "monitoring_alert_cpu_usage"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateMonitoringDiskUsageRuleRequest returns the union data inside the CreateRuleRequest as a CreateMonitoringDiskUsageRuleRequest
func (t CreateRuleRequest) AsCreateMonitoringDiskUsageRuleRequest() (CreateMonitoringDiskUsageRuleRequest, error) {
	var body CreateMonitoringDiskUsageRuleRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateMonitoringDiskUsageRuleRequest overwrites any union data inside the CreateRuleRequest as the provided CreateMonitoringDiskUsageRuleRequest
func (t *CreateRuleRequest) FromCreateMonitoringDiskUsageRuleRequest(v CreateMonitoringDiskUsageRuleRequest) error {
	v.RuleTypeId = "monitoring_alert_disk_usage"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateMonitoringDiskUsageRuleRequest performs a merge with any union data inside the CreateRuleRequest, using the provided CreateMonitoringDiskUsageRuleRequest
func (t *CreateRuleRequest) MergeCreateMonitoringDiskUsageRuleRequest(v CreateMonitoringDiskUsageRuleRequest) error {
	v.RuleTypeId = "monitoring_alert_disk_usage"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateMonitoringElasticsearchVersionMismatchRuleRequest returns the union data inside the CreateRuleRequest as a CreateMonitoringElasticsearchVersionMismatchRuleRequest
func (t CreateRuleRequest) AsCreateMonitoringElasticsearchVersionMismatchRuleRequest() (CreateMonitoringElasticsearchVersionMismatchRuleRequest, error) {
	var body CreateMonitoringElasticsearchVersionMismatchRuleRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateMonitoringElasticsearchVersionMismatchRuleRequest overwrites any union data inside the CreateRuleRequest as the provided CreateMonitoringElasticsearchVersionMismatchRuleRequest
func (t *CreateRuleRequest) FromCreateMonitoringElasticsearchVersionMismatchRuleRequest(v CreateMonitoringElasticsearchVersionMismatchRuleRequest) error {
	v.RuleTypeId = "monitoring_alert_elasticsearch_version_mismatch"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateMonitoringElasticsearchVersionMismatchRuleRequest performs a merge with any union data inside the CreateRuleRequest, using the provided CreateMonitoringElasticsearchVersionMismatchRuleRequest
func (t *CreateRuleRequest) MergeCreateMonitoringElasticsearchVersionMismatchRuleRequest(v CreateMonitoringElasticsearchVersionMismatchRuleRequest) error {
	v.RuleTypeId = "monitoring_alert_elasticsearch_version_mismatch"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateMonitoringLicenseExpirationRuleRequest returns the union data inside the CreateRuleRequest as a CreateMonitoringLicenseExpirationRuleRequest
func (t CreateRuleRequest) AsCreateMonitoringLicenseExpirationRuleRequest() (CreateMonitoringLicenseExpirationRuleRequest, error) {
	var body CreateMonitoringLicenseExpirationRuleRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateMonitoringLicenseExpirationRuleRequest overwrites any union data inside the CreateRuleRequest as the provided CreateMonitoringLicenseExpirationRuleRequest
func (t *CreateRuleRequest) FromCreateMonitoringLicenseExpirationRuleRequest(v CreateMonitoringLicenseExpirationRuleRequest) error {
	v.RuleTypeId = "monitoring_alert_license_expiration"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateMonitoringLicenseExpirationRuleRequest performs a merge with any union data inside the CreateRuleRequest, using the provided CreateMonitoringLicenseExpirationRuleRequest
func (t *CreateRuleRequest) MergeCreateMonitoringLicenseExpirationRuleRequest(v CreateMonitoringLicenseExpirationRuleRequest) error {
	v.RuleTypeId = "monitoring_alert_license_expiration"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateMonitoringKibanaVersionMismatchRuleRequest returns the union data inside the CreateRuleRequest as a CreateMonitoringKibanaVersionMismatchRuleRequest
func (t CreateRuleRequest) AsCreateMonitoringKibanaVersionMismatchRuleRequest() (CreateMonitoringKibanaVersionMismatchRuleRequest, error) {
	var body CreateMonitoringKibanaVersionMismatchRuleRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateMonitoringKibanaVersionMismatchRuleRequest overwrites any union data inside the CreateRuleRequest as the provided CreateMonitoringKibanaVersionMismatchRuleRequest
func (t *CreateRuleRequest) FromCreateMonitoringKibanaVersionMismatchRuleRequest(v CreateMonitoringKibanaVersionMismatchRuleRequest) error {
	v.RuleTypeId = "monitoring_alert_kibana_version_mismatch"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateMonitoringKibanaVersionMismatchRuleRequest performs a merge with any union data inside the CreateRuleRequest, using the provided CreateMonitoringKibanaVersionMismatchRuleRequest
func (t *CreateRuleRequest) MergeCreateMonitoringKibanaVersionMismatchRuleRequest(v CreateMonitoringKibanaVersionMismatchRuleRequest) error {
	v.RuleTypeId = "monitoring_alert_kibana_version_mismatch"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateMonitoringLogstashVersionMismatchRuleRequest returns the union data inside the CreateRuleRequest as a CreateMonitoringLogstashVersionMismatchRuleRequest
func (t CreateRuleRequest) AsCreateMonitoringLogstashVersionMismatchRuleRequest() (CreateMonitoringLogstashVersionMismatchRuleRequest, error) {
	var body CreateMonitoringLogstashVersionMismatchRuleRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateMonitoringLogstashVersionMismatchRuleRequest overwrites any union data inside the CreateRuleRequest as the provided CreateMonitoringLogstashVersionMismatchRuleRequest
func (t *CreateRuleRequest) FromCreateMonitoringLogstashVersionMismatchRuleRequest(v CreateMonitoringLogstashVersionMismatchRuleRequest) error {
	v.RuleTypeId = "monitoring_alert_logstash_version_mismatch"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateMonitoringLogstashVersionMismatchRuleRequest performs a merge with any union data inside the CreateRuleRequest, using the provided CreateMonitoringLogstashVersionMismatchRuleRequest
func (t *CreateRuleRequest) MergeCreateMonitoringLogstashVersionMismatchRuleRequest(v CreateMonitoringLogstashVersionMismatchRuleRequest) error {
	v.RuleTypeId = "monitoring_alert_logstash_version_mismatch"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateMonitoringMissingDataRuleRequest returns the union data inside the CreateRuleRequest as a CreateMonitoringMissingDataRuleRequest
func (t CreateRuleRequest) AsCreateMonitoringMissingDataRuleRequest() (CreateMonitoringMissingDataRuleRequest, error) {
	var body CreateMonitoringMissingDataRuleRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateMonitoringMissingDataRuleRequest overwrites any union data inside the CreateRuleRequest as the provided CreateMonitoringMissingDataRuleRequest
func (t *CreateRuleRequest) FromCreateMonitoringMissingDataRuleRequest(v CreateMonitoringMissingDataRuleRequest) error {
	v.RuleTypeId = "monitoring_alert_missing_monitoring_data"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateMonitoringMissingDataRuleRequest performs a merge with any union data inside the CreateRuleRequest, using the provided CreateMonitoringMissingDataRuleRequest
func (t *CreateRuleRequest) MergeCreateMonitoringMissingDataRuleRequest(v CreateMonitoringMissingDataRuleRequest) error {
	v.RuleTypeId = "monitoring_alert_missing_monitoring_data"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateMonitoringNodesChangedRuleRequest returns the union data inside the CreateRuleRequest as a CreateMonitoringNodesChangedRuleRequest
func (t CreateRuleRequest) AsCreateMonitoringNodesChangedRuleRequest() (CreateMonitoringNodesChangedRuleRequest, error) {
	var body CreateMonitoringNodesChangedRuleRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateMonitoringNodesChangedRuleRequest overwrites any union data inside the CreateRuleRequest as the provided CreateMonitoringNodesChangedRuleRequest
func (t *CreateRuleRequest) FromCreateMonitoringNodesChangedRuleRequest(v CreateMonitoringNodesChangedRuleRequest) error {
	v.RuleTypeId = "monitoring_alert_nodes_changed"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateMonitoringNodesChangedRuleRequest performs a merge with any union data inside the CreateRuleRequest, using the provided CreateMonitoringNodesChangedRuleRequest
func (t *CreateRuleRequest) MergeCreateMonitoringNodesChangedRuleRequest(v CreateMonitoringNodesChangedRuleRequest) error {
	v.RuleTypeId = "monitoring_alert_nodes_changed"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateMonitoringShardSizeRuleRequest returns the union data inside the CreateRuleRequest as a CreateMonitoringShardSizeRuleRequest
func (t CreateRuleRequest) AsCreateMonitoringShardSizeRuleRequest() (CreateMonitoringShardSizeRuleRequest, error) {
	var body CreateMonitoringShardSizeRuleRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateMonitoringShardSizeRuleRequest overwrites any union data inside the CreateRuleRequest as the provided CreateMonitoringShardSizeRuleRequest
func (t *CreateRuleRequest) FromCreateMonitoringShardSizeRuleRequest(v CreateMonitoringShardSizeRuleRequest) error {
	v.RuleTypeId = "monitoring_shard_size"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateMonitoringShardSizeRuleRequest performs a merge with any union data inside the CreateRuleRequest, using the provided CreateMonitoringShardSizeRuleRequest
func (t *CreateRuleRequest) MergeCreateMonitoringShardSizeRuleRequest(v CreateMonitoringShardSizeRuleRequest) error {
	v.RuleTypeId = "monitoring_shard_size"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateMonitoringThreadPoolSearchRejectionsRuleRequest returns the union data inside the CreateRuleRequest as a CreateMonitoringThreadPoolSearchRejectionsRuleRequest
func (t CreateRuleRequest) AsCreateMonitoringThreadPoolSearchRejectionsRuleRequest() (CreateMonitoringThreadPoolSearchRejectionsRuleRequest, error) {
	var body CreateMonitoringThreadPoolSearchRejectionsRuleRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateMonitoringThreadPoolSearchRejectionsRuleRequest overwrites any union data inside the CreateRuleRequest as the provided CreateMonitoringThreadPoolSearchRejectionsRuleRequest
func (t *CreateRuleRequest) FromCreateMonitoringThreadPoolSearchRejectionsRuleRequest(v CreateMonitoringThreadPoolSearchRejectionsRuleRequest) error {
	v.RuleTypeId = "monitoring_alert_thread_pool_search_rejections"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateMonitoringThreadPoolSearchRejectionsRuleRequest performs a merge with any union data inside the CreateRuleRequest, using the provided CreateMonitoringThreadPoolSearchRejectionsRuleRequest
func (t *CreateRuleRequest) MergeCreateMonitoringThreadPoolSearchRejectionsRuleRequest(v CreateMonitoringThreadPoolSearchRejectionsRuleRequest) error {
	v.RuleTypeId = "monitoring_alert_thread_pool_search_rejections"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateMonitoringThreadPoolWriteRejectionsRuleRequest returns the union data inside the CreateRuleRequest as a CreateMonitoringThreadPoolWriteRejectionsRuleRequest
func (t CreateRuleRequest) AsCreateMonitoringThreadPoolWriteRejectionsRuleRequest() (CreateMonitoringThreadPoolWriteRejectionsRuleRequest, error) {
	var body CreateMonitoringThreadPoolWriteRejectionsRuleRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateMonitoringThreadPoolWriteRejectionsRuleRequest overwrites any union data inside the CreateRuleRequest as the provided CreateMonitoringThreadPoolWriteRejectionsRuleRequest
func (t *CreateRuleRequest) FromCreateMonitoringThreadPoolWriteRejectionsRuleRequest(v CreateMonitoringThreadPoolWriteRejectionsRuleRequest) error {
	v.RuleTypeId = "monitoring_alert_thread_pool_write_rejections"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateMonitoringThreadPoolWriteRejectionsRuleRequest performs a merge with any union data inside the CreateRuleRequest, using the provided CreateMonitoringThreadPoolWriteRejectionsRuleRequest
func (t *CreateRuleRequest) MergeCreateMonitoringThreadPoolWriteRejectionsRuleRequest(v CreateMonitoringThreadPoolWriteRejectionsRuleRequest) error {
	v.RuleTypeId = "monitoring_alert_thread_pool_write_rejections"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateSiemEqlRuleRequest returns the union data inside the CreateRuleRequest as a CreateSiemEqlRuleRequest
func (t CreateRuleRequest) AsCreateSiemEqlRuleRequest() (CreateSiemEqlRuleRequest, error) {
	var body CreateSiemEqlRuleRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateSiemEqlRuleRequest overwrites any union data inside the CreateRuleRequest as the provided CreateSiemEqlRuleRequest
func (t *CreateRuleRequest) FromCreateSiemEqlRuleRequest(v CreateSiemEqlRuleRequest) error {
	v.RuleTypeId = "siem.eqlRule"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateSiemEqlRuleRequest performs a merge with any union data inside the CreateRuleRequest, using the provided CreateSiemEqlRuleRequest
func (t *CreateRuleRequest) MergeCreateSiemEqlRuleRequest(v CreateSiemEqlRuleRequest) error {
	v.RuleTypeId = "siem.eqlRule"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateSiemIndicatorRuleRequest returns the union data inside the CreateRuleRequest as a CreateSiemIndicatorRuleRequest
func (t CreateRuleRequest) AsCreateSiemIndicatorRuleRequest() (CreateSiemIndicatorRuleRequest, error) {
	var body CreateSiemIndicatorRuleRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateSiemIndicatorRuleRequest overwrites any union data inside the CreateRuleRequest as the provided CreateSiemIndicatorRuleRequest
func (t *CreateRuleRequest) FromCreateSiemIndicatorRuleRequest(v CreateSiemIndicatorRuleRequest) error {
	v.RuleTypeId = "siem.indicatorRule"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateSiemIndicatorRuleRequest performs a merge with any union data inside the CreateRuleRequest, using the provided CreateSiemIndicatorRuleRequest
func (t *CreateRuleRequest) MergeCreateSiemIndicatorRuleRequest(v CreateSiemIndicatorRuleRequest) error {
	v.RuleTypeId = "siem.indicatorRule"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateSiemMlRuleRequest returns the union data inside the CreateRuleRequest as a CreateSiemMlRuleRequest
func (t CreateRuleRequest) AsCreateSiemMlRuleRequest() (CreateSiemMlRuleRequest, error) {
	var body CreateSiemMlRuleRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateSiemMlRuleRequest overwrites any union data inside the CreateRuleRequest as the provided CreateSiemMlRuleRequest
func (t *CreateRuleRequest) FromCreateSiemMlRuleRequest(v CreateSiemMlRuleRequest) error {
	v.RuleTypeId = "siem.mlRule"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateSiemMlRuleRequest performs a merge with any union data inside the CreateRuleRequest, using the provided CreateSiemMlRuleRequest
func (t *CreateRuleRequest) MergeCreateSiemMlRuleRequest(v CreateSiemMlRuleRequest) error {
	v.RuleTypeId = "siem.mlRule"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateSiemNewTermsRuleRequest returns the union data inside the CreateRuleRequest as a CreateSiemNewTermsRuleRequest
func (t CreateRuleRequest) AsCreateSiemNewTermsRuleRequest() (CreateSiemNewTermsRuleRequest, error) {
	var body CreateSiemNewTermsRuleRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateSiemNewTermsRuleRequest overwrites any union data inside the CreateRuleRequest as the provided CreateSiemNewTermsRuleRequest
func (t *CreateRuleRequest) FromCreateSiemNewTermsRuleRequest(v CreateSiemNewTermsRuleRequest) error {
	v.RuleTypeId = "siem.newTermsRule"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateSiemNewTermsRuleRequest performs a merge with any union data inside the CreateRuleRequest, using the provided CreateSiemNewTermsRuleRequest
func (t *CreateRuleRequest) MergeCreateSiemNewTermsRuleRequest(v CreateSiemNewTermsRuleRequest) error {
	v.RuleTypeId = "siem.newTermsRule"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateSiemNotificationsRuleRequest returns the union data inside the CreateRuleRequest as a CreateSiemNotificationsRuleRequest
func (t CreateRuleRequest) AsCreateSiemNotificationsRuleRequest() (CreateSiemNotificationsRuleRequest, error) {
	var body CreateSiemNotificationsRuleRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateSiemNotificationsRuleRequest overwrites any union data inside the CreateRuleRequest as the provided CreateSiemNotificationsRuleRequest
func (t *CreateRuleRequest) FromCreateSiemNotificationsRuleRequest(v CreateSiemNotificationsRuleRequest) error {
	v.RuleTypeId = "siem.notifications"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateSiemNotificationsRuleRequest performs a merge with any union data inside the CreateRuleRequest, using the provided CreateSiemNotificationsRuleRequest
func (t *CreateRuleRequest) MergeCreateSiemNotificationsRuleRequest(v CreateSiemNotificationsRuleRequest) error {
	v.RuleTypeId = "siem.notifications"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateSiemQueryRuleRequest returns the union data inside the CreateRuleRequest as a CreateSiemQueryRuleRequest
func (t CreateRuleRequest) AsCreateSiemQueryRuleRequest() (CreateSiemQueryRuleRequest, error) {
	var body CreateSiemQueryRuleRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateSiemQueryRuleRequest overwrites any union data inside the CreateRuleRequest as the provided CreateSiemQueryRuleRequest
func (t *CreateRuleRequest) FromCreateSiemQueryRuleRequest(v CreateSiemQueryRuleRequest) error {
	v.RuleTypeId = "siem.queryRule"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateSiemQueryRuleRequest performs a merge with any union data inside the CreateRuleRequest, using the provided CreateSiemQueryRuleRequest
func (t *CreateRuleRequest) MergeCreateSiemQueryRuleRequest(v CreateSiemQueryRuleRequest) error {
	v.RuleTypeId = "siem.queryRule"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateSiemSavedQueryRuleRequest returns the union data inside the CreateRuleRequest as a CreateSiemSavedQueryRuleRequest
func (t CreateRuleRequest) AsCreateSiemSavedQueryRuleRequest() (CreateSiemSavedQueryRuleRequest, error) {
	var body CreateSiemSavedQueryRuleRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateSiemSavedQueryRuleRequest overwrites any union data inside the CreateRuleRequest as the provided CreateSiemSavedQueryRuleRequest
func (t *CreateRuleRequest) FromCreateSiemSavedQueryRuleRequest(v CreateSiemSavedQueryRuleRequest) error {
	v.RuleTypeId = "siem.savedQueryRule"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateSiemSavedQueryRuleRequest performs a merge with any union data inside the CreateRuleRequest, using the provided CreateSiemSavedQueryRuleRequest
func (t *CreateRuleRequest) MergeCreateSiemSavedQueryRuleRequest(v CreateSiemSavedQueryRuleRequest) error {
	v.RuleTypeId = "siem.savedQueryRule"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateSiemThresholdRuleRequest returns the union data inside the CreateRuleRequest as a CreateSiemThresholdRuleRequest
func (t CreateRuleRequest) AsCreateSiemThresholdRuleRequest() (CreateSiemThresholdRuleRequest, error) {
	var body CreateSiemThresholdRuleRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateSiemThresholdRuleRequest overwrites any union data inside the CreateRuleRequest as the provided CreateSiemThresholdRuleRequest
func (t *CreateRuleRequest) FromCreateSiemThresholdRuleRequest(v CreateSiemThresholdRuleRequest) error {
	v.RuleTypeId = "siem.thresholdRule"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateSiemThresholdRuleRequest performs a merge with any union data inside the CreateRuleRequest, using the provided CreateSiemThresholdRuleRequest
func (t *CreateRuleRequest) MergeCreateSiemThresholdRuleRequest(v CreateSiemThresholdRuleRequest) error {
	v.RuleTypeId = "siem.thresholdRule"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateSloBurnRateRuleRequest returns the union data inside the CreateRuleRequest as a CreateSloBurnRateRuleRequest
func (t CreateRuleRequest) AsCreateSloBurnRateRuleRequest() (CreateSloBurnRateRuleRequest, error) {
	var body CreateSloBurnRateRuleRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateSloBurnRateRuleRequest overwrites any union data inside the CreateRuleRequest as the provided CreateSloBurnRateRuleRequest
func (t *CreateRuleRequest) FromCreateSloBurnRateRuleRequest(v CreateSloBurnRateRuleRequest) error {
	v.RuleTypeId = "slo.rules.burnRate"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateSloBurnRateRuleRequest performs a merge with any union data inside the CreateRuleRequest, using the provided CreateSloBurnRateRuleRequest
func (t *CreateRuleRequest) MergeCreateSloBurnRateRuleRequest(v CreateSloBurnRateRuleRequest) error {
	v.RuleTypeId = "slo.rules.burnRate"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateSyntheticsMonitorStatusRuleRequest returns the union data inside the CreateRuleRequest as a CreateSyntheticsMonitorStatusRuleRequest
func (t CreateRuleRequest) AsCreateSyntheticsMonitorStatusRuleRequest() (CreateSyntheticsMonitorStatusRuleRequest, error) {
	var body CreateSyntheticsMonitorStatusRuleRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateSyntheticsMonitorStatusRuleRequest overwrites any union data inside the CreateRuleRequest as the provided CreateSyntheticsMonitorStatusRuleRequest
func (t *CreateRuleRequest) FromCreateSyntheticsMonitorStatusRuleRequest(v CreateSyntheticsMonitorStatusRuleRequest) error {
	v.RuleTypeId = "xpack.synthetics.alerts.monitorStatus"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateSyntheticsMonitorStatusRuleRequest performs a merge with any union data inside the CreateRuleRequest, using the provided CreateSyntheticsMonitorStatusRuleRequest
func (t *CreateRuleRequest) MergeCreateSyntheticsMonitorStatusRuleRequest(v CreateSyntheticsMonitorStatusRuleRequest) error {
	v.RuleTypeId = "xpack.synthetics.alerts.monitorStatus"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateSyntheticsUptimeDurationAnomalyRuleRequest returns the union data inside the CreateRuleRequest as a CreateSyntheticsUptimeDurationAnomalyRuleRequest
func (t CreateRuleRequest) AsCreateSyntheticsUptimeDurationAnomalyRuleRequest() (CreateSyntheticsUptimeDurationAnomalyRuleRequest, error) {
	var body CreateSyntheticsUptimeDurationAnomalyRuleRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateSyntheticsUptimeDurationAnomalyRuleRequest overwrites any union data inside the CreateRuleRequest as the provided CreateSyntheticsUptimeDurationAnomalyRuleRequest
func (t *CreateRuleRequest) FromCreateSyntheticsUptimeDurationAnomalyRuleRequest(v CreateSyntheticsUptimeDurationAnomalyRuleRequest) error {
	v.RuleTypeId = "xpack.uptime.alerts.durationAnomaly"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateSyntheticsUptimeDurationAnomalyRuleRequest performs a merge with any union data inside the CreateRuleRequest, using the provided CreateSyntheticsUptimeDurationAnomalyRuleRequest
func (t *CreateRuleRequest) MergeCreateSyntheticsUptimeDurationAnomalyRuleRequest(v CreateSyntheticsUptimeDurationAnomalyRuleRequest) error {
	v.RuleTypeId = "xpack.uptime.alerts.durationAnomaly"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateSyntheticsUptimeTlsRuleRequest returns the union data inside the CreateRuleRequest as a CreateSyntheticsUptimeTlsRuleRequest
func (t CreateRuleRequest) AsCreateSyntheticsUptimeTlsRuleRequest() (CreateSyntheticsUptimeTlsRuleRequest, error) {
	var body CreateSyntheticsUptimeTlsRuleRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateSyntheticsUptimeTlsRuleRequest overwrites any union data inside the CreateRuleRequest as the provided CreateSyntheticsUptimeTlsRuleRequest
func (t *CreateRuleRequest) FromCreateSyntheticsUptimeTlsRuleRequest(v CreateSyntheticsUptimeTlsRuleRequest) error {
	v.RuleTypeId = "xpack.uptime.alerts.tls"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateSyntheticsUptimeTlsRuleRequest performs a merge with any union data inside the CreateRuleRequest, using the provided CreateSyntheticsUptimeTlsRuleRequest
func (t *CreateRuleRequest) MergeCreateSyntheticsUptimeTlsRuleRequest(v CreateSyntheticsUptimeTlsRuleRequest) error {
	v.RuleTypeId = "xpack.uptime.alerts.tls"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateSyntheticsUptimeTlsCertificateRuleRequest returns the union data inside the CreateRuleRequest as a CreateSyntheticsUptimeTlsCertificateRuleRequest
func (t CreateRuleRequest) AsCreateSyntheticsUptimeTlsCertificateRuleRequest() (CreateSyntheticsUptimeTlsCertificateRuleRequest, error) {
	var body CreateSyntheticsUptimeTlsCertificateRuleRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateSyntheticsUptimeTlsCertificateRuleRequest overwrites any union data inside the CreateRuleRequest as the provided CreateSyntheticsUptimeTlsCertificateRuleRequest
func (t *CreateRuleRequest) FromCreateSyntheticsUptimeTlsCertificateRuleRequest(v CreateSyntheticsUptimeTlsCertificateRuleRequest) error {
	v.RuleTypeId = "xpack.uptime.alerts.tlsCertificate"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateSyntheticsUptimeTlsCertificateRuleRequest performs a merge with any union data inside the CreateRuleRequest, using the provided CreateSyntheticsUptimeTlsCertificateRuleRequest
func (t *CreateRuleRequest) MergeCreateSyntheticsUptimeTlsCertificateRuleRequest(v CreateSyntheticsUptimeTlsCertificateRuleRequest) error {
	v.RuleTypeId = "xpack.uptime.alerts.tlsCertificate"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateTransformHealthRuleRequest returns the union data inside the CreateRuleRequest as a CreateTransformHealthRuleRequest
func (t CreateRuleRequest) AsCreateTransformHealthRuleRequest() (CreateTransformHealthRuleRequest, error) {
	var body CreateTransformHealthRuleRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateTransformHealthRuleRequest overwrites any union data inside the CreateRuleRequest as the provided CreateTransformHealthRuleRequest
func (t *CreateRuleRequest) FromCreateTransformHealthRuleRequest(v CreateTransformHealthRuleRequest) error {
	v.RuleTypeId = "transform_health"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateTransformHealthRuleRequest performs a merge with any union data inside the CreateRuleRequest, using the provided CreateTransformHealthRuleRequest
func (t *CreateRuleRequest) MergeCreateTransformHealthRuleRequest(v CreateTransformHealthRuleRequest) error {
	v.RuleTypeId = "transform_health"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateUptimeMonitorStatusRuleRequest returns the union data inside the CreateRuleRequest as a CreateUptimeMonitorStatusRuleRequest
func (t CreateRuleRequest) AsCreateUptimeMonitorStatusRuleRequest() (CreateUptimeMonitorStatusRuleRequest, error) {
	var body CreateUptimeMonitorStatusRuleRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateUptimeMonitorStatusRuleRequest overwrites any union data inside the CreateRuleRequest as the provided CreateUptimeMonitorStatusRuleRequest
func (t *CreateRuleRequest) FromCreateUptimeMonitorStatusRuleRequest(v CreateUptimeMonitorStatusRuleRequest) error {
	v.RuleTypeId = "xpack.uptime.alerts.monitorStatus"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateUptimeMonitorStatusRuleRequest performs a merge with any union data inside the CreateRuleRequest, using the provided CreateUptimeMonitorStatusRuleRequest
func (t *CreateRuleRequest) MergeCreateUptimeMonitorStatusRuleRequest(v CreateUptimeMonitorStatusRuleRequest) error {
	v.RuleTypeId = "xpack.uptime.alerts.monitorStatus"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateRuleRequest) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"rule_type_id"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t CreateRuleRequest) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case ".es-query":
		return t.AsCreateEsQueryRuleRequest()
	case ".geo-containment":
		return t.AsCreateGeoContainmentRuleRequest()
	case ".index-threshold":
		return t.AsCreateIndexThresholdRuleRequest()
	case "apm.anomaly":
		return t.AsCreateApmAnomalyRuleRequest()
	case "apm.error_rate":
		return t.AsCreateApmErrorCountRuleRequest()
	case "apm.transaction_duration":
		return t.AsCreateApmTransactionDurationRuleRequest()
	case "apm.transaction_error_rate":
		return t.AsCreateApmTransactionErrorRateRuleRequest()
	case "logs.alert.document.count":
		return t.AsCreateLogThresholdRuleRequest()
	case "metrics.alert.anomaly":
		return t.AsCreateInfraMetricAnomalyRuleRequest()
	case "metrics.alert.inventory.threshold":
		return t.AsCreateInfraInventoryRuleRequest()
	case "metrics.alert.threshold":
		return t.AsCreateInfraMetricThresholdRuleRequest()
	case "monitoring_alert_cluster_health":
		return t.AsCreateMonitoringClusterHealthRuleRequest()
	case "monitoring_alert_cpu_usage":
		return t.AsCreateMonitoringCpuUsageRuleRequest()
	case "monitoring_alert_disk_usage":
		return t.AsCreateMonitoringDiskUsageRuleRequest()
	case "monitoring_alert_elasticsearch_version_mismatch":
		return t.AsCreateMonitoringElasticsearchVersionMismatchRuleRequest()
	case "monitoring_alert_jvm_memory_usage":
		return t.AsCreateMonitoringJvmMemoryUsageRuleRequest()
	case "monitoring_alert_kibana_version_mismatch":
		return t.AsCreateMonitoringKibanaVersionMismatchRuleRequest()
	case "monitoring_alert_license_expiration":
		return t.AsCreateMonitoringLicenseExpirationRuleRequest()
	case "monitoring_alert_logstash_version_mismatch":
		return t.AsCreateMonitoringLogstashVersionMismatchRuleRequest()
	case "monitoring_alert_missing_monitoring_data":
		return t.AsCreateMonitoringMissingDataRuleRequest()
	case "monitoring_alert_nodes_changed":
		return t.AsCreateMonitoringNodesChangedRuleRequest()
	case "monitoring_alert_thread_pool_search_rejections":
		return t.AsCreateMonitoringThreadPoolSearchRejectionsRuleRequest()
	case "monitoring_alert_thread_pool_write_rejections":
		return t.AsCreateMonitoringThreadPoolWriteRejectionsRuleRequest()
	case "monitoring_ccr_read_exceptions":
		return t.AsCreateMonitoringCcrExceptionsRuleRequest()
	case "monitoring_shard_size":
		return t.AsCreateMonitoringShardSizeRuleRequest()
	case "siem.eqlRule":
		return t.AsCreateSiemEqlRuleRequest()
	case "siem.indicatorRule":
		return t.AsCreateSiemIndicatorRuleRequest()
	case "siem.mlRule":
		return t.AsCreateSiemMlRuleRequest()
	case "siem.newTermsRule":
		return t.AsCreateSiemNewTermsRuleRequest()
	case "siem.notifications":
		return t.AsCreateSiemNotificationsRuleRequest()
	case "siem.queryRule":
		return t.AsCreateSiemQueryRuleRequest()
	case "siem.savedQueryRule":
		return t.AsCreateSiemSavedQueryRuleRequest()
	case "siem.thresholdRule":
		return t.AsCreateSiemThresholdRuleRequest()
	case "slo.rules.burnRate":
		return t.AsCreateSloBurnRateRuleRequest()
	case "transform_health":
		return t.AsCreateTransformHealthRuleRequest()
	case "xpack.ml.anomaly_detection_alert":
		return t.AsCreateAnomalyDetectionAlertRuleRequest()
	case "xpack.ml.anomaly_detection_jobs_health":
		return t.AsCreateAnomalyDetectionJobsHealthRuleRequest()
	case "xpack.synthetics.alerts.monitorStatus":
		return t.AsCreateSyntheticsMonitorStatusRuleRequest()
	case "xpack.uptime.alerts.durationAnomaly":
		return t.AsCreateSyntheticsUptimeDurationAnomalyRuleRequest()
	case "xpack.uptime.alerts.monitorStatus":
		return t.AsCreateUptimeMonitorStatusRuleRequest()
	case "xpack.uptime.alerts.tls":
		return t.AsCreateSyntheticsUptimeTlsRuleRequest()
	case "xpack.uptime.alerts.tlsCertificate":
		return t.AsCreateSyntheticsUptimeTlsCertificateRuleRequest()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t CreateRuleRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateRuleRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsIndicatorPropertiesCustomKql returns the union data inside the CreateSloRequest_Indicator as a IndicatorPropertiesCustomKql
func (t CreateSloRequest_Indicator) AsIndicatorPropertiesCustomKql() (IndicatorPropertiesCustomKql, error) {
	var body IndicatorPropertiesCustomKql
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndicatorPropertiesCustomKql overwrites any union data inside the CreateSloRequest_Indicator as the provided IndicatorPropertiesCustomKql
func (t *CreateSloRequest_Indicator) FromIndicatorPropertiesCustomKql(v IndicatorPropertiesCustomKql) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndicatorPropertiesCustomKql performs a merge with any union data inside the CreateSloRequest_Indicator, using the provided IndicatorPropertiesCustomKql
func (t *CreateSloRequest_Indicator) MergeIndicatorPropertiesCustomKql(v IndicatorPropertiesCustomKql) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIndicatorPropertiesApmAvailability returns the union data inside the CreateSloRequest_Indicator as a IndicatorPropertiesApmAvailability
func (t CreateSloRequest_Indicator) AsIndicatorPropertiesApmAvailability() (IndicatorPropertiesApmAvailability, error) {
	var body IndicatorPropertiesApmAvailability
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndicatorPropertiesApmAvailability overwrites any union data inside the CreateSloRequest_Indicator as the provided IndicatorPropertiesApmAvailability
func (t *CreateSloRequest_Indicator) FromIndicatorPropertiesApmAvailability(v IndicatorPropertiesApmAvailability) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndicatorPropertiesApmAvailability performs a merge with any union data inside the CreateSloRequest_Indicator, using the provided IndicatorPropertiesApmAvailability
func (t *CreateSloRequest_Indicator) MergeIndicatorPropertiesApmAvailability(v IndicatorPropertiesApmAvailability) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIndicatorPropertiesApmLatency returns the union data inside the CreateSloRequest_Indicator as a IndicatorPropertiesApmLatency
func (t CreateSloRequest_Indicator) AsIndicatorPropertiesApmLatency() (IndicatorPropertiesApmLatency, error) {
	var body IndicatorPropertiesApmLatency
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndicatorPropertiesApmLatency overwrites any union data inside the CreateSloRequest_Indicator as the provided IndicatorPropertiesApmLatency
func (t *CreateSloRequest_Indicator) FromIndicatorPropertiesApmLatency(v IndicatorPropertiesApmLatency) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndicatorPropertiesApmLatency performs a merge with any union data inside the CreateSloRequest_Indicator, using the provided IndicatorPropertiesApmLatency
func (t *CreateSloRequest_Indicator) MergeIndicatorPropertiesApmLatency(v IndicatorPropertiesApmLatency) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIndicatorPropertiesCustomMetric returns the union data inside the CreateSloRequest_Indicator as a IndicatorPropertiesCustomMetric
func (t CreateSloRequest_Indicator) AsIndicatorPropertiesCustomMetric() (IndicatorPropertiesCustomMetric, error) {
	var body IndicatorPropertiesCustomMetric
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndicatorPropertiesCustomMetric overwrites any union data inside the CreateSloRequest_Indicator as the provided IndicatorPropertiesCustomMetric
func (t *CreateSloRequest_Indicator) FromIndicatorPropertiesCustomMetric(v IndicatorPropertiesCustomMetric) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndicatorPropertiesCustomMetric performs a merge with any union data inside the CreateSloRequest_Indicator, using the provided IndicatorPropertiesCustomMetric
func (t *CreateSloRequest_Indicator) MergeIndicatorPropertiesCustomMetric(v IndicatorPropertiesCustomMetric) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIndicatorPropertiesHistogram returns the union data inside the CreateSloRequest_Indicator as a IndicatorPropertiesHistogram
func (t CreateSloRequest_Indicator) AsIndicatorPropertiesHistogram() (IndicatorPropertiesHistogram, error) {
	var body IndicatorPropertiesHistogram
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndicatorPropertiesHistogram overwrites any union data inside the CreateSloRequest_Indicator as the provided IndicatorPropertiesHistogram
func (t *CreateSloRequest_Indicator) FromIndicatorPropertiesHistogram(v IndicatorPropertiesHistogram) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndicatorPropertiesHistogram performs a merge with any union data inside the CreateSloRequest_Indicator, using the provided IndicatorPropertiesHistogram
func (t *CreateSloRequest_Indicator) MergeIndicatorPropertiesHistogram(v IndicatorPropertiesHistogram) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIndicatorPropertiesTimesliceMetric returns the union data inside the CreateSloRequest_Indicator as a IndicatorPropertiesTimesliceMetric
func (t CreateSloRequest_Indicator) AsIndicatorPropertiesTimesliceMetric() (IndicatorPropertiesTimesliceMetric, error) {
	var body IndicatorPropertiesTimesliceMetric
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndicatorPropertiesTimesliceMetric overwrites any union data inside the CreateSloRequest_Indicator as the provided IndicatorPropertiesTimesliceMetric
func (t *CreateSloRequest_Indicator) FromIndicatorPropertiesTimesliceMetric(v IndicatorPropertiesTimesliceMetric) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndicatorPropertiesTimesliceMetric performs a merge with any union data inside the CreateSloRequest_Indicator, using the provided IndicatorPropertiesTimesliceMetric
func (t *CreateSloRequest_Indicator) MergeIndicatorPropertiesTimesliceMetric(v IndicatorPropertiesTimesliceMetric) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateSloRequest_Indicator) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateSloRequest_Indicator) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTimesliceMetricBasicMetricWithField returns the union data inside the IndicatorPropertiesTimesliceMetric_Params_Metric_Metrics_Item as a TimesliceMetricBasicMetricWithField
func (t IndicatorPropertiesTimesliceMetric_Params_Metric_Metrics_Item) AsTimesliceMetricBasicMetricWithField() (TimesliceMetricBasicMetricWithField, error) {
	var body TimesliceMetricBasicMetricWithField
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTimesliceMetricBasicMetricWithField overwrites any union data inside the IndicatorPropertiesTimesliceMetric_Params_Metric_Metrics_Item as the provided TimesliceMetricBasicMetricWithField
func (t *IndicatorPropertiesTimesliceMetric_Params_Metric_Metrics_Item) FromTimesliceMetricBasicMetricWithField(v TimesliceMetricBasicMetricWithField) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTimesliceMetricBasicMetricWithField performs a merge with any union data inside the IndicatorPropertiesTimesliceMetric_Params_Metric_Metrics_Item, using the provided TimesliceMetricBasicMetricWithField
func (t *IndicatorPropertiesTimesliceMetric_Params_Metric_Metrics_Item) MergeTimesliceMetricBasicMetricWithField(v TimesliceMetricBasicMetricWithField) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTimesliceMetricPercentileMetric returns the union data inside the IndicatorPropertiesTimesliceMetric_Params_Metric_Metrics_Item as a TimesliceMetricPercentileMetric
func (t IndicatorPropertiesTimesliceMetric_Params_Metric_Metrics_Item) AsTimesliceMetricPercentileMetric() (TimesliceMetricPercentileMetric, error) {
	var body TimesliceMetricPercentileMetric
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTimesliceMetricPercentileMetric overwrites any union data inside the IndicatorPropertiesTimesliceMetric_Params_Metric_Metrics_Item as the provided TimesliceMetricPercentileMetric
func (t *IndicatorPropertiesTimesliceMetric_Params_Metric_Metrics_Item) FromTimesliceMetricPercentileMetric(v TimesliceMetricPercentileMetric) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTimesliceMetricPercentileMetric performs a merge with any union data inside the IndicatorPropertiesTimesliceMetric_Params_Metric_Metrics_Item, using the provided TimesliceMetricPercentileMetric
func (t *IndicatorPropertiesTimesliceMetric_Params_Metric_Metrics_Item) MergeTimesliceMetricPercentileMetric(v TimesliceMetricPercentileMetric) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTimesliceMetricDocCountMetric returns the union data inside the IndicatorPropertiesTimesliceMetric_Params_Metric_Metrics_Item as a TimesliceMetricDocCountMetric
func (t IndicatorPropertiesTimesliceMetric_Params_Metric_Metrics_Item) AsTimesliceMetricDocCountMetric() (TimesliceMetricDocCountMetric, error) {
	var body TimesliceMetricDocCountMetric
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTimesliceMetricDocCountMetric overwrites any union data inside the IndicatorPropertiesTimesliceMetric_Params_Metric_Metrics_Item as the provided TimesliceMetricDocCountMetric
func (t *IndicatorPropertiesTimesliceMetric_Params_Metric_Metrics_Item) FromTimesliceMetricDocCountMetric(v TimesliceMetricDocCountMetric) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTimesliceMetricDocCountMetric performs a merge with any union data inside the IndicatorPropertiesTimesliceMetric_Params_Metric_Metrics_Item, using the provided TimesliceMetricDocCountMetric
func (t *IndicatorPropertiesTimesliceMetric_Params_Metric_Metrics_Item) MergeTimesliceMetricDocCountMetric(v TimesliceMetricDocCountMetric) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t IndicatorPropertiesTimesliceMetric_Params_Metric_Metrics_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *IndicatorPropertiesTimesliceMetric_Params_Metric_Metrics_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsKqlWithFilters0 returns the union data inside the KqlWithFilters as a KqlWithFilters0
func (t KqlWithFilters) AsKqlWithFilters0() (KqlWithFilters0, error) {
	var body KqlWithFilters0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKqlWithFilters0 overwrites any union data inside the KqlWithFilters as the provided KqlWithFilters0
func (t *KqlWithFilters) FromKqlWithFilters0(v KqlWithFilters0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKqlWithFilters0 performs a merge with any union data inside the KqlWithFilters, using the provided KqlWithFilters0
func (t *KqlWithFilters) MergeKqlWithFilters0(v KqlWithFilters0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsKqlWithFilters1 returns the union data inside the KqlWithFilters as a KqlWithFilters1
func (t KqlWithFilters) AsKqlWithFilters1() (KqlWithFilters1, error) {
	var body KqlWithFilters1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKqlWithFilters1 overwrites any union data inside the KqlWithFilters as the provided KqlWithFilters1
func (t *KqlWithFilters) FromKqlWithFilters1(v KqlWithFilters1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKqlWithFilters1 performs a merge with any union data inside the KqlWithFilters, using the provided KqlWithFilters1
func (t *KqlWithFilters) MergeKqlWithFilters1(v KqlWithFilters1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t KqlWithFilters) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *KqlWithFilters) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsKqlWithFiltersGood0 returns the union data inside the KqlWithFiltersGood as a KqlWithFiltersGood0
func (t KqlWithFiltersGood) AsKqlWithFiltersGood0() (KqlWithFiltersGood0, error) {
	var body KqlWithFiltersGood0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKqlWithFiltersGood0 overwrites any union data inside the KqlWithFiltersGood as the provided KqlWithFiltersGood0
func (t *KqlWithFiltersGood) FromKqlWithFiltersGood0(v KqlWithFiltersGood0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKqlWithFiltersGood0 performs a merge with any union data inside the KqlWithFiltersGood, using the provided KqlWithFiltersGood0
func (t *KqlWithFiltersGood) MergeKqlWithFiltersGood0(v KqlWithFiltersGood0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsKqlWithFiltersGood1 returns the union data inside the KqlWithFiltersGood as a KqlWithFiltersGood1
func (t KqlWithFiltersGood) AsKqlWithFiltersGood1() (KqlWithFiltersGood1, error) {
	var body KqlWithFiltersGood1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKqlWithFiltersGood1 overwrites any union data inside the KqlWithFiltersGood as the provided KqlWithFiltersGood1
func (t *KqlWithFiltersGood) FromKqlWithFiltersGood1(v KqlWithFiltersGood1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKqlWithFiltersGood1 performs a merge with any union data inside the KqlWithFiltersGood, using the provided KqlWithFiltersGood1
func (t *KqlWithFiltersGood) MergeKqlWithFiltersGood1(v KqlWithFiltersGood1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t KqlWithFiltersGood) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *KqlWithFiltersGood) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsKqlWithFiltersTotal0 returns the union data inside the KqlWithFiltersTotal as a KqlWithFiltersTotal0
func (t KqlWithFiltersTotal) AsKqlWithFiltersTotal0() (KqlWithFiltersTotal0, error) {
	var body KqlWithFiltersTotal0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKqlWithFiltersTotal0 overwrites any union data inside the KqlWithFiltersTotal as the provided KqlWithFiltersTotal0
func (t *KqlWithFiltersTotal) FromKqlWithFiltersTotal0(v KqlWithFiltersTotal0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKqlWithFiltersTotal0 performs a merge with any union data inside the KqlWithFiltersTotal, using the provided KqlWithFiltersTotal0
func (t *KqlWithFiltersTotal) MergeKqlWithFiltersTotal0(v KqlWithFiltersTotal0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsKqlWithFiltersTotal1 returns the union data inside the KqlWithFiltersTotal as a KqlWithFiltersTotal1
func (t KqlWithFiltersTotal) AsKqlWithFiltersTotal1() (KqlWithFiltersTotal1, error) {
	var body KqlWithFiltersTotal1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKqlWithFiltersTotal1 overwrites any union data inside the KqlWithFiltersTotal as the provided KqlWithFiltersTotal1
func (t *KqlWithFiltersTotal) FromKqlWithFiltersTotal1(v KqlWithFiltersTotal1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKqlWithFiltersTotal1 performs a merge with any union data inside the KqlWithFiltersTotal, using the provided KqlWithFiltersTotal1
func (t *KqlWithFiltersTotal) MergeKqlWithFiltersTotal1(v KqlWithFiltersTotal1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t KqlWithFiltersTotal) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *KqlWithFiltersTotal) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOutputCreateRequestElasticsearch returns the union data inside the OutputCreateRequest as a OutputCreateRequestElasticsearch
func (t OutputCreateRequest) AsOutputCreateRequestElasticsearch() (OutputCreateRequestElasticsearch, error) {
	var body OutputCreateRequestElasticsearch
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOutputCreateRequestElasticsearch overwrites any union data inside the OutputCreateRequest as the provided OutputCreateRequestElasticsearch
func (t *OutputCreateRequest) FromOutputCreateRequestElasticsearch(v OutputCreateRequestElasticsearch) error {
	v.Type = "elasticsearch"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOutputCreateRequestElasticsearch performs a merge with any union data inside the OutputCreateRequest, using the provided OutputCreateRequestElasticsearch
func (t *OutputCreateRequest) MergeOutputCreateRequestElasticsearch(v OutputCreateRequestElasticsearch) error {
	v.Type = "elasticsearch"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOutputCreateRequestKafka returns the union data inside the OutputCreateRequest as a OutputCreateRequestKafka
func (t OutputCreateRequest) AsOutputCreateRequestKafka() (OutputCreateRequestKafka, error) {
	var body OutputCreateRequestKafka
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOutputCreateRequestKafka overwrites any union data inside the OutputCreateRequest as the provided OutputCreateRequestKafka
func (t *OutputCreateRequest) FromOutputCreateRequestKafka(v OutputCreateRequestKafka) error {
	v.Type = "kafka"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOutputCreateRequestKafka performs a merge with any union data inside the OutputCreateRequest, using the provided OutputCreateRequestKafka
func (t *OutputCreateRequest) MergeOutputCreateRequestKafka(v OutputCreateRequestKafka) error {
	v.Type = "kafka"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOutputCreateRequestLogstash returns the union data inside the OutputCreateRequest as a OutputCreateRequestLogstash
func (t OutputCreateRequest) AsOutputCreateRequestLogstash() (OutputCreateRequestLogstash, error) {
	var body OutputCreateRequestLogstash
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOutputCreateRequestLogstash overwrites any union data inside the OutputCreateRequest as the provided OutputCreateRequestLogstash
func (t *OutputCreateRequest) FromOutputCreateRequestLogstash(v OutputCreateRequestLogstash) error {
	v.Type = "logstash"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOutputCreateRequestLogstash performs a merge with any union data inside the OutputCreateRequest, using the provided OutputCreateRequestLogstash
func (t *OutputCreateRequest) MergeOutputCreateRequestLogstash(v OutputCreateRequestLogstash) error {
	v.Type = "logstash"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOutputCreateRequestRemoteElasticsearch returns the union data inside the OutputCreateRequest as a OutputCreateRequestRemoteElasticsearch
func (t OutputCreateRequest) AsOutputCreateRequestRemoteElasticsearch() (OutputCreateRequestRemoteElasticsearch, error) {
	var body OutputCreateRequestRemoteElasticsearch
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOutputCreateRequestRemoteElasticsearch overwrites any union data inside the OutputCreateRequest as the provided OutputCreateRequestRemoteElasticsearch
func (t *OutputCreateRequest) FromOutputCreateRequestRemoteElasticsearch(v OutputCreateRequestRemoteElasticsearch) error {
	v.Type = "remote_elasticsearch"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOutputCreateRequestRemoteElasticsearch performs a merge with any union data inside the OutputCreateRequest, using the provided OutputCreateRequestRemoteElasticsearch
func (t *OutputCreateRequest) MergeOutputCreateRequestRemoteElasticsearch(v OutputCreateRequestRemoteElasticsearch) error {
	v.Type = "remote_elasticsearch"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t OutputCreateRequest) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t OutputCreateRequest) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "elasticsearch":
		return t.AsOutputCreateRequestElasticsearch()
	case "kafka":
		return t.AsOutputCreateRequestKafka()
	case "logstash":
		return t.AsOutputCreateRequestLogstash()
	case "remote_elasticsearch":
		return t.AsOutputCreateRequestRemoteElasticsearch()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t OutputCreateRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OutputCreateRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOutputUpdateRequestElasticsearch returns the union data inside the OutputUpdateRequest as a OutputUpdateRequestElasticsearch
func (t OutputUpdateRequest) AsOutputUpdateRequestElasticsearch() (OutputUpdateRequestElasticsearch, error) {
	var body OutputUpdateRequestElasticsearch
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOutputUpdateRequestElasticsearch overwrites any union data inside the OutputUpdateRequest as the provided OutputUpdateRequestElasticsearch
func (t *OutputUpdateRequest) FromOutputUpdateRequestElasticsearch(v OutputUpdateRequestElasticsearch) error {
	v.Type = "elasticsearch"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOutputUpdateRequestElasticsearch performs a merge with any union data inside the OutputUpdateRequest, using the provided OutputUpdateRequestElasticsearch
func (t *OutputUpdateRequest) MergeOutputUpdateRequestElasticsearch(v OutputUpdateRequestElasticsearch) error {
	v.Type = "elasticsearch"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOutputUpdateRequestKafka returns the union data inside the OutputUpdateRequest as a OutputUpdateRequestKafka
func (t OutputUpdateRequest) AsOutputUpdateRequestKafka() (OutputUpdateRequestKafka, error) {
	var body OutputUpdateRequestKafka
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOutputUpdateRequestKafka overwrites any union data inside the OutputUpdateRequest as the provided OutputUpdateRequestKafka
func (t *OutputUpdateRequest) FromOutputUpdateRequestKafka(v OutputUpdateRequestKafka) error {
	v.Type = "kafka"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOutputUpdateRequestKafka performs a merge with any union data inside the OutputUpdateRequest, using the provided OutputUpdateRequestKafka
func (t *OutputUpdateRequest) MergeOutputUpdateRequestKafka(v OutputUpdateRequestKafka) error {
	v.Type = "kafka"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOutputUpdateRequestLogstash returns the union data inside the OutputUpdateRequest as a OutputUpdateRequestLogstash
func (t OutputUpdateRequest) AsOutputUpdateRequestLogstash() (OutputUpdateRequestLogstash, error) {
	var body OutputUpdateRequestLogstash
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOutputUpdateRequestLogstash overwrites any union data inside the OutputUpdateRequest as the provided OutputUpdateRequestLogstash
func (t *OutputUpdateRequest) FromOutputUpdateRequestLogstash(v OutputUpdateRequestLogstash) error {
	v.Type = "logstash"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOutputUpdateRequestLogstash performs a merge with any union data inside the OutputUpdateRequest, using the provided OutputUpdateRequestLogstash
func (t *OutputUpdateRequest) MergeOutputUpdateRequestLogstash(v OutputUpdateRequestLogstash) error {
	v.Type = "logstash"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t OutputUpdateRequest) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t OutputUpdateRequest) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "elasticsearch":
		return t.AsOutputUpdateRequestElasticsearch()
	case "kafka":
		return t.AsOutputUpdateRequestKafka()
	case "logstash":
		return t.AsOutputUpdateRequestLogstash()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t OutputUpdateRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OutputUpdateRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsKibanaSavedObjectType returns the union data inside the PackageItemType as a KibanaSavedObjectType
func (t PackageItemType) AsKibanaSavedObjectType() (KibanaSavedObjectType, error) {
	var body KibanaSavedObjectType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKibanaSavedObjectType overwrites any union data inside the PackageItemType as the provided KibanaSavedObjectType
func (t *PackageItemType) FromKibanaSavedObjectType(v KibanaSavedObjectType) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKibanaSavedObjectType performs a merge with any union data inside the PackageItemType, using the provided KibanaSavedObjectType
func (t *PackageItemType) MergeKibanaSavedObjectType(v KibanaSavedObjectType) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsElasticsearchAssetType returns the union data inside the PackageItemType as a ElasticsearchAssetType
func (t PackageItemType) AsElasticsearchAssetType() (ElasticsearchAssetType, error) {
	var body ElasticsearchAssetType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromElasticsearchAssetType overwrites any union data inside the PackageItemType as the provided ElasticsearchAssetType
func (t *PackageItemType) FromElasticsearchAssetType(v ElasticsearchAssetType) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeElasticsearchAssetType performs a merge with any union data inside the PackageItemType, using the provided ElasticsearchAssetType
func (t *PackageItemType) MergeElasticsearchAssetType(v ElasticsearchAssetType) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PackageItemType) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PackageItemType) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsParamsEsQueryRule0 returns the union data inside the ParamsEsQueryRule as a ParamsEsQueryRule0
func (t ParamsEsQueryRule) AsParamsEsQueryRule0() (ParamsEsQueryRule0, error) {
	var body ParamsEsQueryRule0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromParamsEsQueryRule0 overwrites any union data inside the ParamsEsQueryRule as the provided ParamsEsQueryRule0
func (t *ParamsEsQueryRule) FromParamsEsQueryRule0(v ParamsEsQueryRule0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeParamsEsQueryRule0 performs a merge with any union data inside the ParamsEsQueryRule, using the provided ParamsEsQueryRule0
func (t *ParamsEsQueryRule) MergeParamsEsQueryRule0(v ParamsEsQueryRule0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsParamsEsQueryRule1 returns the union data inside the ParamsEsQueryRule as a ParamsEsQueryRule1
func (t ParamsEsQueryRule) AsParamsEsQueryRule1() (ParamsEsQueryRule1, error) {
	var body ParamsEsQueryRule1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromParamsEsQueryRule1 overwrites any union data inside the ParamsEsQueryRule as the provided ParamsEsQueryRule1
func (t *ParamsEsQueryRule) FromParamsEsQueryRule1(v ParamsEsQueryRule1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeParamsEsQueryRule1 performs a merge with any union data inside the ParamsEsQueryRule, using the provided ParamsEsQueryRule1
func (t *ParamsEsQueryRule) MergeParamsEsQueryRule1(v ParamsEsQueryRule1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsParamsEsQueryRule2 returns the union data inside the ParamsEsQueryRule as a ParamsEsQueryRule2
func (t ParamsEsQueryRule) AsParamsEsQueryRule2() (ParamsEsQueryRule2, error) {
	var body ParamsEsQueryRule2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromParamsEsQueryRule2 overwrites any union data inside the ParamsEsQueryRule as the provided ParamsEsQueryRule2
func (t *ParamsEsQueryRule) FromParamsEsQueryRule2(v ParamsEsQueryRule2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeParamsEsQueryRule2 performs a merge with any union data inside the ParamsEsQueryRule, using the provided ParamsEsQueryRule2
func (t *ParamsEsQueryRule) MergeParamsEsQueryRule2(v ParamsEsQueryRule2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ParamsEsQueryRule) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ParamsEsQueryRule) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsParamsEsQueryRule1SearchConfigurationIndex0 returns the union data inside the ParamsEsQueryRule_1_SearchConfiguration_Index as a ParamsEsQueryRule1SearchConfigurationIndex0
func (t ParamsEsQueryRule_1_SearchConfiguration_Index) AsParamsEsQueryRule1SearchConfigurationIndex0() (ParamsEsQueryRule1SearchConfigurationIndex0, error) {
	var body ParamsEsQueryRule1SearchConfigurationIndex0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromParamsEsQueryRule1SearchConfigurationIndex0 overwrites any union data inside the ParamsEsQueryRule_1_SearchConfiguration_Index as the provided ParamsEsQueryRule1SearchConfigurationIndex0
func (t *ParamsEsQueryRule_1_SearchConfiguration_Index) FromParamsEsQueryRule1SearchConfigurationIndex0(v ParamsEsQueryRule1SearchConfigurationIndex0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeParamsEsQueryRule1SearchConfigurationIndex0 performs a merge with any union data inside the ParamsEsQueryRule_1_SearchConfiguration_Index, using the provided ParamsEsQueryRule1SearchConfigurationIndex0
func (t *ParamsEsQueryRule_1_SearchConfiguration_Index) MergeParamsEsQueryRule1SearchConfigurationIndex0(v ParamsEsQueryRule1SearchConfigurationIndex0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsParamsEsQueryRule1SearchConfigurationIndex1 returns the union data inside the ParamsEsQueryRule_1_SearchConfiguration_Index as a ParamsEsQueryRule1SearchConfigurationIndex1
func (t ParamsEsQueryRule_1_SearchConfiguration_Index) AsParamsEsQueryRule1SearchConfigurationIndex1() (ParamsEsQueryRule1SearchConfigurationIndex1, error) {
	var body ParamsEsQueryRule1SearchConfigurationIndex1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromParamsEsQueryRule1SearchConfigurationIndex1 overwrites any union data inside the ParamsEsQueryRule_1_SearchConfiguration_Index as the provided ParamsEsQueryRule1SearchConfigurationIndex1
func (t *ParamsEsQueryRule_1_SearchConfiguration_Index) FromParamsEsQueryRule1SearchConfigurationIndex1(v ParamsEsQueryRule1SearchConfigurationIndex1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeParamsEsQueryRule1SearchConfigurationIndex1 performs a merge with any union data inside the ParamsEsQueryRule_1_SearchConfiguration_Index, using the provided ParamsEsQueryRule1SearchConfigurationIndex1
func (t *ParamsEsQueryRule_1_SearchConfiguration_Index) MergeParamsEsQueryRule1SearchConfigurationIndex1(v ParamsEsQueryRule1SearchConfigurationIndex1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ParamsEsQueryRule_1_SearchConfiguration_Index) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ParamsEsQueryRule_1_SearchConfiguration_Index) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsParamsEsQueryRule2Index0 returns the union data inside the ParamsEsQueryRule_2_Index as a ParamsEsQueryRule2Index0
func (t ParamsEsQueryRule_2_Index) AsParamsEsQueryRule2Index0() (ParamsEsQueryRule2Index0, error) {
	var body ParamsEsQueryRule2Index0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromParamsEsQueryRule2Index0 overwrites any union data inside the ParamsEsQueryRule_2_Index as the provided ParamsEsQueryRule2Index0
func (t *ParamsEsQueryRule_2_Index) FromParamsEsQueryRule2Index0(v ParamsEsQueryRule2Index0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeParamsEsQueryRule2Index0 performs a merge with any union data inside the ParamsEsQueryRule_2_Index, using the provided ParamsEsQueryRule2Index0
func (t *ParamsEsQueryRule_2_Index) MergeParamsEsQueryRule2Index0(v ParamsEsQueryRule2Index0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsParamsEsQueryRule2Index1 returns the union data inside the ParamsEsQueryRule_2_Index as a ParamsEsQueryRule2Index1
func (t ParamsEsQueryRule_2_Index) AsParamsEsQueryRule2Index1() (ParamsEsQueryRule2Index1, error) {
	var body ParamsEsQueryRule2Index1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromParamsEsQueryRule2Index1 overwrites any union data inside the ParamsEsQueryRule_2_Index as the provided ParamsEsQueryRule2Index1
func (t *ParamsEsQueryRule_2_Index) FromParamsEsQueryRule2Index1(v ParamsEsQueryRule2Index1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeParamsEsQueryRule2Index1 performs a merge with any union data inside the ParamsEsQueryRule_2_Index, using the provided ParamsEsQueryRule2Index1
func (t *ParamsEsQueryRule_2_Index) MergeParamsEsQueryRule2Index1(v ParamsEsQueryRule2Index1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ParamsEsQueryRule_2_Index) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ParamsEsQueryRule_2_Index) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsParamsPropertyInfraMetricThresholdCriteria2CustomMetric0 returns the union data inside the ParamsPropertyInfraMetricThreshold_Criteria_2_CustomMetric_Item as a ParamsPropertyInfraMetricThresholdCriteria2CustomMetric0
func (t ParamsPropertyInfraMetricThreshold_Criteria_2_CustomMetric_Item) AsParamsPropertyInfraMetricThresholdCriteria2CustomMetric0() (ParamsPropertyInfraMetricThresholdCriteria2CustomMetric0, error) {
	var body ParamsPropertyInfraMetricThresholdCriteria2CustomMetric0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromParamsPropertyInfraMetricThresholdCriteria2CustomMetric0 overwrites any union data inside the ParamsPropertyInfraMetricThreshold_Criteria_2_CustomMetric_Item as the provided ParamsPropertyInfraMetricThresholdCriteria2CustomMetric0
func (t *ParamsPropertyInfraMetricThreshold_Criteria_2_CustomMetric_Item) FromParamsPropertyInfraMetricThresholdCriteria2CustomMetric0(v ParamsPropertyInfraMetricThresholdCriteria2CustomMetric0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeParamsPropertyInfraMetricThresholdCriteria2CustomMetric0 performs a merge with any union data inside the ParamsPropertyInfraMetricThreshold_Criteria_2_CustomMetric_Item, using the provided ParamsPropertyInfraMetricThresholdCriteria2CustomMetric0
func (t *ParamsPropertyInfraMetricThreshold_Criteria_2_CustomMetric_Item) MergeParamsPropertyInfraMetricThresholdCriteria2CustomMetric0(v ParamsPropertyInfraMetricThresholdCriteria2CustomMetric0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsParamsPropertyInfraMetricThresholdCriteria2CustomMetric1 returns the union data inside the ParamsPropertyInfraMetricThreshold_Criteria_2_CustomMetric_Item as a ParamsPropertyInfraMetricThresholdCriteria2CustomMetric1
func (t ParamsPropertyInfraMetricThreshold_Criteria_2_CustomMetric_Item) AsParamsPropertyInfraMetricThresholdCriteria2CustomMetric1() (ParamsPropertyInfraMetricThresholdCriteria2CustomMetric1, error) {
	var body ParamsPropertyInfraMetricThresholdCriteria2CustomMetric1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromParamsPropertyInfraMetricThresholdCriteria2CustomMetric1 overwrites any union data inside the ParamsPropertyInfraMetricThreshold_Criteria_2_CustomMetric_Item as the provided ParamsPropertyInfraMetricThresholdCriteria2CustomMetric1
func (t *ParamsPropertyInfraMetricThreshold_Criteria_2_CustomMetric_Item) FromParamsPropertyInfraMetricThresholdCriteria2CustomMetric1(v ParamsPropertyInfraMetricThresholdCriteria2CustomMetric1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeParamsPropertyInfraMetricThresholdCriteria2CustomMetric1 performs a merge with any union data inside the ParamsPropertyInfraMetricThreshold_Criteria_2_CustomMetric_Item, using the provided ParamsPropertyInfraMetricThresholdCriteria2CustomMetric1
func (t *ParamsPropertyInfraMetricThreshold_Criteria_2_CustomMetric_Item) MergeParamsPropertyInfraMetricThresholdCriteria2CustomMetric1(v ParamsPropertyInfraMetricThresholdCriteria2CustomMetric1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ParamsPropertyInfraMetricThreshold_Criteria_2_CustomMetric_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ParamsPropertyInfraMetricThreshold_Criteria_2_CustomMetric_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsParamsPropertyInfraMetricThresholdCriteria0 returns the union data inside the ParamsPropertyInfraMetricThreshold_Criteria_Item as a ParamsPropertyInfraMetricThresholdCriteria0
func (t ParamsPropertyInfraMetricThreshold_Criteria_Item) AsParamsPropertyInfraMetricThresholdCriteria0() (ParamsPropertyInfraMetricThresholdCriteria0, error) {
	var body ParamsPropertyInfraMetricThresholdCriteria0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromParamsPropertyInfraMetricThresholdCriteria0 overwrites any union data inside the ParamsPropertyInfraMetricThreshold_Criteria_Item as the provided ParamsPropertyInfraMetricThresholdCriteria0
func (t *ParamsPropertyInfraMetricThreshold_Criteria_Item) FromParamsPropertyInfraMetricThresholdCriteria0(v ParamsPropertyInfraMetricThresholdCriteria0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeParamsPropertyInfraMetricThresholdCriteria0 performs a merge with any union data inside the ParamsPropertyInfraMetricThreshold_Criteria_Item, using the provided ParamsPropertyInfraMetricThresholdCriteria0
func (t *ParamsPropertyInfraMetricThreshold_Criteria_Item) MergeParamsPropertyInfraMetricThresholdCriteria0(v ParamsPropertyInfraMetricThresholdCriteria0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsParamsPropertyInfraMetricThresholdCriteria1 returns the union data inside the ParamsPropertyInfraMetricThreshold_Criteria_Item as a ParamsPropertyInfraMetricThresholdCriteria1
func (t ParamsPropertyInfraMetricThreshold_Criteria_Item) AsParamsPropertyInfraMetricThresholdCriteria1() (ParamsPropertyInfraMetricThresholdCriteria1, error) {
	var body ParamsPropertyInfraMetricThresholdCriteria1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromParamsPropertyInfraMetricThresholdCriteria1 overwrites any union data inside the ParamsPropertyInfraMetricThreshold_Criteria_Item as the provided ParamsPropertyInfraMetricThresholdCriteria1
func (t *ParamsPropertyInfraMetricThreshold_Criteria_Item) FromParamsPropertyInfraMetricThresholdCriteria1(v ParamsPropertyInfraMetricThresholdCriteria1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeParamsPropertyInfraMetricThresholdCriteria1 performs a merge with any union data inside the ParamsPropertyInfraMetricThreshold_Criteria_Item, using the provided ParamsPropertyInfraMetricThresholdCriteria1
func (t *ParamsPropertyInfraMetricThreshold_Criteria_Item) MergeParamsPropertyInfraMetricThresholdCriteria1(v ParamsPropertyInfraMetricThresholdCriteria1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsParamsPropertyInfraMetricThresholdCriteria2 returns the union data inside the ParamsPropertyInfraMetricThreshold_Criteria_Item as a ParamsPropertyInfraMetricThresholdCriteria2
func (t ParamsPropertyInfraMetricThreshold_Criteria_Item) AsParamsPropertyInfraMetricThresholdCriteria2() (ParamsPropertyInfraMetricThresholdCriteria2, error) {
	var body ParamsPropertyInfraMetricThresholdCriteria2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromParamsPropertyInfraMetricThresholdCriteria2 overwrites any union data inside the ParamsPropertyInfraMetricThreshold_Criteria_Item as the provided ParamsPropertyInfraMetricThresholdCriteria2
func (t *ParamsPropertyInfraMetricThreshold_Criteria_Item) FromParamsPropertyInfraMetricThresholdCriteria2(v ParamsPropertyInfraMetricThresholdCriteria2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeParamsPropertyInfraMetricThresholdCriteria2 performs a merge with any union data inside the ParamsPropertyInfraMetricThreshold_Criteria_Item, using the provided ParamsPropertyInfraMetricThresholdCriteria2
func (t *ParamsPropertyInfraMetricThreshold_Criteria_Item) MergeParamsPropertyInfraMetricThresholdCriteria2(v ParamsPropertyInfraMetricThresholdCriteria2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ParamsPropertyInfraMetricThreshold_Criteria_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ParamsPropertyInfraMetricThreshold_Criteria_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsParamsPropertyInfraMetricThresholdGroupBy0 returns the union data inside the ParamsPropertyInfraMetricThreshold_GroupBy as a ParamsPropertyInfraMetricThresholdGroupBy0
func (t ParamsPropertyInfraMetricThreshold_GroupBy) AsParamsPropertyInfraMetricThresholdGroupBy0() (ParamsPropertyInfraMetricThresholdGroupBy0, error) {
	var body ParamsPropertyInfraMetricThresholdGroupBy0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromParamsPropertyInfraMetricThresholdGroupBy0 overwrites any union data inside the ParamsPropertyInfraMetricThreshold_GroupBy as the provided ParamsPropertyInfraMetricThresholdGroupBy0
func (t *ParamsPropertyInfraMetricThreshold_GroupBy) FromParamsPropertyInfraMetricThresholdGroupBy0(v ParamsPropertyInfraMetricThresholdGroupBy0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeParamsPropertyInfraMetricThresholdGroupBy0 performs a merge with any union data inside the ParamsPropertyInfraMetricThreshold_GroupBy, using the provided ParamsPropertyInfraMetricThresholdGroupBy0
func (t *ParamsPropertyInfraMetricThreshold_GroupBy) MergeParamsPropertyInfraMetricThresholdGroupBy0(v ParamsPropertyInfraMetricThresholdGroupBy0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsParamsPropertyInfraMetricThresholdGroupBy1 returns the union data inside the ParamsPropertyInfraMetricThreshold_GroupBy as a ParamsPropertyInfraMetricThresholdGroupBy1
func (t ParamsPropertyInfraMetricThreshold_GroupBy) AsParamsPropertyInfraMetricThresholdGroupBy1() (ParamsPropertyInfraMetricThresholdGroupBy1, error) {
	var body ParamsPropertyInfraMetricThresholdGroupBy1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromParamsPropertyInfraMetricThresholdGroupBy1 overwrites any union data inside the ParamsPropertyInfraMetricThreshold_GroupBy as the provided ParamsPropertyInfraMetricThresholdGroupBy1
func (t *ParamsPropertyInfraMetricThreshold_GroupBy) FromParamsPropertyInfraMetricThresholdGroupBy1(v ParamsPropertyInfraMetricThresholdGroupBy1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeParamsPropertyInfraMetricThresholdGroupBy1 performs a merge with any union data inside the ParamsPropertyInfraMetricThreshold_GroupBy, using the provided ParamsPropertyInfraMetricThresholdGroupBy1
func (t *ParamsPropertyInfraMetricThreshold_GroupBy) MergeParamsPropertyInfraMetricThresholdGroupBy1(v ParamsPropertyInfraMetricThresholdGroupBy1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ParamsPropertyInfraMetricThreshold_GroupBy) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ParamsPropertyInfraMetricThreshold_GroupBy) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsParamsPropertyLogThreshold0 returns the union data inside the ParamsPropertyLogThreshold as a ParamsPropertyLogThreshold0
func (t ParamsPropertyLogThreshold) AsParamsPropertyLogThreshold0() (ParamsPropertyLogThreshold0, error) {
	var body ParamsPropertyLogThreshold0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromParamsPropertyLogThreshold0 overwrites any union data inside the ParamsPropertyLogThreshold as the provided ParamsPropertyLogThreshold0
func (t *ParamsPropertyLogThreshold) FromParamsPropertyLogThreshold0(v ParamsPropertyLogThreshold0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeParamsPropertyLogThreshold0 performs a merge with any union data inside the ParamsPropertyLogThreshold, using the provided ParamsPropertyLogThreshold0
func (t *ParamsPropertyLogThreshold) MergeParamsPropertyLogThreshold0(v ParamsPropertyLogThreshold0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsParamsPropertyLogThreshold1 returns the union data inside the ParamsPropertyLogThreshold as a ParamsPropertyLogThreshold1
func (t ParamsPropertyLogThreshold) AsParamsPropertyLogThreshold1() (ParamsPropertyLogThreshold1, error) {
	var body ParamsPropertyLogThreshold1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromParamsPropertyLogThreshold1 overwrites any union data inside the ParamsPropertyLogThreshold as the provided ParamsPropertyLogThreshold1
func (t *ParamsPropertyLogThreshold) FromParamsPropertyLogThreshold1(v ParamsPropertyLogThreshold1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeParamsPropertyLogThreshold1 performs a merge with any union data inside the ParamsPropertyLogThreshold, using the provided ParamsPropertyLogThreshold1
func (t *ParamsPropertyLogThreshold) MergeParamsPropertyLogThreshold1(v ParamsPropertyLogThreshold1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ParamsPropertyLogThreshold) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ParamsPropertyLogThreshold) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsParamsPropertyLogThreshold0CriteriaValue0 returns the union data inside the ParamsPropertyLogThreshold_0_Criteria_Value as a ParamsPropertyLogThreshold0CriteriaValue0
func (t ParamsPropertyLogThreshold_0_Criteria_Value) AsParamsPropertyLogThreshold0CriteriaValue0() (ParamsPropertyLogThreshold0CriteriaValue0, error) {
	var body ParamsPropertyLogThreshold0CriteriaValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromParamsPropertyLogThreshold0CriteriaValue0 overwrites any union data inside the ParamsPropertyLogThreshold_0_Criteria_Value as the provided ParamsPropertyLogThreshold0CriteriaValue0
func (t *ParamsPropertyLogThreshold_0_Criteria_Value) FromParamsPropertyLogThreshold0CriteriaValue0(v ParamsPropertyLogThreshold0CriteriaValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeParamsPropertyLogThreshold0CriteriaValue0 performs a merge with any union data inside the ParamsPropertyLogThreshold_0_Criteria_Value, using the provided ParamsPropertyLogThreshold0CriteriaValue0
func (t *ParamsPropertyLogThreshold_0_Criteria_Value) MergeParamsPropertyLogThreshold0CriteriaValue0(v ParamsPropertyLogThreshold0CriteriaValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsParamsPropertyLogThreshold0CriteriaValue1 returns the union data inside the ParamsPropertyLogThreshold_0_Criteria_Value as a ParamsPropertyLogThreshold0CriteriaValue1
func (t ParamsPropertyLogThreshold_0_Criteria_Value) AsParamsPropertyLogThreshold0CriteriaValue1() (ParamsPropertyLogThreshold0CriteriaValue1, error) {
	var body ParamsPropertyLogThreshold0CriteriaValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromParamsPropertyLogThreshold0CriteriaValue1 overwrites any union data inside the ParamsPropertyLogThreshold_0_Criteria_Value as the provided ParamsPropertyLogThreshold0CriteriaValue1
func (t *ParamsPropertyLogThreshold_0_Criteria_Value) FromParamsPropertyLogThreshold0CriteriaValue1(v ParamsPropertyLogThreshold0CriteriaValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeParamsPropertyLogThreshold0CriteriaValue1 performs a merge with any union data inside the ParamsPropertyLogThreshold_0_Criteria_Value, using the provided ParamsPropertyLogThreshold0CriteriaValue1
func (t *ParamsPropertyLogThreshold_0_Criteria_Value) MergeParamsPropertyLogThreshold0CriteriaValue1(v ParamsPropertyLogThreshold0CriteriaValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ParamsPropertyLogThreshold_0_Criteria_Value) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ParamsPropertyLogThreshold_0_Criteria_Value) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsParamsPropertyLogThreshold1CriteriaValue0 returns the union data inside the ParamsPropertyLogThreshold_1_Criteria_Value as a ParamsPropertyLogThreshold1CriteriaValue0
func (t ParamsPropertyLogThreshold_1_Criteria_Value) AsParamsPropertyLogThreshold1CriteriaValue0() (ParamsPropertyLogThreshold1CriteriaValue0, error) {
	var body ParamsPropertyLogThreshold1CriteriaValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromParamsPropertyLogThreshold1CriteriaValue0 overwrites any union data inside the ParamsPropertyLogThreshold_1_Criteria_Value as the provided ParamsPropertyLogThreshold1CriteriaValue0
func (t *ParamsPropertyLogThreshold_1_Criteria_Value) FromParamsPropertyLogThreshold1CriteriaValue0(v ParamsPropertyLogThreshold1CriteriaValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeParamsPropertyLogThreshold1CriteriaValue0 performs a merge with any union data inside the ParamsPropertyLogThreshold_1_Criteria_Value, using the provided ParamsPropertyLogThreshold1CriteriaValue0
func (t *ParamsPropertyLogThreshold_1_Criteria_Value) MergeParamsPropertyLogThreshold1CriteriaValue0(v ParamsPropertyLogThreshold1CriteriaValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsParamsPropertyLogThreshold1CriteriaValue1 returns the union data inside the ParamsPropertyLogThreshold_1_Criteria_Value as a ParamsPropertyLogThreshold1CriteriaValue1
func (t ParamsPropertyLogThreshold_1_Criteria_Value) AsParamsPropertyLogThreshold1CriteriaValue1() (ParamsPropertyLogThreshold1CriteriaValue1, error) {
	var body ParamsPropertyLogThreshold1CriteriaValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromParamsPropertyLogThreshold1CriteriaValue1 overwrites any union data inside the ParamsPropertyLogThreshold_1_Criteria_Value as the provided ParamsPropertyLogThreshold1CriteriaValue1
func (t *ParamsPropertyLogThreshold_1_Criteria_Value) FromParamsPropertyLogThreshold1CriteriaValue1(v ParamsPropertyLogThreshold1CriteriaValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeParamsPropertyLogThreshold1CriteriaValue1 performs a merge with any union data inside the ParamsPropertyLogThreshold_1_Criteria_Value, using the provided ParamsPropertyLogThreshold1CriteriaValue1
func (t *ParamsPropertyLogThreshold_1_Criteria_Value) MergeParamsPropertyLogThreshold1CriteriaValue1(v ParamsPropertyLogThreshold1CriteriaValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ParamsPropertyLogThreshold_1_Criteria_Value) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ParamsPropertyLogThreshold_1_Criteria_Value) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsParamsPropertySyntheticsMonitorStatusFilters0 returns the union data inside the ParamsPropertySyntheticsMonitorStatus_Filters as a ParamsPropertySyntheticsMonitorStatusFilters0
func (t ParamsPropertySyntheticsMonitorStatus_Filters) AsParamsPropertySyntheticsMonitorStatusFilters0() (ParamsPropertySyntheticsMonitorStatusFilters0, error) {
	var body ParamsPropertySyntheticsMonitorStatusFilters0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromParamsPropertySyntheticsMonitorStatusFilters0 overwrites any union data inside the ParamsPropertySyntheticsMonitorStatus_Filters as the provided ParamsPropertySyntheticsMonitorStatusFilters0
func (t *ParamsPropertySyntheticsMonitorStatus_Filters) FromParamsPropertySyntheticsMonitorStatusFilters0(v ParamsPropertySyntheticsMonitorStatusFilters0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeParamsPropertySyntheticsMonitorStatusFilters0 performs a merge with any union data inside the ParamsPropertySyntheticsMonitorStatus_Filters, using the provided ParamsPropertySyntheticsMonitorStatusFilters0
func (t *ParamsPropertySyntheticsMonitorStatus_Filters) MergeParamsPropertySyntheticsMonitorStatusFilters0(v ParamsPropertySyntheticsMonitorStatusFilters0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsParamsPropertySyntheticsMonitorStatusFilters1 returns the union data inside the ParamsPropertySyntheticsMonitorStatus_Filters as a ParamsPropertySyntheticsMonitorStatusFilters1
func (t ParamsPropertySyntheticsMonitorStatus_Filters) AsParamsPropertySyntheticsMonitorStatusFilters1() (ParamsPropertySyntheticsMonitorStatusFilters1, error) {
	var body ParamsPropertySyntheticsMonitorStatusFilters1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromParamsPropertySyntheticsMonitorStatusFilters1 overwrites any union data inside the ParamsPropertySyntheticsMonitorStatus_Filters as the provided ParamsPropertySyntheticsMonitorStatusFilters1
func (t *ParamsPropertySyntheticsMonitorStatus_Filters) FromParamsPropertySyntheticsMonitorStatusFilters1(v ParamsPropertySyntheticsMonitorStatusFilters1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeParamsPropertySyntheticsMonitorStatusFilters1 performs a merge with any union data inside the ParamsPropertySyntheticsMonitorStatus_Filters, using the provided ParamsPropertySyntheticsMonitorStatusFilters1
func (t *ParamsPropertySyntheticsMonitorStatus_Filters) MergeParamsPropertySyntheticsMonitorStatusFilters1(v ParamsPropertySyntheticsMonitorStatusFilters1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ParamsPropertySyntheticsMonitorStatus_Filters) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ParamsPropertySyntheticsMonitorStatus_Filters) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsIndicatorPropertiesCustomKql returns the union data inside the SloDefinitionResponse_Indicator as a IndicatorPropertiesCustomKql
func (t SloDefinitionResponse_Indicator) AsIndicatorPropertiesCustomKql() (IndicatorPropertiesCustomKql, error) {
	var body IndicatorPropertiesCustomKql
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndicatorPropertiesCustomKql overwrites any union data inside the SloDefinitionResponse_Indicator as the provided IndicatorPropertiesCustomKql
func (t *SloDefinitionResponse_Indicator) FromIndicatorPropertiesCustomKql(v IndicatorPropertiesCustomKql) error {
	v.Type = "sli.kql.custom"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndicatorPropertiesCustomKql performs a merge with any union data inside the SloDefinitionResponse_Indicator, using the provided IndicatorPropertiesCustomKql
func (t *SloDefinitionResponse_Indicator) MergeIndicatorPropertiesCustomKql(v IndicatorPropertiesCustomKql) error {
	v.Type = "sli.kql.custom"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIndicatorPropertiesApmAvailability returns the union data inside the SloDefinitionResponse_Indicator as a IndicatorPropertiesApmAvailability
func (t SloDefinitionResponse_Indicator) AsIndicatorPropertiesApmAvailability() (IndicatorPropertiesApmAvailability, error) {
	var body IndicatorPropertiesApmAvailability
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndicatorPropertiesApmAvailability overwrites any union data inside the SloDefinitionResponse_Indicator as the provided IndicatorPropertiesApmAvailability
func (t *SloDefinitionResponse_Indicator) FromIndicatorPropertiesApmAvailability(v IndicatorPropertiesApmAvailability) error {
	v.Type = "sli.apm.transactionErrorRate"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndicatorPropertiesApmAvailability performs a merge with any union data inside the SloDefinitionResponse_Indicator, using the provided IndicatorPropertiesApmAvailability
func (t *SloDefinitionResponse_Indicator) MergeIndicatorPropertiesApmAvailability(v IndicatorPropertiesApmAvailability) error {
	v.Type = "sli.apm.transactionErrorRate"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIndicatorPropertiesApmLatency returns the union data inside the SloDefinitionResponse_Indicator as a IndicatorPropertiesApmLatency
func (t SloDefinitionResponse_Indicator) AsIndicatorPropertiesApmLatency() (IndicatorPropertiesApmLatency, error) {
	var body IndicatorPropertiesApmLatency
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndicatorPropertiesApmLatency overwrites any union data inside the SloDefinitionResponse_Indicator as the provided IndicatorPropertiesApmLatency
func (t *SloDefinitionResponse_Indicator) FromIndicatorPropertiesApmLatency(v IndicatorPropertiesApmLatency) error {
	v.Type = "sli.apm.transactionDuration"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndicatorPropertiesApmLatency performs a merge with any union data inside the SloDefinitionResponse_Indicator, using the provided IndicatorPropertiesApmLatency
func (t *SloDefinitionResponse_Indicator) MergeIndicatorPropertiesApmLatency(v IndicatorPropertiesApmLatency) error {
	v.Type = "sli.apm.transactionDuration"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIndicatorPropertiesCustomMetric returns the union data inside the SloDefinitionResponse_Indicator as a IndicatorPropertiesCustomMetric
func (t SloDefinitionResponse_Indicator) AsIndicatorPropertiesCustomMetric() (IndicatorPropertiesCustomMetric, error) {
	var body IndicatorPropertiesCustomMetric
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndicatorPropertiesCustomMetric overwrites any union data inside the SloDefinitionResponse_Indicator as the provided IndicatorPropertiesCustomMetric
func (t *SloDefinitionResponse_Indicator) FromIndicatorPropertiesCustomMetric(v IndicatorPropertiesCustomMetric) error {
	v.Type = "sli.metric.custom"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndicatorPropertiesCustomMetric performs a merge with any union data inside the SloDefinitionResponse_Indicator, using the provided IndicatorPropertiesCustomMetric
func (t *SloDefinitionResponse_Indicator) MergeIndicatorPropertiesCustomMetric(v IndicatorPropertiesCustomMetric) error {
	v.Type = "sli.metric.custom"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIndicatorPropertiesHistogram returns the union data inside the SloDefinitionResponse_Indicator as a IndicatorPropertiesHistogram
func (t SloDefinitionResponse_Indicator) AsIndicatorPropertiesHistogram() (IndicatorPropertiesHistogram, error) {
	var body IndicatorPropertiesHistogram
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndicatorPropertiesHistogram overwrites any union data inside the SloDefinitionResponse_Indicator as the provided IndicatorPropertiesHistogram
func (t *SloDefinitionResponse_Indicator) FromIndicatorPropertiesHistogram(v IndicatorPropertiesHistogram) error {
	v.Type = "sli.histogram.custom"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndicatorPropertiesHistogram performs a merge with any union data inside the SloDefinitionResponse_Indicator, using the provided IndicatorPropertiesHistogram
func (t *SloDefinitionResponse_Indicator) MergeIndicatorPropertiesHistogram(v IndicatorPropertiesHistogram) error {
	v.Type = "sli.histogram.custom"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIndicatorPropertiesTimesliceMetric returns the union data inside the SloDefinitionResponse_Indicator as a IndicatorPropertiesTimesliceMetric
func (t SloDefinitionResponse_Indicator) AsIndicatorPropertiesTimesliceMetric() (IndicatorPropertiesTimesliceMetric, error) {
	var body IndicatorPropertiesTimesliceMetric
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndicatorPropertiesTimesliceMetric overwrites any union data inside the SloDefinitionResponse_Indicator as the provided IndicatorPropertiesTimesliceMetric
func (t *SloDefinitionResponse_Indicator) FromIndicatorPropertiesTimesliceMetric(v IndicatorPropertiesTimesliceMetric) error {
	v.Type = "sli.metric.timeslice"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndicatorPropertiesTimesliceMetric performs a merge with any union data inside the SloDefinitionResponse_Indicator, using the provided IndicatorPropertiesTimesliceMetric
func (t *SloDefinitionResponse_Indicator) MergeIndicatorPropertiesTimesliceMetric(v IndicatorPropertiesTimesliceMetric) error {
	v.Type = "sli.metric.timeslice"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SloDefinitionResponse_Indicator) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t SloDefinitionResponse_Indicator) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "sli.apm.transactionDuration":
		return t.AsIndicatorPropertiesApmLatency()
	case "sli.apm.transactionErrorRate":
		return t.AsIndicatorPropertiesApmAvailability()
	case "sli.histogram.custom":
		return t.AsIndicatorPropertiesHistogram()
	case "sli.kql.custom":
		return t.AsIndicatorPropertiesCustomKql()
	case "sli.metric.custom":
		return t.AsIndicatorPropertiesCustomMetric()
	case "sli.metric.timeslice":
		return t.AsIndicatorPropertiesTimesliceMetric()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t SloDefinitionResponse_Indicator) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SloDefinitionResponse_Indicator) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsIndicatorPropertiesCustomKql returns the union data inside the SloWithSummaryResponse_Indicator as a IndicatorPropertiesCustomKql
func (t SloWithSummaryResponse_Indicator) AsIndicatorPropertiesCustomKql() (IndicatorPropertiesCustomKql, error) {
	var body IndicatorPropertiesCustomKql
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndicatorPropertiesCustomKql overwrites any union data inside the SloWithSummaryResponse_Indicator as the provided IndicatorPropertiesCustomKql
func (t *SloWithSummaryResponse_Indicator) FromIndicatorPropertiesCustomKql(v IndicatorPropertiesCustomKql) error {
	v.Type = "sli.kql.custom"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndicatorPropertiesCustomKql performs a merge with any union data inside the SloWithSummaryResponse_Indicator, using the provided IndicatorPropertiesCustomKql
func (t *SloWithSummaryResponse_Indicator) MergeIndicatorPropertiesCustomKql(v IndicatorPropertiesCustomKql) error {
	v.Type = "sli.kql.custom"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIndicatorPropertiesApmAvailability returns the union data inside the SloWithSummaryResponse_Indicator as a IndicatorPropertiesApmAvailability
func (t SloWithSummaryResponse_Indicator) AsIndicatorPropertiesApmAvailability() (IndicatorPropertiesApmAvailability, error) {
	var body IndicatorPropertiesApmAvailability
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndicatorPropertiesApmAvailability overwrites any union data inside the SloWithSummaryResponse_Indicator as the provided IndicatorPropertiesApmAvailability
func (t *SloWithSummaryResponse_Indicator) FromIndicatorPropertiesApmAvailability(v IndicatorPropertiesApmAvailability) error {
	v.Type = "sli.apm.transactionErrorRate"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndicatorPropertiesApmAvailability performs a merge with any union data inside the SloWithSummaryResponse_Indicator, using the provided IndicatorPropertiesApmAvailability
func (t *SloWithSummaryResponse_Indicator) MergeIndicatorPropertiesApmAvailability(v IndicatorPropertiesApmAvailability) error {
	v.Type = "sli.apm.transactionErrorRate"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIndicatorPropertiesApmLatency returns the union data inside the SloWithSummaryResponse_Indicator as a IndicatorPropertiesApmLatency
func (t SloWithSummaryResponse_Indicator) AsIndicatorPropertiesApmLatency() (IndicatorPropertiesApmLatency, error) {
	var body IndicatorPropertiesApmLatency
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndicatorPropertiesApmLatency overwrites any union data inside the SloWithSummaryResponse_Indicator as the provided IndicatorPropertiesApmLatency
func (t *SloWithSummaryResponse_Indicator) FromIndicatorPropertiesApmLatency(v IndicatorPropertiesApmLatency) error {
	v.Type = "sli.apm.transactionDuration"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndicatorPropertiesApmLatency performs a merge with any union data inside the SloWithSummaryResponse_Indicator, using the provided IndicatorPropertiesApmLatency
func (t *SloWithSummaryResponse_Indicator) MergeIndicatorPropertiesApmLatency(v IndicatorPropertiesApmLatency) error {
	v.Type = "sli.apm.transactionDuration"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIndicatorPropertiesCustomMetric returns the union data inside the SloWithSummaryResponse_Indicator as a IndicatorPropertiesCustomMetric
func (t SloWithSummaryResponse_Indicator) AsIndicatorPropertiesCustomMetric() (IndicatorPropertiesCustomMetric, error) {
	var body IndicatorPropertiesCustomMetric
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndicatorPropertiesCustomMetric overwrites any union data inside the SloWithSummaryResponse_Indicator as the provided IndicatorPropertiesCustomMetric
func (t *SloWithSummaryResponse_Indicator) FromIndicatorPropertiesCustomMetric(v IndicatorPropertiesCustomMetric) error {
	v.Type = "sli.metric.custom"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndicatorPropertiesCustomMetric performs a merge with any union data inside the SloWithSummaryResponse_Indicator, using the provided IndicatorPropertiesCustomMetric
func (t *SloWithSummaryResponse_Indicator) MergeIndicatorPropertiesCustomMetric(v IndicatorPropertiesCustomMetric) error {
	v.Type = "sli.metric.custom"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIndicatorPropertiesHistogram returns the union data inside the SloWithSummaryResponse_Indicator as a IndicatorPropertiesHistogram
func (t SloWithSummaryResponse_Indicator) AsIndicatorPropertiesHistogram() (IndicatorPropertiesHistogram, error) {
	var body IndicatorPropertiesHistogram
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndicatorPropertiesHistogram overwrites any union data inside the SloWithSummaryResponse_Indicator as the provided IndicatorPropertiesHistogram
func (t *SloWithSummaryResponse_Indicator) FromIndicatorPropertiesHistogram(v IndicatorPropertiesHistogram) error {
	v.Type = "sli.histogram.custom"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndicatorPropertiesHistogram performs a merge with any union data inside the SloWithSummaryResponse_Indicator, using the provided IndicatorPropertiesHistogram
func (t *SloWithSummaryResponse_Indicator) MergeIndicatorPropertiesHistogram(v IndicatorPropertiesHistogram) error {
	v.Type = "sli.histogram.custom"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIndicatorPropertiesTimesliceMetric returns the union data inside the SloWithSummaryResponse_Indicator as a IndicatorPropertiesTimesliceMetric
func (t SloWithSummaryResponse_Indicator) AsIndicatorPropertiesTimesliceMetric() (IndicatorPropertiesTimesliceMetric, error) {
	var body IndicatorPropertiesTimesliceMetric
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndicatorPropertiesTimesliceMetric overwrites any union data inside the SloWithSummaryResponse_Indicator as the provided IndicatorPropertiesTimesliceMetric
func (t *SloWithSummaryResponse_Indicator) FromIndicatorPropertiesTimesliceMetric(v IndicatorPropertiesTimesliceMetric) error {
	v.Type = "sli.metric.timeslice"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndicatorPropertiesTimesliceMetric performs a merge with any union data inside the SloWithSummaryResponse_Indicator, using the provided IndicatorPropertiesTimesliceMetric
func (t *SloWithSummaryResponse_Indicator) MergeIndicatorPropertiesTimesliceMetric(v IndicatorPropertiesTimesliceMetric) error {
	v.Type = "sli.metric.timeslice"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SloWithSummaryResponse_Indicator) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t SloWithSummaryResponse_Indicator) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "sli.apm.transactionDuration":
		return t.AsIndicatorPropertiesApmLatency()
	case "sli.apm.transactionErrorRate":
		return t.AsIndicatorPropertiesApmAvailability()
	case "sli.histogram.custom":
		return t.AsIndicatorPropertiesHistogram()
	case "sli.kql.custom":
		return t.AsIndicatorPropertiesCustomKql()
	case "sli.metric.custom":
		return t.AsIndicatorPropertiesCustomMetric()
	case "sli.metric.timeslice":
		return t.AsIndicatorPropertiesTimesliceMetric()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t SloWithSummaryResponse_Indicator) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SloWithSummaryResponse_Indicator) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTermfield0 returns the union data inside the Termfield as a Termfield0
func (t Termfield) AsTermfield0() (Termfield0, error) {
	var body Termfield0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTermfield0 overwrites any union data inside the Termfield as the provided Termfield0
func (t *Termfield) FromTermfield0(v Termfield0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTermfield0 performs a merge with any union data inside the Termfield, using the provided Termfield0
func (t *Termfield) MergeTermfield0(v Termfield0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTermfield1 returns the union data inside the Termfield as a Termfield1
func (t Termfield) AsTermfield1() (Termfield1, error) {
	var body Termfield1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTermfield1 overwrites any union data inside the Termfield as the provided Termfield1
func (t *Termfield) FromTermfield1(v Termfield1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTermfield1 performs a merge with any union data inside the Termfield, using the provided Termfield1
func (t *Termfield) MergeTermfield1(v Termfield1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Termfield) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Termfield) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsIndicatorPropertiesCustomKql returns the union data inside the UpdateSloRequest_Indicator as a IndicatorPropertiesCustomKql
func (t UpdateSloRequest_Indicator) AsIndicatorPropertiesCustomKql() (IndicatorPropertiesCustomKql, error) {
	var body IndicatorPropertiesCustomKql
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndicatorPropertiesCustomKql overwrites any union data inside the UpdateSloRequest_Indicator as the provided IndicatorPropertiesCustomKql
func (t *UpdateSloRequest_Indicator) FromIndicatorPropertiesCustomKql(v IndicatorPropertiesCustomKql) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndicatorPropertiesCustomKql performs a merge with any union data inside the UpdateSloRequest_Indicator, using the provided IndicatorPropertiesCustomKql
func (t *UpdateSloRequest_Indicator) MergeIndicatorPropertiesCustomKql(v IndicatorPropertiesCustomKql) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIndicatorPropertiesApmAvailability returns the union data inside the UpdateSloRequest_Indicator as a IndicatorPropertiesApmAvailability
func (t UpdateSloRequest_Indicator) AsIndicatorPropertiesApmAvailability() (IndicatorPropertiesApmAvailability, error) {
	var body IndicatorPropertiesApmAvailability
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndicatorPropertiesApmAvailability overwrites any union data inside the UpdateSloRequest_Indicator as the provided IndicatorPropertiesApmAvailability
func (t *UpdateSloRequest_Indicator) FromIndicatorPropertiesApmAvailability(v IndicatorPropertiesApmAvailability) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndicatorPropertiesApmAvailability performs a merge with any union data inside the UpdateSloRequest_Indicator, using the provided IndicatorPropertiesApmAvailability
func (t *UpdateSloRequest_Indicator) MergeIndicatorPropertiesApmAvailability(v IndicatorPropertiesApmAvailability) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIndicatorPropertiesApmLatency returns the union data inside the UpdateSloRequest_Indicator as a IndicatorPropertiesApmLatency
func (t UpdateSloRequest_Indicator) AsIndicatorPropertiesApmLatency() (IndicatorPropertiesApmLatency, error) {
	var body IndicatorPropertiesApmLatency
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndicatorPropertiesApmLatency overwrites any union data inside the UpdateSloRequest_Indicator as the provided IndicatorPropertiesApmLatency
func (t *UpdateSloRequest_Indicator) FromIndicatorPropertiesApmLatency(v IndicatorPropertiesApmLatency) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndicatorPropertiesApmLatency performs a merge with any union data inside the UpdateSloRequest_Indicator, using the provided IndicatorPropertiesApmLatency
func (t *UpdateSloRequest_Indicator) MergeIndicatorPropertiesApmLatency(v IndicatorPropertiesApmLatency) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIndicatorPropertiesCustomMetric returns the union data inside the UpdateSloRequest_Indicator as a IndicatorPropertiesCustomMetric
func (t UpdateSloRequest_Indicator) AsIndicatorPropertiesCustomMetric() (IndicatorPropertiesCustomMetric, error) {
	var body IndicatorPropertiesCustomMetric
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndicatorPropertiesCustomMetric overwrites any union data inside the UpdateSloRequest_Indicator as the provided IndicatorPropertiesCustomMetric
func (t *UpdateSloRequest_Indicator) FromIndicatorPropertiesCustomMetric(v IndicatorPropertiesCustomMetric) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndicatorPropertiesCustomMetric performs a merge with any union data inside the UpdateSloRequest_Indicator, using the provided IndicatorPropertiesCustomMetric
func (t *UpdateSloRequest_Indicator) MergeIndicatorPropertiesCustomMetric(v IndicatorPropertiesCustomMetric) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIndicatorPropertiesHistogram returns the union data inside the UpdateSloRequest_Indicator as a IndicatorPropertiesHistogram
func (t UpdateSloRequest_Indicator) AsIndicatorPropertiesHistogram() (IndicatorPropertiesHistogram, error) {
	var body IndicatorPropertiesHistogram
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndicatorPropertiesHistogram overwrites any union data inside the UpdateSloRequest_Indicator as the provided IndicatorPropertiesHistogram
func (t *UpdateSloRequest_Indicator) FromIndicatorPropertiesHistogram(v IndicatorPropertiesHistogram) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndicatorPropertiesHistogram performs a merge with any union data inside the UpdateSloRequest_Indicator, using the provided IndicatorPropertiesHistogram
func (t *UpdateSloRequest_Indicator) MergeIndicatorPropertiesHistogram(v IndicatorPropertiesHistogram) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIndicatorPropertiesTimesliceMetric returns the union data inside the UpdateSloRequest_Indicator as a IndicatorPropertiesTimesliceMetric
func (t UpdateSloRequest_Indicator) AsIndicatorPropertiesTimesliceMetric() (IndicatorPropertiesTimesliceMetric, error) {
	var body IndicatorPropertiesTimesliceMetric
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndicatorPropertiesTimesliceMetric overwrites any union data inside the UpdateSloRequest_Indicator as the provided IndicatorPropertiesTimesliceMetric
func (t *UpdateSloRequest_Indicator) FromIndicatorPropertiesTimesliceMetric(v IndicatorPropertiesTimesliceMetric) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndicatorPropertiesTimesliceMetric performs a merge with any union data inside the UpdateSloRequest_Indicator, using the provided IndicatorPropertiesTimesliceMetric
func (t *UpdateSloRequest_Indicator) MergeIndicatorPropertiesTimesliceMetric(v IndicatorPropertiesTimesliceMetric) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UpdateSloRequest_Indicator) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UpdateSloRequest_Indicator) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// AgentPolicyList request
	AgentPolicyList(ctx context.Context, params *AgentPolicyListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAgentPolicyWithBody request with any body
	CreateAgentPolicyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAgentPolicy(ctx context.Context, body CreateAgentPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAgentPolicyWithBody request with any body
	DeleteAgentPolicyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteAgentPolicy(ctx context.Context, body DeleteAgentPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AgentPolicyInfo request
	AgentPolicyInfo(ctx context.Context, agentPolicyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAgentPolicyWithBody request with any body
	UpdateAgentPolicyWithBody(ctx context.Context, agentPolicyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAgentPolicy(ctx context.Context, agentPolicyId string, body UpdateAgentPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRuleWithBody request with any body
	CreateRuleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRule(ctx context.Context, body CreateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRule request
	DeleteRule(ctx context.Context, ruleId RuleId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRule request
	GetRule(ctx context.Context, ruleId RuleId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRuleIdWithBody request with any body
	CreateRuleIdWithBody(ctx context.Context, ruleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRuleId(ctx context.Context, ruleId string, body CreateRuleIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRuleWithBody request with any body
	UpdateRuleWithBody(ctx context.Context, ruleId RuleId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRule(ctx context.Context, ruleId RuleId, body UpdateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindRules request
	FindRules(ctx context.Context, params *FindRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllDataViewsDefault request
	GetAllDataViewsDefault(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDataViewDefaultwWithBody request with any body
	CreateDataViewDefaultwWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDataViewDefaultw(ctx context.Context, body CreateDataViewDefaultwJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDataViewDefault request
	DeleteDataViewDefault(ctx context.Context, viewId ViewId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDataViewDefault request
	GetDataViewDefault(ctx context.Context, viewId ViewId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDataViewDefaultWithBody request with any body
	UpdateDataViewDefaultWithBody(ctx context.Context, viewId ViewId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateDataViewDefault(ctx context.Context, viewId ViewId, body UpdateDataViewDefaultJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ImportSavedObjectsDefaultWithBody request with any body
	ImportSavedObjectsDefaultWithBody(ctx context.Context, params *ImportSavedObjectsDefaultParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEnrollmentApiKeys request
	GetEnrollmentApiKeys(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateEnrollmentApiKeys request
	CreateEnrollmentApiKeys(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAllPackages request
	ListAllPackages(ctx context.Context, params *ListAllPackagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InstallPackageByUploadWithBody request with any body
	InstallPackageByUploadWithBody(ctx context.Context, params *InstallPackageByUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePackageWithBody request with any body
	DeletePackageWithBody(ctx context.Context, pkgName string, pkgVersion string, params *DeletePackageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeletePackage(ctx context.Context, pkgName string, pkgVersion string, params *DeletePackageParams, body DeletePackageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPackage request
	GetPackage(ctx context.Context, pkgName string, pkgVersion string, params *GetPackageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InstallPackageWithBody request with any body
	InstallPackageWithBody(ctx context.Context, pkgName string, pkgVersion string, params *InstallPackageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InstallPackage(ctx context.Context, pkgName string, pkgVersion string, params *InstallPackageParams, body InstallPackageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePackageWithBody request with any body
	UpdatePackageWithBody(ctx context.Context, pkgName string, pkgVersion string, params *UpdatePackageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePackage(ctx context.Context, pkgName string, pkgVersion string, params *UpdatePackageParams, body UpdatePackageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFleetServerHosts request
	GetFleetServerHosts(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostFleetServerHostsWithBody request with any body
	PostFleetServerHostsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostFleetServerHosts(ctx context.Context, body PostFleetServerHostsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFleetServerHosts request
	DeleteFleetServerHosts(ctx context.Context, itemId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOneFleetServerHosts request
	GetOneFleetServerHosts(ctx context.Context, itemId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateFleetServerHostsWithBody request with any body
	UpdateFleetServerHostsWithBody(ctx context.Context, itemId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateFleetServerHosts(ctx context.Context, itemId string, body UpdateFleetServerHostsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOutputs request
	GetOutputs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOutputsWithBody request with any body
	PostOutputsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostOutputs(ctx context.Context, body PostOutputsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteOutput request
	DeleteOutput(ctx context.Context, outputId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOutput request
	GetOutput(ctx context.Context, outputId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateOutputWithBody request with any body
	UpdateOutputWithBody(ctx context.Context, outputId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateOutput(ctx context.Context, outputId string, body UpdateOutputJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPackagePolicies request
	GetPackagePolicies(ctx context.Context, params *GetPackagePoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePackagePolicyWithBody request with any body
	CreatePackagePolicyWithBody(ctx context.Context, params *CreatePackagePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePackagePolicy(ctx context.Context, params *CreatePackagePolicyParams, body CreatePackagePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePackagePolicy request
	DeletePackagePolicy(ctx context.Context, packagePolicyId string, params *DeletePackagePolicyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPackagePolicy request
	GetPackagePolicy(ctx context.Context, packagePolicyId string, params *GetPackagePolicyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePackagePolicyWithBody request with any body
	UpdatePackagePolicyWithBody(ctx context.Context, packagePolicyId string, params *UpdatePackagePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePackagePolicy(ctx context.Context, packagePolicyId string, params *UpdatePackagePolicyParams, body UpdatePackagePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindSlosOp request
	FindSlosOp(ctx context.Context, spaceId SpaceId, params *FindSlosOpParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSloOpWithBody request with any body
	CreateSloOpWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSloOp(ctx context.Context, spaceId SpaceId, body CreateSloOpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSloOp request
	DeleteSloOp(ctx context.Context, spaceId SpaceId, sloId SloId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSloOp request
	GetSloOp(ctx context.Context, spaceId SpaceId, sloId SloId, params *GetSloOpParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSloOpWithBody request with any body
	UpdateSloOpWithBody(ctx context.Context, spaceId SpaceId, sloId SloId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSloOp(ctx context.Context, spaceId SpaceId, sloId SloId, body UpdateSloOpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenerateServiceToken request
	GenerateServiceToken(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) AgentPolicyList(ctx context.Context, params *AgentPolicyListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAgentPolicyListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAgentPolicyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAgentPolicyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAgentPolicy(ctx context.Context, body CreateAgentPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAgentPolicyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAgentPolicyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAgentPolicyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAgentPolicy(ctx context.Context, body DeleteAgentPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAgentPolicyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AgentPolicyInfo(ctx context.Context, agentPolicyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAgentPolicyInfoRequest(c.Server, agentPolicyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAgentPolicyWithBody(ctx context.Context, agentPolicyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAgentPolicyRequestWithBody(c.Server, agentPolicyId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAgentPolicy(ctx context.Context, agentPolicyId string, body UpdateAgentPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAgentPolicyRequest(c.Server, agentPolicyId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRuleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRuleRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRule(ctx context.Context, body CreateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRuleRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRule(ctx context.Context, ruleId RuleId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRuleRequest(c.Server, ruleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRule(ctx context.Context, ruleId RuleId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRuleRequest(c.Server, ruleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRuleIdWithBody(ctx context.Context, ruleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRuleIdRequestWithBody(c.Server, ruleId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRuleId(ctx context.Context, ruleId string, body CreateRuleIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRuleIdRequest(c.Server, ruleId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRuleWithBody(ctx context.Context, ruleId RuleId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRuleRequestWithBody(c.Server, ruleId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRule(ctx context.Context, ruleId RuleId, body UpdateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRuleRequest(c.Server, ruleId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindRules(ctx context.Context, params *FindRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindRulesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllDataViewsDefault(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllDataViewsDefaultRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDataViewDefaultwWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDataViewDefaultwRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDataViewDefaultw(ctx context.Context, body CreateDataViewDefaultwJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDataViewDefaultwRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDataViewDefault(ctx context.Context, viewId ViewId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDataViewDefaultRequest(c.Server, viewId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDataViewDefault(ctx context.Context, viewId ViewId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDataViewDefaultRequest(c.Server, viewId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDataViewDefaultWithBody(ctx context.Context, viewId ViewId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDataViewDefaultRequestWithBody(c.Server, viewId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDataViewDefault(ctx context.Context, viewId ViewId, body UpdateDataViewDefaultJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDataViewDefaultRequest(c.Server, viewId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportSavedObjectsDefaultWithBody(ctx context.Context, params *ImportSavedObjectsDefaultParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportSavedObjectsDefaultRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEnrollmentApiKeys(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEnrollmentApiKeysRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEnrollmentApiKeys(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEnrollmentApiKeysRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAllPackages(ctx context.Context, params *ListAllPackagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAllPackagesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InstallPackageByUploadWithBody(ctx context.Context, params *InstallPackageByUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInstallPackageByUploadRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePackageWithBody(ctx context.Context, pkgName string, pkgVersion string, params *DeletePackageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePackageRequestWithBody(c.Server, pkgName, pkgVersion, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePackage(ctx context.Context, pkgName string, pkgVersion string, params *DeletePackageParams, body DeletePackageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePackageRequest(c.Server, pkgName, pkgVersion, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPackage(ctx context.Context, pkgName string, pkgVersion string, params *GetPackageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPackageRequest(c.Server, pkgName, pkgVersion, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InstallPackageWithBody(ctx context.Context, pkgName string, pkgVersion string, params *InstallPackageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInstallPackageRequestWithBody(c.Server, pkgName, pkgVersion, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InstallPackage(ctx context.Context, pkgName string, pkgVersion string, params *InstallPackageParams, body InstallPackageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInstallPackageRequest(c.Server, pkgName, pkgVersion, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePackageWithBody(ctx context.Context, pkgName string, pkgVersion string, params *UpdatePackageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePackageRequestWithBody(c.Server, pkgName, pkgVersion, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePackage(ctx context.Context, pkgName string, pkgVersion string, params *UpdatePackageParams, body UpdatePackageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePackageRequest(c.Server, pkgName, pkgVersion, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFleetServerHosts(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFleetServerHostsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFleetServerHostsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFleetServerHostsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFleetServerHosts(ctx context.Context, body PostFleetServerHostsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFleetServerHostsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFleetServerHosts(ctx context.Context, itemId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFleetServerHostsRequest(c.Server, itemId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOneFleetServerHosts(ctx context.Context, itemId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOneFleetServerHostsRequest(c.Server, itemId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFleetServerHostsWithBody(ctx context.Context, itemId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFleetServerHostsRequestWithBody(c.Server, itemId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFleetServerHosts(ctx context.Context, itemId string, body UpdateFleetServerHostsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFleetServerHostsRequest(c.Server, itemId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOutputs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOutputsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOutputsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOutputsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOutputs(ctx context.Context, body PostOutputsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOutputsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOutput(ctx context.Context, outputId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOutputRequest(c.Server, outputId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOutput(ctx context.Context, outputId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOutputRequest(c.Server, outputId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOutputWithBody(ctx context.Context, outputId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOutputRequestWithBody(c.Server, outputId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOutput(ctx context.Context, outputId string, body UpdateOutputJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOutputRequest(c.Server, outputId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPackagePolicies(ctx context.Context, params *GetPackagePoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPackagePoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePackagePolicyWithBody(ctx context.Context, params *CreatePackagePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePackagePolicyRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePackagePolicy(ctx context.Context, params *CreatePackagePolicyParams, body CreatePackagePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePackagePolicyRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePackagePolicy(ctx context.Context, packagePolicyId string, params *DeletePackagePolicyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePackagePolicyRequest(c.Server, packagePolicyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPackagePolicy(ctx context.Context, packagePolicyId string, params *GetPackagePolicyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPackagePolicyRequest(c.Server, packagePolicyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePackagePolicyWithBody(ctx context.Context, packagePolicyId string, params *UpdatePackagePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePackagePolicyRequestWithBody(c.Server, packagePolicyId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePackagePolicy(ctx context.Context, packagePolicyId string, params *UpdatePackagePolicyParams, body UpdatePackagePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePackagePolicyRequest(c.Server, packagePolicyId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindSlosOp(ctx context.Context, spaceId SpaceId, params *FindSlosOpParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindSlosOpRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSloOpWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSloOpRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSloOp(ctx context.Context, spaceId SpaceId, body CreateSloOpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSloOpRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSloOp(ctx context.Context, spaceId SpaceId, sloId SloId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSloOpRequest(c.Server, spaceId, sloId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSloOp(ctx context.Context, spaceId SpaceId, sloId SloId, params *GetSloOpParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSloOpRequest(c.Server, spaceId, sloId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSloOpWithBody(ctx context.Context, spaceId SpaceId, sloId SloId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSloOpRequestWithBody(c.Server, spaceId, sloId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSloOp(ctx context.Context, spaceId SpaceId, sloId SloId, body UpdateSloOpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSloOpRequest(c.Server, spaceId, sloId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateServiceToken(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateServiceTokenRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewAgentPolicyListRequest generates requests for AgentPolicyList
func NewAgentPolicyListRequest(server string, params *AgentPolicyListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/agent_policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Kuery != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kuery", runtime.ParamLocationQuery, *params.Kuery); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Full != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full", runtime.ParamLocationQuery, *params.Full); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NoAgentCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "noAgentCount", runtime.ParamLocationQuery, *params.NoAgentCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAgentPolicyRequest calls the generic CreateAgentPolicy builder with application/json body
func NewCreateAgentPolicyRequest(server string, body CreateAgentPolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAgentPolicyRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAgentPolicyRequestWithBody generates requests for CreateAgentPolicy with any type of body
func NewCreateAgentPolicyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/agent_policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAgentPolicyRequest calls the generic DeleteAgentPolicy builder with application/json body
func NewDeleteAgentPolicyRequest(server string, body DeleteAgentPolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteAgentPolicyRequestWithBody(server, "application/json", bodyReader)
}

// NewDeleteAgentPolicyRequestWithBody generates requests for DeleteAgentPolicy with any type of body
func NewDeleteAgentPolicyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/agent_policies/delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAgentPolicyInfoRequest generates requests for AgentPolicyInfo
func NewAgentPolicyInfoRequest(server string, agentPolicyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "agentPolicyId", runtime.ParamLocationPath, agentPolicyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/agent_policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAgentPolicyRequest calls the generic UpdateAgentPolicy builder with application/json body
func NewUpdateAgentPolicyRequest(server string, agentPolicyId string, body UpdateAgentPolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAgentPolicyRequestWithBody(server, agentPolicyId, "application/json", bodyReader)
}

// NewUpdateAgentPolicyRequestWithBody generates requests for UpdateAgentPolicy with any type of body
func NewUpdateAgentPolicyRequestWithBody(server string, agentPolicyId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "agentPolicyId", runtime.ParamLocationPath, agentPolicyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/agent_policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateRuleRequest calls the generic CreateRule builder with application/json body
func NewCreateRuleRequest(server string, body CreateRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRuleRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateRuleRequestWithBody generates requests for CreateRule with any type of body
func NewCreateRuleRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/alerting/rule")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRuleRequest generates requests for DeleteRule
func NewDeleteRuleRequest(server string, ruleId RuleId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleId", runtime.ParamLocationPath, ruleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/alerting/rule/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRuleRequest generates requests for GetRule
func NewGetRuleRequest(server string, ruleId RuleId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleId", runtime.ParamLocationPath, ruleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/alerting/rule/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRuleIdRequest calls the generic CreateRuleId builder with application/json body
func NewCreateRuleIdRequest(server string, ruleId string, body CreateRuleIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRuleIdRequestWithBody(server, ruleId, "application/json", bodyReader)
}

// NewCreateRuleIdRequestWithBody generates requests for CreateRuleId with any type of body
func NewCreateRuleIdRequestWithBody(server string, ruleId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleId", runtime.ParamLocationPath, ruleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/alerting/rule/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateRuleRequest calls the generic UpdateRule builder with application/json body
func NewUpdateRuleRequest(server string, ruleId RuleId, body UpdateRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRuleRequestWithBody(server, ruleId, "application/json", bodyReader)
}

// NewUpdateRuleRequestWithBody generates requests for UpdateRule with any type of body
func NewUpdateRuleRequestWithBody(server string, ruleId RuleId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleId", runtime.ParamLocationPath, ruleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/alerting/rule/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindRulesRequest generates requests for FindRules
func NewFindRulesRequest(server string, params *FindRulesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/alerting/rules/_find")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DefaultSearchOperator != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "default_search_operator", runtime.ParamLocationQuery, *params.DefaultSearchOperator); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Fields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, *params.Fields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasReference != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "has_reference", runtime.ParamLocationQuery, *params.HasReference); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SearchFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search_fields", runtime.ParamLocationQuery, *params.SearchFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortField != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_field", runtime.ParamLocationQuery, *params.SortField); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortOrder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_order", runtime.ParamLocationQuery, *params.SortOrder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllDataViewsDefaultRequest generates requests for GetAllDataViewsDefault
func NewGetAllDataViewsDefaultRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/data_views")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDataViewDefaultwRequest calls the generic CreateDataViewDefaultw builder with application/json body
func NewCreateDataViewDefaultwRequest(server string, body CreateDataViewDefaultwJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDataViewDefaultwRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateDataViewDefaultwRequestWithBody generates requests for CreateDataViewDefaultw with any type of body
func NewCreateDataViewDefaultwRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/data_views/data_view")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDataViewDefaultRequest generates requests for DeleteDataViewDefault
func NewDeleteDataViewDefaultRequest(server string, viewId ViewId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "viewId", runtime.ParamLocationPath, viewId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/data_views/data_view/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDataViewDefaultRequest generates requests for GetDataViewDefault
func NewGetDataViewDefaultRequest(server string, viewId ViewId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "viewId", runtime.ParamLocationPath, viewId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/data_views/data_view/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateDataViewDefaultRequest calls the generic UpdateDataViewDefault builder with application/json body
func NewUpdateDataViewDefaultRequest(server string, viewId ViewId, body UpdateDataViewDefaultJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDataViewDefaultRequestWithBody(server, viewId, "application/json", bodyReader)
}

// NewUpdateDataViewDefaultRequestWithBody generates requests for UpdateDataViewDefault with any type of body
func NewUpdateDataViewDefaultRequestWithBody(server string, viewId ViewId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "viewId", runtime.ParamLocationPath, viewId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/data_views/data_view/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewImportSavedObjectsDefaultRequestWithBody generates requests for ImportSavedObjectsDefault with any type of body
func NewImportSavedObjectsDefaultRequestWithBody(server string, params *ImportSavedObjectsDefaultParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/saved_objects/_import")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CreateNewCopies != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createNewCopies", runtime.ParamLocationQuery, *params.CreateNewCopies); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Overwrite != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "overwrite", runtime.ParamLocationQuery, *params.Overwrite); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CompatibilityMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "compatibilityMode", runtime.ParamLocationQuery, *params.CompatibilityMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetEnrollmentApiKeysRequest generates requests for GetEnrollmentApiKeys
func NewGetEnrollmentApiKeysRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/enrollment_api_keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateEnrollmentApiKeysRequest generates requests for CreateEnrollmentApiKeys
func NewCreateEnrollmentApiKeysRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/enrollment_api_keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllPackagesRequest generates requests for ListAllPackages
func NewListAllPackagesRequest(server string, params *ListAllPackagesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/epm/packages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ExcludeInstallStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludeInstallStatus", runtime.ParamLocationQuery, *params.ExcludeInstallStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Prerelease != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prerelease", runtime.ParamLocationQuery, *params.Prerelease); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Experimental != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "experimental", runtime.ParamLocationQuery, *params.Experimental); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Category != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "category", runtime.ParamLocationQuery, *params.Category); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInstallPackageByUploadRequestWithBody generates requests for InstallPackageByUpload with any type of body
func NewInstallPackageByUploadRequestWithBody(server string, params *InstallPackageByUploadParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/epm/packages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IgnoreMappingUpdateErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ignoreMappingUpdateErrors", runtime.ParamLocationQuery, *params.IgnoreMappingUpdateErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipDataStreamRollover != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipDataStreamRollover", runtime.ParamLocationQuery, *params.SkipDataStreamRollover); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePackageRequest calls the generic DeletePackage builder with application/json body
func NewDeletePackageRequest(server string, pkgName string, pkgVersion string, params *DeletePackageParams, body DeletePackageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeletePackageRequestWithBody(server, pkgName, pkgVersion, params, "application/json", bodyReader)
}

// NewDeletePackageRequestWithBody generates requests for DeletePackage with any type of body
func NewDeletePackageRequestWithBody(server string, pkgName string, pkgVersion string, params *DeletePackageParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pkgName", runtime.ParamLocationPath, pkgName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "pkgVersion", runtime.ParamLocationPath, pkgVersion)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/epm/packages/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Force != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IgnoreUnverified != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ignoreUnverified", runtime.ParamLocationQuery, *params.IgnoreUnverified); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Full != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full", runtime.ParamLocationQuery, *params.Full); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Prerelease != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prerelease", runtime.ParamLocationQuery, *params.Prerelease); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPackageRequest generates requests for GetPackage
func NewGetPackageRequest(server string, pkgName string, pkgVersion string, params *GetPackageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pkgName", runtime.ParamLocationPath, pkgName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "pkgVersion", runtime.ParamLocationPath, pkgVersion)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/epm/packages/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IgnoreUnverified != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ignoreUnverified", runtime.ParamLocationQuery, *params.IgnoreUnverified); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Full != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full", runtime.ParamLocationQuery, *params.Full); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Prerelease != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prerelease", runtime.ParamLocationQuery, *params.Prerelease); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInstallPackageRequest calls the generic InstallPackage builder with application/json body
func NewInstallPackageRequest(server string, pkgName string, pkgVersion string, params *InstallPackageParams, body InstallPackageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInstallPackageRequestWithBody(server, pkgName, pkgVersion, params, "application/json", bodyReader)
}

// NewInstallPackageRequestWithBody generates requests for InstallPackage with any type of body
func NewInstallPackageRequestWithBody(server string, pkgName string, pkgVersion string, params *InstallPackageParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pkgName", runtime.ParamLocationPath, pkgName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "pkgVersion", runtime.ParamLocationPath, pkgVersion)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/epm/packages/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IgnoreMappingUpdateErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ignoreMappingUpdateErrors", runtime.ParamLocationQuery, *params.IgnoreMappingUpdateErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipDataStreamRollover != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipDataStreamRollover", runtime.ParamLocationQuery, *params.SkipDataStreamRollover); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IgnoreUnverified != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ignoreUnverified", runtime.ParamLocationQuery, *params.IgnoreUnverified); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Full != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full", runtime.ParamLocationQuery, *params.Full); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Prerelease != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prerelease", runtime.ParamLocationQuery, *params.Prerelease); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdatePackageRequest calls the generic UpdatePackage builder with application/json body
func NewUpdatePackageRequest(server string, pkgName string, pkgVersion string, params *UpdatePackageParams, body UpdatePackageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePackageRequestWithBody(server, pkgName, pkgVersion, params, "application/json", bodyReader)
}

// NewUpdatePackageRequestWithBody generates requests for UpdatePackage with any type of body
func NewUpdatePackageRequestWithBody(server string, pkgName string, pkgVersion string, params *UpdatePackageParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pkgName", runtime.ParamLocationPath, pkgName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "pkgVersion", runtime.ParamLocationPath, pkgVersion)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/epm/packages/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IgnoreUnverified != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ignoreUnverified", runtime.ParamLocationQuery, *params.IgnoreUnverified); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Full != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full", runtime.ParamLocationQuery, *params.Full); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Prerelease != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prerelease", runtime.ParamLocationQuery, *params.Prerelease); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFleetServerHostsRequest generates requests for GetFleetServerHosts
func NewGetFleetServerHostsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fleet_server_hosts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostFleetServerHostsRequest calls the generic PostFleetServerHosts builder with application/json body
func NewPostFleetServerHostsRequest(server string, body PostFleetServerHostsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostFleetServerHostsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostFleetServerHostsRequestWithBody generates requests for PostFleetServerHosts with any type of body
func NewPostFleetServerHostsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fleet_server_hosts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFleetServerHostsRequest generates requests for DeleteFleetServerHosts
func NewDeleteFleetServerHostsRequest(server string, itemId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fleet_server_hosts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOneFleetServerHostsRequest generates requests for GetOneFleetServerHosts
func NewGetOneFleetServerHostsRequest(server string, itemId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fleet_server_hosts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateFleetServerHostsRequest calls the generic UpdateFleetServerHosts builder with application/json body
func NewUpdateFleetServerHostsRequest(server string, itemId string, body UpdateFleetServerHostsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateFleetServerHostsRequestWithBody(server, itemId, "application/json", bodyReader)
}

// NewUpdateFleetServerHostsRequestWithBody generates requests for UpdateFleetServerHosts with any type of body
func NewUpdateFleetServerHostsRequestWithBody(server string, itemId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fleet_server_hosts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetOutputsRequest generates requests for GetOutputs
func NewGetOutputsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/outputs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostOutputsRequest calls the generic PostOutputs builder with application/json body
func NewPostOutputsRequest(server string, body PostOutputsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostOutputsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostOutputsRequestWithBody generates requests for PostOutputs with any type of body
func NewPostOutputsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/outputs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOutputRequest generates requests for DeleteOutput
func NewDeleteOutputRequest(server string, outputId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "outputId", runtime.ParamLocationPath, outputId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/outputs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOutputRequest generates requests for GetOutput
func NewGetOutputRequest(server string, outputId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "outputId", runtime.ParamLocationPath, outputId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/outputs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateOutputRequest calls the generic UpdateOutput builder with application/json body
func NewUpdateOutputRequest(server string, outputId string, body UpdateOutputJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOutputRequestWithBody(server, outputId, "application/json", bodyReader)
}

// NewUpdateOutputRequestWithBody generates requests for UpdateOutput with any type of body
func NewUpdateOutputRequestWithBody(server string, outputId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "outputId", runtime.ParamLocationPath, outputId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/outputs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPackagePoliciesRequest generates requests for GetPackagePolicies
func NewGetPackagePoliciesRequest(server string, params *GetPackagePoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/package_policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Kuery != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kuery", runtime.ParamLocationQuery, *params.Kuery); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePackagePolicyRequest calls the generic CreatePackagePolicy builder with application/json body
func NewCreatePackagePolicyRequest(server string, params *CreatePackagePolicyParams, body CreatePackagePolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePackagePolicyRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreatePackagePolicyRequestWithBody generates requests for CreatePackagePolicy with any type of body
func NewCreatePackagePolicyRequestWithBody(server string, params *CreatePackagePolicyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/package_policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePackagePolicyRequest generates requests for DeletePackagePolicy
func NewDeletePackagePolicyRequest(server string, packagePolicyId string, params *DeletePackagePolicyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "packagePolicyId", runtime.ParamLocationPath, packagePolicyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/package_policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Force != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPackagePolicyRequest generates requests for GetPackagePolicy
func NewGetPackagePolicyRequest(server string, packagePolicyId string, params *GetPackagePolicyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "packagePolicyId", runtime.ParamLocationPath, packagePolicyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/package_policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePackagePolicyRequest calls the generic UpdatePackagePolicy builder with application/json body
func NewUpdatePackagePolicyRequest(server string, packagePolicyId string, params *UpdatePackagePolicyParams, body UpdatePackagePolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePackagePolicyRequestWithBody(server, packagePolicyId, params, "application/json", bodyReader)
}

// NewUpdatePackagePolicyRequestWithBody generates requests for UpdatePackagePolicy with any type of body
func NewUpdatePackagePolicyRequestWithBody(server string, packagePolicyId string, params *UpdatePackagePolicyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "packagePolicyId", runtime.ParamLocationPath, packagePolicyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/package_policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindSlosOpRequest generates requests for FindSlosOp
func NewFindSlosOpRequest(server string, spaceId SpaceId, params *FindSlosOpParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/s/%s/api/observability/slos", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.KqlQuery != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kqlQuery", runtime.ParamLocationQuery, *params.KqlQuery); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortDirection", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HideStale != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hideStale", runtime.ParamLocationQuery, *params.HideStale); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSloOpRequest calls the generic CreateSloOp builder with application/json body
func NewCreateSloOpRequest(server string, spaceId SpaceId, body CreateSloOpJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSloOpRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateSloOpRequestWithBody generates requests for CreateSloOp with any type of body
func NewCreateSloOpRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/s/%s/api/observability/slos", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSloOpRequest generates requests for DeleteSloOp
func NewDeleteSloOpRequest(server string, spaceId SpaceId, sloId SloId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sloId", runtime.ParamLocationPath, sloId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/s/%s/api/observability/slos/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSloOpRequest generates requests for GetSloOp
func NewGetSloOpRequest(server string, spaceId SpaceId, sloId SloId, params *GetSloOpParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sloId", runtime.ParamLocationPath, sloId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/s/%s/api/observability/slos/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.InstanceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "instanceId", runtime.ParamLocationQuery, *params.InstanceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSloOpRequest calls the generic UpdateSloOp builder with application/json body
func NewUpdateSloOpRequest(server string, spaceId SpaceId, sloId SloId, body UpdateSloOpJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSloOpRequestWithBody(server, spaceId, sloId, "application/json", bodyReader)
}

// NewUpdateSloOpRequestWithBody generates requests for UpdateSloOp with any type of body
func NewUpdateSloOpRequestWithBody(server string, spaceId SpaceId, sloId SloId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sloId", runtime.ParamLocationPath, sloId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/s/%s/api/observability/slos/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGenerateServiceTokenRequest generates requests for GenerateServiceToken
func NewGenerateServiceTokenRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service_tokens")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// AgentPolicyListWithResponse request
	AgentPolicyListWithResponse(ctx context.Context, params *AgentPolicyListParams, reqEditors ...RequestEditorFn) (*AgentPolicyListResponse, error)

	// CreateAgentPolicyWithBodyWithResponse request with any body
	CreateAgentPolicyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAgentPolicyResponse, error)

	CreateAgentPolicyWithResponse(ctx context.Context, body CreateAgentPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAgentPolicyResponse, error)

	// DeleteAgentPolicyWithBodyWithResponse request with any body
	DeleteAgentPolicyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteAgentPolicyResponse, error)

	DeleteAgentPolicyWithResponse(ctx context.Context, body DeleteAgentPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteAgentPolicyResponse, error)

	// AgentPolicyInfoWithResponse request
	AgentPolicyInfoWithResponse(ctx context.Context, agentPolicyId string, reqEditors ...RequestEditorFn) (*AgentPolicyInfoResponse, error)

	// UpdateAgentPolicyWithBodyWithResponse request with any body
	UpdateAgentPolicyWithBodyWithResponse(ctx context.Context, agentPolicyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAgentPolicyResponse, error)

	UpdateAgentPolicyWithResponse(ctx context.Context, agentPolicyId string, body UpdateAgentPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAgentPolicyResponse, error)

	// CreateRuleWithBodyWithResponse request with any body
	CreateRuleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRuleResponse, error)

	CreateRuleWithResponse(ctx context.Context, body CreateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRuleResponse, error)

	// DeleteRuleWithResponse request
	DeleteRuleWithResponse(ctx context.Context, ruleId RuleId, reqEditors ...RequestEditorFn) (*DeleteRuleResponse, error)

	// GetRuleWithResponse request
	GetRuleWithResponse(ctx context.Context, ruleId RuleId, reqEditors ...RequestEditorFn) (*GetRuleResponse, error)

	// CreateRuleIdWithBodyWithResponse request with any body
	CreateRuleIdWithBodyWithResponse(ctx context.Context, ruleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRuleIdResponse, error)

	CreateRuleIdWithResponse(ctx context.Context, ruleId string, body CreateRuleIdJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRuleIdResponse, error)

	// UpdateRuleWithBodyWithResponse request with any body
	UpdateRuleWithBodyWithResponse(ctx context.Context, ruleId RuleId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRuleResponse, error)

	UpdateRuleWithResponse(ctx context.Context, ruleId RuleId, body UpdateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRuleResponse, error)

	// FindRulesWithResponse request
	FindRulesWithResponse(ctx context.Context, params *FindRulesParams, reqEditors ...RequestEditorFn) (*FindRulesResponse, error)

	// GetAllDataViewsDefaultWithResponse request
	GetAllDataViewsDefaultWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllDataViewsDefaultResponse, error)

	// CreateDataViewDefaultwWithBodyWithResponse request with any body
	CreateDataViewDefaultwWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDataViewDefaultwResponse, error)

	CreateDataViewDefaultwWithResponse(ctx context.Context, body CreateDataViewDefaultwJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDataViewDefaultwResponse, error)

	// DeleteDataViewDefaultWithResponse request
	DeleteDataViewDefaultWithResponse(ctx context.Context, viewId ViewId, reqEditors ...RequestEditorFn) (*DeleteDataViewDefaultResponse, error)

	// GetDataViewDefaultWithResponse request
	GetDataViewDefaultWithResponse(ctx context.Context, viewId ViewId, reqEditors ...RequestEditorFn) (*GetDataViewDefaultResponse, error)

	// UpdateDataViewDefaultWithBodyWithResponse request with any body
	UpdateDataViewDefaultWithBodyWithResponse(ctx context.Context, viewId ViewId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDataViewDefaultResponse, error)

	UpdateDataViewDefaultWithResponse(ctx context.Context, viewId ViewId, body UpdateDataViewDefaultJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDataViewDefaultResponse, error)

	// ImportSavedObjectsDefaultWithBodyWithResponse request with any body
	ImportSavedObjectsDefaultWithBodyWithResponse(ctx context.Context, params *ImportSavedObjectsDefaultParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportSavedObjectsDefaultResponse, error)

	// GetEnrollmentApiKeysWithResponse request
	GetEnrollmentApiKeysWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetEnrollmentApiKeysResponse, error)

	// CreateEnrollmentApiKeysWithResponse request
	CreateEnrollmentApiKeysWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CreateEnrollmentApiKeysResponse, error)

	// ListAllPackagesWithResponse request
	ListAllPackagesWithResponse(ctx context.Context, params *ListAllPackagesParams, reqEditors ...RequestEditorFn) (*ListAllPackagesResponse, error)

	// InstallPackageByUploadWithBodyWithResponse request with any body
	InstallPackageByUploadWithBodyWithResponse(ctx context.Context, params *InstallPackageByUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InstallPackageByUploadResponse, error)

	// DeletePackageWithBodyWithResponse request with any body
	DeletePackageWithBodyWithResponse(ctx context.Context, pkgName string, pkgVersion string, params *DeletePackageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeletePackageResponse, error)

	DeletePackageWithResponse(ctx context.Context, pkgName string, pkgVersion string, params *DeletePackageParams, body DeletePackageJSONRequestBody, reqEditors ...RequestEditorFn) (*DeletePackageResponse, error)

	// GetPackageWithResponse request
	GetPackageWithResponse(ctx context.Context, pkgName string, pkgVersion string, params *GetPackageParams, reqEditors ...RequestEditorFn) (*GetPackageResponse, error)

	// InstallPackageWithBodyWithResponse request with any body
	InstallPackageWithBodyWithResponse(ctx context.Context, pkgName string, pkgVersion string, params *InstallPackageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InstallPackageResponse, error)

	InstallPackageWithResponse(ctx context.Context, pkgName string, pkgVersion string, params *InstallPackageParams, body InstallPackageJSONRequestBody, reqEditors ...RequestEditorFn) (*InstallPackageResponse, error)

	// UpdatePackageWithBodyWithResponse request with any body
	UpdatePackageWithBodyWithResponse(ctx context.Context, pkgName string, pkgVersion string, params *UpdatePackageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePackageResponse, error)

	UpdatePackageWithResponse(ctx context.Context, pkgName string, pkgVersion string, params *UpdatePackageParams, body UpdatePackageJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePackageResponse, error)

	// GetFleetServerHostsWithResponse request
	GetFleetServerHostsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetFleetServerHostsResponse, error)

	// PostFleetServerHostsWithBodyWithResponse request with any body
	PostFleetServerHostsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFleetServerHostsResponse, error)

	PostFleetServerHostsWithResponse(ctx context.Context, body PostFleetServerHostsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFleetServerHostsResponse, error)

	// DeleteFleetServerHostsWithResponse request
	DeleteFleetServerHostsWithResponse(ctx context.Context, itemId string, reqEditors ...RequestEditorFn) (*DeleteFleetServerHostsResponse, error)

	// GetOneFleetServerHostsWithResponse request
	GetOneFleetServerHostsWithResponse(ctx context.Context, itemId string, reqEditors ...RequestEditorFn) (*GetOneFleetServerHostsResponse, error)

	// UpdateFleetServerHostsWithBodyWithResponse request with any body
	UpdateFleetServerHostsWithBodyWithResponse(ctx context.Context, itemId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFleetServerHostsResponse, error)

	UpdateFleetServerHostsWithResponse(ctx context.Context, itemId string, body UpdateFleetServerHostsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFleetServerHostsResponse, error)

	// GetOutputsWithResponse request
	GetOutputsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOutputsResponse, error)

	// PostOutputsWithBodyWithResponse request with any body
	PostOutputsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOutputsResponse, error)

	PostOutputsWithResponse(ctx context.Context, body PostOutputsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOutputsResponse, error)

	// DeleteOutputWithResponse request
	DeleteOutputWithResponse(ctx context.Context, outputId string, reqEditors ...RequestEditorFn) (*DeleteOutputResponse, error)

	// GetOutputWithResponse request
	GetOutputWithResponse(ctx context.Context, outputId string, reqEditors ...RequestEditorFn) (*GetOutputResponse, error)

	// UpdateOutputWithBodyWithResponse request with any body
	UpdateOutputWithBodyWithResponse(ctx context.Context, outputId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOutputResponse, error)

	UpdateOutputWithResponse(ctx context.Context, outputId string, body UpdateOutputJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOutputResponse, error)

	// GetPackagePoliciesWithResponse request
	GetPackagePoliciesWithResponse(ctx context.Context, params *GetPackagePoliciesParams, reqEditors ...RequestEditorFn) (*GetPackagePoliciesResponse, error)

	// CreatePackagePolicyWithBodyWithResponse request with any body
	CreatePackagePolicyWithBodyWithResponse(ctx context.Context, params *CreatePackagePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePackagePolicyResponse, error)

	CreatePackagePolicyWithResponse(ctx context.Context, params *CreatePackagePolicyParams, body CreatePackagePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePackagePolicyResponse, error)

	// DeletePackagePolicyWithResponse request
	DeletePackagePolicyWithResponse(ctx context.Context, packagePolicyId string, params *DeletePackagePolicyParams, reqEditors ...RequestEditorFn) (*DeletePackagePolicyResponse, error)

	// GetPackagePolicyWithResponse request
	GetPackagePolicyWithResponse(ctx context.Context, packagePolicyId string, params *GetPackagePolicyParams, reqEditors ...RequestEditorFn) (*GetPackagePolicyResponse, error)

	// UpdatePackagePolicyWithBodyWithResponse request with any body
	UpdatePackagePolicyWithBodyWithResponse(ctx context.Context, packagePolicyId string, params *UpdatePackagePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePackagePolicyResponse, error)

	UpdatePackagePolicyWithResponse(ctx context.Context, packagePolicyId string, params *UpdatePackagePolicyParams, body UpdatePackagePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePackagePolicyResponse, error)

	// FindSlosOpWithResponse request
	FindSlosOpWithResponse(ctx context.Context, spaceId SpaceId, params *FindSlosOpParams, reqEditors ...RequestEditorFn) (*FindSlosOpResponse, error)

	// CreateSloOpWithBodyWithResponse request with any body
	CreateSloOpWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSloOpResponse, error)

	CreateSloOpWithResponse(ctx context.Context, spaceId SpaceId, body CreateSloOpJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSloOpResponse, error)

	// DeleteSloOpWithResponse request
	DeleteSloOpWithResponse(ctx context.Context, spaceId SpaceId, sloId SloId, reqEditors ...RequestEditorFn) (*DeleteSloOpResponse, error)

	// GetSloOpWithResponse request
	GetSloOpWithResponse(ctx context.Context, spaceId SpaceId, sloId SloId, params *GetSloOpParams, reqEditors ...RequestEditorFn) (*GetSloOpResponse, error)

	// UpdateSloOpWithBodyWithResponse request with any body
	UpdateSloOpWithBodyWithResponse(ctx context.Context, spaceId SpaceId, sloId SloId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSloOpResponse, error)

	UpdateSloOpWithResponse(ctx context.Context, spaceId SpaceId, sloId SloId, body UpdateSloOpJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSloOpResponse, error)

	// GenerateServiceTokenWithResponse request
	GenerateServiceTokenWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GenerateServiceTokenResponse, error)
}

type AgentPolicyListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items   []AgentPolicy `json:"items"`
		Page    float32       `json:"page"`
		PerPage float32       `json:"perPage"`
		Total   float32       `json:"total"`
	}
	JSON400 *Error
}

// Status returns HTTPResponse.Status
func (r AgentPolicyListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AgentPolicyListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAgentPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Item *AgentPolicy `json:"item,omitempty"`
	}
	JSON400 *Error
}

// Status returns HTTPResponse.Status
func (r CreateAgentPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAgentPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAgentPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Id      string `json:"id"`
		Success bool   `json:"success"`
	}
	JSON400 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteAgentPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAgentPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AgentPolicyInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Item AgentPolicy `json:"item"`
	}
	JSON400 *Error
}

// Status returns HTTPResponse.Status
func (r AgentPolicyInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AgentPolicyInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAgentPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Item AgentPolicy `json:"item"`
	}
	JSON400 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateAgentPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAgentPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RuleResponseProperties
	JSON401      *N401Response
	JSON404      *N404Response
}

// Status returns HTTPResponse.Status
func (r CreateRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *N401Response
	JSON404      *N404Response
}

// Status returns HTTPResponse.Status
func (r DeleteRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RuleResponseProperties
	JSON401      *N401Response
	JSON404      *N404Response
}

// Status returns HTTPResponse.Status
func (r GetRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRuleIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RuleResponseProperties
	JSON401      *N401Response
	JSON404      *N404Response
}

// Status returns HTTPResponse.Status
func (r CreateRuleIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRuleIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RuleResponseProperties
	JSON401      *N401Response
	JSON404      *N404Response
}

// Status returns HTTPResponse.Status
func (r UpdateRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data    []RuleResponseProperties `json:"data,omitempty"`
		Page    *int                     `json:"page,omitempty"`
		PerPage *int                     `json:"per_page,omitempty"`
		Total   *int                     `json:"total,omitempty"`
	}
	JSON401 *N401Response
}

// Status returns HTTPResponse.Status
func (r FindRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllDataViewsDefaultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		DataView []struct {
			Id         *string                `json:"id,omitempty"`
			Name       *string                `json:"name,omitempty"`
			Namespaces []string               `json:"namespaces,omitempty"`
			Title      *string                `json:"title,omitempty"`
			TypeMeta   map[string]interface{} `json:"typeMeta,omitempty"`
		} `json:"data_view,omitempty"`
	}
	JSON400 *N400Response
}

// Status returns HTTPResponse.Status
func (r GetAllDataViewsDefaultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllDataViewsDefaultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDataViewDefaultwResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DataViewResponseObject
	JSON400      *N400Response
}

// Status returns HTTPResponse.Status
func (r CreateDataViewDefaultwResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDataViewDefaultwResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDataViewDefaultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *N404Response
}

// Status returns HTTPResponse.Status
func (r DeleteDataViewDefaultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDataViewDefaultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDataViewDefaultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DataViewResponseObject
	JSON404      *N404Response
}

// Status returns HTTPResponse.Status
func (r GetDataViewDefaultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDataViewDefaultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateDataViewDefaultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DataViewResponseObject
	JSON400      *N400Response
}

// Status returns HTTPResponse.Status
func (r UpdateDataViewDefaultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDataViewDefaultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ImportSavedObjectsDefaultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Errors Indicates the import was unsuccessful and specifies the objects that failed to import.
		//
		// NOTE: One object may result in multiple errors, which requires separate steps to resolve. For instance, a `missing_references` error and conflict error.
		Errors []map[string]interface{} `json:"errors,omitempty"`

		// Success Indicates when the import was successfully completed. When set to false, some objects may not have been created. For additional information, refer to the `errors` and `successResults` properties.
		Success *bool `json:"success,omitempty"`

		// SuccessCount Indicates the number of successfully imported records.
		SuccessCount *int `json:"successCount,omitempty"`

		// SuccessResults Indicates the objects that are successfully imported, with any metadata if applicable.
		//
		// NOTE: Objects are created only when all resolvable errors are addressed, including conflicts and missing references. If objects are created as new copies, each entry in the `successResults` array includes a `destinationId` attribute.
		SuccessResults []map[string]interface{} `json:"successResults,omitempty"`
	}
	JSON400 *N400Response
}

// Status returns HTTPResponse.Status
func (r ImportSavedObjectsDefaultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ImportSavedObjectsDefaultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEnrollmentApiKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items []EnrollmentApiKey `json:"items"`
		// Deprecated:
		List    []EnrollmentApiKey `json:"list,omitempty"`
		Page    float32            `json:"page"`
		PerPage float32            `json:"perPage"`
		Total   float32            `json:"total"`
	}
	JSON400 *Error
}

// Status returns HTTPResponse.Status
func (r GetEnrollmentApiKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEnrollmentApiKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateEnrollmentApiKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Action *N200Action       `json:"action,omitempty"`
		Item   *EnrollmentApiKey `json:"item,omitempty"`
	}
	JSON400 *Error
}

// Status returns HTTPResponse.Status
func (r CreateEnrollmentApiKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateEnrollmentApiKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAllPackagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetPackagesResponse
	JSON400      *Error
}

// Status returns HTTPResponse.Status
func (r ListAllPackagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAllPackagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InstallPackageByUploadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			InstallSource *PackageInstallSource `json:"install_source,omitempty"`
		} `json:"_meta,omitempty"`
		Items PackageItem `json:"items"`
	}
	JSON400 *Error
	JSON429 *Error
}

// Status returns HTTPResponse.Status
func (r InstallPackageByUploadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InstallPackageByUploadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePackageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items PackageItem `json:"items"`
	}
	JSON400 *Error
}

// Status returns HTTPResponse.Status
func (r DeletePackageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePackageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPackageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Item                 *PackageInfo `json:"item,omitempty"`
		KeepPoliciesUpToDate *bool        `json:"keepPoliciesUpToDate,omitempty"`
		LatestVersion        *string      `json:"latestVersion,omitempty"`
		LicensePath          *string      `json:"licensePath,omitempty"`
		Notice               *string      `json:"notice,omitempty"`
		// Deprecated:
		SavedObject map[string]interface{} `json:"savedObject"`
		Status      PackageStatus          `json:"status"`
	}
	JSON400 *Error
}

// Status returns HTTPResponse.Status
func (r GetPackageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPackageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InstallPackageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			InstallSource *PackageInstallSource `json:"install_source,omitempty"`
		} `json:"_meta,omitempty"`
		Items PackageItem `json:"items"`
	}
	JSON400 *Error
}

// Status returns HTTPResponse.Status
func (r InstallPackageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InstallPackageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePackageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items PackageItem `json:"items"`
	}
	JSON400 *Error
}

// Status returns HTTPResponse.Status
func (r UpdatePackageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePackageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFleetServerHostsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items   []FleetServerHost `json:"items,omitempty"`
		Page    *int              `json:"page,omitempty"`
		PerPage *int              `json:"perPage,omitempty"`
		Total   *int              `json:"total,omitempty"`
	}
	JSON400 *Error
}

// Status returns HTTPResponse.Status
func (r GetFleetServerHostsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFleetServerHostsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostFleetServerHostsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Item *FleetServerHost `json:"item,omitempty"`
	}
	JSON400 *Error
}

// Status returns HTTPResponse.Status
func (r PostFleetServerHostsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostFleetServerHostsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFleetServerHostsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Id string `json:"id"`
	}
	JSON400 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteFleetServerHostsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFleetServerHostsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOneFleetServerHostsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Item FleetServerHost `json:"item"`
	}
	JSON400 *Error
}

// Status returns HTTPResponse.Status
func (r GetOneFleetServerHostsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOneFleetServerHostsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateFleetServerHostsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Item FleetServerHost `json:"item"`
	}
	JSON400 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateFleetServerHostsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateFleetServerHostsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOutputsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items   []OutputCreateRequest `json:"items,omitempty"`
		Page    *int                  `json:"page,omitempty"`
		PerPage *int                  `json:"perPage,omitempty"`
		Total   *int                  `json:"total,omitempty"`
	}
	JSON400 *Error
}

// Status returns HTTPResponse.Status
func (r GetOutputsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOutputsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOutputsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Item *OutputCreateRequest `json:"item,omitempty"`
	}
	JSON400 *Error
}

// Status returns HTTPResponse.Status
func (r PostOutputsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOutputsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOutputResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Id string `json:"id"`
	}
	JSON400 *Error
}

// Status returns HTTPResponse.Status
func (r DeleteOutputResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOutputResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOutputResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Item *OutputCreateRequest `json:"item,omitempty"`
	}
	JSON400 *Error
}

// Status returns HTTPResponse.Status
func (r GetOutputResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOutputResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOutputResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Item *OutputUpdateRequest `json:"item,omitempty"`
	}
	JSON400 *Error
}

// Status returns HTTPResponse.Status
func (r UpdateOutputResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOutputResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPackagePoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items   []PackagePolicy `json:"items"`
		Page    *float32        `json:"page,omitempty"`
		PerPage *float32        `json:"perPage,omitempty"`
		Total   *float32        `json:"total,omitempty"`
	}
	JSON400 *Error
}

// Status returns HTTPResponse.Status
func (r GetPackagePoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPackagePoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePackagePolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Item PackagePolicy `json:"item"`
	}
	JSON400 *Error
	JSON409 *Error
}

// Status returns HTTPResponse.Status
func (r CreatePackagePolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePackagePolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePackagePolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Id string `json:"id"`
	}
	JSON400 *Error
}

// Status returns HTTPResponse.Status
func (r DeletePackagePolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePackagePolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPackagePolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Item PackagePolicy `json:"item"`
	}
	JSON400 *Error
}

// Status returns HTTPResponse.Status
func (r GetPackagePolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPackagePolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePackagePolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Item   PackagePolicy `json:"item"`
		Sucess bool          `json:"sucess"`
	}
	JSON400 *Error
}

// Status returns HTTPResponse.Status
func (r UpdatePackagePolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePackagePolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindSlosOpResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FindSloResponse
	JSON400      *N400Response
	JSON401      *N401Response
	JSON403      *N403Response
	JSON404      *N404Response
}

// Status returns HTTPResponse.Status
func (r FindSlosOpResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindSlosOpResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSloOpResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateSloResponse
	JSON400      *N400Response
	JSON401      *N401Response
	JSON403      *N403Response
	JSON409      *N409Response
}

// Status returns HTTPResponse.Status
func (r CreateSloOpResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSloOpResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSloOpResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *N400Response
	JSON401      *N401Response
	JSON403      *N403Response
	JSON404      *N404Response
}

// Status returns HTTPResponse.Status
func (r DeleteSloOpResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSloOpResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSloOpResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SloWithSummaryResponse
	JSON400      *N400Response
	JSON401      *N401Response
	JSON403      *N403Response
	JSON404      *N404Response
}

// Status returns HTTPResponse.Status
func (r GetSloOpResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSloOpResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSloOpResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SloDefinitionResponse
	JSON400      *N400Response
	JSON401      *N401Response
	JSON403      *N403Response
	JSON404      *N404Response
}

// Status returns HTTPResponse.Status
func (r UpdateSloOpResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSloOpResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenerateServiceTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Name  *string `json:"name,omitempty"`
		Value *string `json:"value,omitempty"`
	}
	JSON400 *Error
}

// Status returns HTTPResponse.Status
func (r GenerateServiceTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenerateServiceTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// AgentPolicyListWithResponse request returning *AgentPolicyListResponse
func (c *ClientWithResponses) AgentPolicyListWithResponse(ctx context.Context, params *AgentPolicyListParams, reqEditors ...RequestEditorFn) (*AgentPolicyListResponse, error) {
	rsp, err := c.AgentPolicyList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAgentPolicyListResponse(rsp)
}

// CreateAgentPolicyWithBodyWithResponse request with arbitrary body returning *CreateAgentPolicyResponse
func (c *ClientWithResponses) CreateAgentPolicyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAgentPolicyResponse, error) {
	rsp, err := c.CreateAgentPolicyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAgentPolicyResponse(rsp)
}

func (c *ClientWithResponses) CreateAgentPolicyWithResponse(ctx context.Context, body CreateAgentPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAgentPolicyResponse, error) {
	rsp, err := c.CreateAgentPolicy(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAgentPolicyResponse(rsp)
}

// DeleteAgentPolicyWithBodyWithResponse request with arbitrary body returning *DeleteAgentPolicyResponse
func (c *ClientWithResponses) DeleteAgentPolicyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteAgentPolicyResponse, error) {
	rsp, err := c.DeleteAgentPolicyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAgentPolicyResponse(rsp)
}

func (c *ClientWithResponses) DeleteAgentPolicyWithResponse(ctx context.Context, body DeleteAgentPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteAgentPolicyResponse, error) {
	rsp, err := c.DeleteAgentPolicy(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAgentPolicyResponse(rsp)
}

// AgentPolicyInfoWithResponse request returning *AgentPolicyInfoResponse
func (c *ClientWithResponses) AgentPolicyInfoWithResponse(ctx context.Context, agentPolicyId string, reqEditors ...RequestEditorFn) (*AgentPolicyInfoResponse, error) {
	rsp, err := c.AgentPolicyInfo(ctx, agentPolicyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAgentPolicyInfoResponse(rsp)
}

// UpdateAgentPolicyWithBodyWithResponse request with arbitrary body returning *UpdateAgentPolicyResponse
func (c *ClientWithResponses) UpdateAgentPolicyWithBodyWithResponse(ctx context.Context, agentPolicyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAgentPolicyResponse, error) {
	rsp, err := c.UpdateAgentPolicyWithBody(ctx, agentPolicyId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAgentPolicyResponse(rsp)
}

func (c *ClientWithResponses) UpdateAgentPolicyWithResponse(ctx context.Context, agentPolicyId string, body UpdateAgentPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAgentPolicyResponse, error) {
	rsp, err := c.UpdateAgentPolicy(ctx, agentPolicyId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAgentPolicyResponse(rsp)
}

// CreateRuleWithBodyWithResponse request with arbitrary body returning *CreateRuleResponse
func (c *ClientWithResponses) CreateRuleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRuleResponse, error) {
	rsp, err := c.CreateRuleWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRuleResponse(rsp)
}

func (c *ClientWithResponses) CreateRuleWithResponse(ctx context.Context, body CreateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRuleResponse, error) {
	rsp, err := c.CreateRule(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRuleResponse(rsp)
}

// DeleteRuleWithResponse request returning *DeleteRuleResponse
func (c *ClientWithResponses) DeleteRuleWithResponse(ctx context.Context, ruleId RuleId, reqEditors ...RequestEditorFn) (*DeleteRuleResponse, error) {
	rsp, err := c.DeleteRule(ctx, ruleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRuleResponse(rsp)
}

// GetRuleWithResponse request returning *GetRuleResponse
func (c *ClientWithResponses) GetRuleWithResponse(ctx context.Context, ruleId RuleId, reqEditors ...RequestEditorFn) (*GetRuleResponse, error) {
	rsp, err := c.GetRule(ctx, ruleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRuleResponse(rsp)
}

// CreateRuleIdWithBodyWithResponse request with arbitrary body returning *CreateRuleIdResponse
func (c *ClientWithResponses) CreateRuleIdWithBodyWithResponse(ctx context.Context, ruleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRuleIdResponse, error) {
	rsp, err := c.CreateRuleIdWithBody(ctx, ruleId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRuleIdResponse(rsp)
}

func (c *ClientWithResponses) CreateRuleIdWithResponse(ctx context.Context, ruleId string, body CreateRuleIdJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRuleIdResponse, error) {
	rsp, err := c.CreateRuleId(ctx, ruleId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRuleIdResponse(rsp)
}

// UpdateRuleWithBodyWithResponse request with arbitrary body returning *UpdateRuleResponse
func (c *ClientWithResponses) UpdateRuleWithBodyWithResponse(ctx context.Context, ruleId RuleId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRuleResponse, error) {
	rsp, err := c.UpdateRuleWithBody(ctx, ruleId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRuleResponse(rsp)
}

func (c *ClientWithResponses) UpdateRuleWithResponse(ctx context.Context, ruleId RuleId, body UpdateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRuleResponse, error) {
	rsp, err := c.UpdateRule(ctx, ruleId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRuleResponse(rsp)
}

// FindRulesWithResponse request returning *FindRulesResponse
func (c *ClientWithResponses) FindRulesWithResponse(ctx context.Context, params *FindRulesParams, reqEditors ...RequestEditorFn) (*FindRulesResponse, error) {
	rsp, err := c.FindRules(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindRulesResponse(rsp)
}

// GetAllDataViewsDefaultWithResponse request returning *GetAllDataViewsDefaultResponse
func (c *ClientWithResponses) GetAllDataViewsDefaultWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllDataViewsDefaultResponse, error) {
	rsp, err := c.GetAllDataViewsDefault(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllDataViewsDefaultResponse(rsp)
}

// CreateDataViewDefaultwWithBodyWithResponse request with arbitrary body returning *CreateDataViewDefaultwResponse
func (c *ClientWithResponses) CreateDataViewDefaultwWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDataViewDefaultwResponse, error) {
	rsp, err := c.CreateDataViewDefaultwWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDataViewDefaultwResponse(rsp)
}

func (c *ClientWithResponses) CreateDataViewDefaultwWithResponse(ctx context.Context, body CreateDataViewDefaultwJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDataViewDefaultwResponse, error) {
	rsp, err := c.CreateDataViewDefaultw(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDataViewDefaultwResponse(rsp)
}

// DeleteDataViewDefaultWithResponse request returning *DeleteDataViewDefaultResponse
func (c *ClientWithResponses) DeleteDataViewDefaultWithResponse(ctx context.Context, viewId ViewId, reqEditors ...RequestEditorFn) (*DeleteDataViewDefaultResponse, error) {
	rsp, err := c.DeleteDataViewDefault(ctx, viewId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDataViewDefaultResponse(rsp)
}

// GetDataViewDefaultWithResponse request returning *GetDataViewDefaultResponse
func (c *ClientWithResponses) GetDataViewDefaultWithResponse(ctx context.Context, viewId ViewId, reqEditors ...RequestEditorFn) (*GetDataViewDefaultResponse, error) {
	rsp, err := c.GetDataViewDefault(ctx, viewId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDataViewDefaultResponse(rsp)
}

// UpdateDataViewDefaultWithBodyWithResponse request with arbitrary body returning *UpdateDataViewDefaultResponse
func (c *ClientWithResponses) UpdateDataViewDefaultWithBodyWithResponse(ctx context.Context, viewId ViewId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDataViewDefaultResponse, error) {
	rsp, err := c.UpdateDataViewDefaultWithBody(ctx, viewId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDataViewDefaultResponse(rsp)
}

func (c *ClientWithResponses) UpdateDataViewDefaultWithResponse(ctx context.Context, viewId ViewId, body UpdateDataViewDefaultJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDataViewDefaultResponse, error) {
	rsp, err := c.UpdateDataViewDefault(ctx, viewId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDataViewDefaultResponse(rsp)
}

// ImportSavedObjectsDefaultWithBodyWithResponse request with arbitrary body returning *ImportSavedObjectsDefaultResponse
func (c *ClientWithResponses) ImportSavedObjectsDefaultWithBodyWithResponse(ctx context.Context, params *ImportSavedObjectsDefaultParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportSavedObjectsDefaultResponse, error) {
	rsp, err := c.ImportSavedObjectsDefaultWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportSavedObjectsDefaultResponse(rsp)
}

// GetEnrollmentApiKeysWithResponse request returning *GetEnrollmentApiKeysResponse
func (c *ClientWithResponses) GetEnrollmentApiKeysWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetEnrollmentApiKeysResponse, error) {
	rsp, err := c.GetEnrollmentApiKeys(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEnrollmentApiKeysResponse(rsp)
}

// CreateEnrollmentApiKeysWithResponse request returning *CreateEnrollmentApiKeysResponse
func (c *ClientWithResponses) CreateEnrollmentApiKeysWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CreateEnrollmentApiKeysResponse, error) {
	rsp, err := c.CreateEnrollmentApiKeys(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEnrollmentApiKeysResponse(rsp)
}

// ListAllPackagesWithResponse request returning *ListAllPackagesResponse
func (c *ClientWithResponses) ListAllPackagesWithResponse(ctx context.Context, params *ListAllPackagesParams, reqEditors ...RequestEditorFn) (*ListAllPackagesResponse, error) {
	rsp, err := c.ListAllPackages(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAllPackagesResponse(rsp)
}

// InstallPackageByUploadWithBodyWithResponse request with arbitrary body returning *InstallPackageByUploadResponse
func (c *ClientWithResponses) InstallPackageByUploadWithBodyWithResponse(ctx context.Context, params *InstallPackageByUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InstallPackageByUploadResponse, error) {
	rsp, err := c.InstallPackageByUploadWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInstallPackageByUploadResponse(rsp)
}

// DeletePackageWithBodyWithResponse request with arbitrary body returning *DeletePackageResponse
func (c *ClientWithResponses) DeletePackageWithBodyWithResponse(ctx context.Context, pkgName string, pkgVersion string, params *DeletePackageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeletePackageResponse, error) {
	rsp, err := c.DeletePackageWithBody(ctx, pkgName, pkgVersion, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePackageResponse(rsp)
}

func (c *ClientWithResponses) DeletePackageWithResponse(ctx context.Context, pkgName string, pkgVersion string, params *DeletePackageParams, body DeletePackageJSONRequestBody, reqEditors ...RequestEditorFn) (*DeletePackageResponse, error) {
	rsp, err := c.DeletePackage(ctx, pkgName, pkgVersion, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePackageResponse(rsp)
}

// GetPackageWithResponse request returning *GetPackageResponse
func (c *ClientWithResponses) GetPackageWithResponse(ctx context.Context, pkgName string, pkgVersion string, params *GetPackageParams, reqEditors ...RequestEditorFn) (*GetPackageResponse, error) {
	rsp, err := c.GetPackage(ctx, pkgName, pkgVersion, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPackageResponse(rsp)
}

// InstallPackageWithBodyWithResponse request with arbitrary body returning *InstallPackageResponse
func (c *ClientWithResponses) InstallPackageWithBodyWithResponse(ctx context.Context, pkgName string, pkgVersion string, params *InstallPackageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InstallPackageResponse, error) {
	rsp, err := c.InstallPackageWithBody(ctx, pkgName, pkgVersion, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInstallPackageResponse(rsp)
}

func (c *ClientWithResponses) InstallPackageWithResponse(ctx context.Context, pkgName string, pkgVersion string, params *InstallPackageParams, body InstallPackageJSONRequestBody, reqEditors ...RequestEditorFn) (*InstallPackageResponse, error) {
	rsp, err := c.InstallPackage(ctx, pkgName, pkgVersion, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInstallPackageResponse(rsp)
}

// UpdatePackageWithBodyWithResponse request with arbitrary body returning *UpdatePackageResponse
func (c *ClientWithResponses) UpdatePackageWithBodyWithResponse(ctx context.Context, pkgName string, pkgVersion string, params *UpdatePackageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePackageResponse, error) {
	rsp, err := c.UpdatePackageWithBody(ctx, pkgName, pkgVersion, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePackageResponse(rsp)
}

func (c *ClientWithResponses) UpdatePackageWithResponse(ctx context.Context, pkgName string, pkgVersion string, params *UpdatePackageParams, body UpdatePackageJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePackageResponse, error) {
	rsp, err := c.UpdatePackage(ctx, pkgName, pkgVersion, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePackageResponse(rsp)
}

// GetFleetServerHostsWithResponse request returning *GetFleetServerHostsResponse
func (c *ClientWithResponses) GetFleetServerHostsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetFleetServerHostsResponse, error) {
	rsp, err := c.GetFleetServerHosts(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFleetServerHostsResponse(rsp)
}

// PostFleetServerHostsWithBodyWithResponse request with arbitrary body returning *PostFleetServerHostsResponse
func (c *ClientWithResponses) PostFleetServerHostsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFleetServerHostsResponse, error) {
	rsp, err := c.PostFleetServerHostsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFleetServerHostsResponse(rsp)
}

func (c *ClientWithResponses) PostFleetServerHostsWithResponse(ctx context.Context, body PostFleetServerHostsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFleetServerHostsResponse, error) {
	rsp, err := c.PostFleetServerHosts(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFleetServerHostsResponse(rsp)
}

// DeleteFleetServerHostsWithResponse request returning *DeleteFleetServerHostsResponse
func (c *ClientWithResponses) DeleteFleetServerHostsWithResponse(ctx context.Context, itemId string, reqEditors ...RequestEditorFn) (*DeleteFleetServerHostsResponse, error) {
	rsp, err := c.DeleteFleetServerHosts(ctx, itemId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFleetServerHostsResponse(rsp)
}

// GetOneFleetServerHostsWithResponse request returning *GetOneFleetServerHostsResponse
func (c *ClientWithResponses) GetOneFleetServerHostsWithResponse(ctx context.Context, itemId string, reqEditors ...RequestEditorFn) (*GetOneFleetServerHostsResponse, error) {
	rsp, err := c.GetOneFleetServerHosts(ctx, itemId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOneFleetServerHostsResponse(rsp)
}

// UpdateFleetServerHostsWithBodyWithResponse request with arbitrary body returning *UpdateFleetServerHostsResponse
func (c *ClientWithResponses) UpdateFleetServerHostsWithBodyWithResponse(ctx context.Context, itemId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFleetServerHostsResponse, error) {
	rsp, err := c.UpdateFleetServerHostsWithBody(ctx, itemId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFleetServerHostsResponse(rsp)
}

func (c *ClientWithResponses) UpdateFleetServerHostsWithResponse(ctx context.Context, itemId string, body UpdateFleetServerHostsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFleetServerHostsResponse, error) {
	rsp, err := c.UpdateFleetServerHosts(ctx, itemId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFleetServerHostsResponse(rsp)
}

// GetOutputsWithResponse request returning *GetOutputsResponse
func (c *ClientWithResponses) GetOutputsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOutputsResponse, error) {
	rsp, err := c.GetOutputs(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOutputsResponse(rsp)
}

// PostOutputsWithBodyWithResponse request with arbitrary body returning *PostOutputsResponse
func (c *ClientWithResponses) PostOutputsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOutputsResponse, error) {
	rsp, err := c.PostOutputsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOutputsResponse(rsp)
}

func (c *ClientWithResponses) PostOutputsWithResponse(ctx context.Context, body PostOutputsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOutputsResponse, error) {
	rsp, err := c.PostOutputs(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOutputsResponse(rsp)
}

// DeleteOutputWithResponse request returning *DeleteOutputResponse
func (c *ClientWithResponses) DeleteOutputWithResponse(ctx context.Context, outputId string, reqEditors ...RequestEditorFn) (*DeleteOutputResponse, error) {
	rsp, err := c.DeleteOutput(ctx, outputId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOutputResponse(rsp)
}

// GetOutputWithResponse request returning *GetOutputResponse
func (c *ClientWithResponses) GetOutputWithResponse(ctx context.Context, outputId string, reqEditors ...RequestEditorFn) (*GetOutputResponse, error) {
	rsp, err := c.GetOutput(ctx, outputId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOutputResponse(rsp)
}

// UpdateOutputWithBodyWithResponse request with arbitrary body returning *UpdateOutputResponse
func (c *ClientWithResponses) UpdateOutputWithBodyWithResponse(ctx context.Context, outputId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOutputResponse, error) {
	rsp, err := c.UpdateOutputWithBody(ctx, outputId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOutputResponse(rsp)
}

func (c *ClientWithResponses) UpdateOutputWithResponse(ctx context.Context, outputId string, body UpdateOutputJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOutputResponse, error) {
	rsp, err := c.UpdateOutput(ctx, outputId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOutputResponse(rsp)
}

// GetPackagePoliciesWithResponse request returning *GetPackagePoliciesResponse
func (c *ClientWithResponses) GetPackagePoliciesWithResponse(ctx context.Context, params *GetPackagePoliciesParams, reqEditors ...RequestEditorFn) (*GetPackagePoliciesResponse, error) {
	rsp, err := c.GetPackagePolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPackagePoliciesResponse(rsp)
}

// CreatePackagePolicyWithBodyWithResponse request with arbitrary body returning *CreatePackagePolicyResponse
func (c *ClientWithResponses) CreatePackagePolicyWithBodyWithResponse(ctx context.Context, params *CreatePackagePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePackagePolicyResponse, error) {
	rsp, err := c.CreatePackagePolicyWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePackagePolicyResponse(rsp)
}

func (c *ClientWithResponses) CreatePackagePolicyWithResponse(ctx context.Context, params *CreatePackagePolicyParams, body CreatePackagePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePackagePolicyResponse, error) {
	rsp, err := c.CreatePackagePolicy(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePackagePolicyResponse(rsp)
}

// DeletePackagePolicyWithResponse request returning *DeletePackagePolicyResponse
func (c *ClientWithResponses) DeletePackagePolicyWithResponse(ctx context.Context, packagePolicyId string, params *DeletePackagePolicyParams, reqEditors ...RequestEditorFn) (*DeletePackagePolicyResponse, error) {
	rsp, err := c.DeletePackagePolicy(ctx, packagePolicyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePackagePolicyResponse(rsp)
}

// GetPackagePolicyWithResponse request returning *GetPackagePolicyResponse
func (c *ClientWithResponses) GetPackagePolicyWithResponse(ctx context.Context, packagePolicyId string, params *GetPackagePolicyParams, reqEditors ...RequestEditorFn) (*GetPackagePolicyResponse, error) {
	rsp, err := c.GetPackagePolicy(ctx, packagePolicyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPackagePolicyResponse(rsp)
}

// UpdatePackagePolicyWithBodyWithResponse request with arbitrary body returning *UpdatePackagePolicyResponse
func (c *ClientWithResponses) UpdatePackagePolicyWithBodyWithResponse(ctx context.Context, packagePolicyId string, params *UpdatePackagePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePackagePolicyResponse, error) {
	rsp, err := c.UpdatePackagePolicyWithBody(ctx, packagePolicyId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePackagePolicyResponse(rsp)
}

func (c *ClientWithResponses) UpdatePackagePolicyWithResponse(ctx context.Context, packagePolicyId string, params *UpdatePackagePolicyParams, body UpdatePackagePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePackagePolicyResponse, error) {
	rsp, err := c.UpdatePackagePolicy(ctx, packagePolicyId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePackagePolicyResponse(rsp)
}

// FindSlosOpWithResponse request returning *FindSlosOpResponse
func (c *ClientWithResponses) FindSlosOpWithResponse(ctx context.Context, spaceId SpaceId, params *FindSlosOpParams, reqEditors ...RequestEditorFn) (*FindSlosOpResponse, error) {
	rsp, err := c.FindSlosOp(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindSlosOpResponse(rsp)
}

// CreateSloOpWithBodyWithResponse request with arbitrary body returning *CreateSloOpResponse
func (c *ClientWithResponses) CreateSloOpWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSloOpResponse, error) {
	rsp, err := c.CreateSloOpWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSloOpResponse(rsp)
}

func (c *ClientWithResponses) CreateSloOpWithResponse(ctx context.Context, spaceId SpaceId, body CreateSloOpJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSloOpResponse, error) {
	rsp, err := c.CreateSloOp(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSloOpResponse(rsp)
}

// DeleteSloOpWithResponse request returning *DeleteSloOpResponse
func (c *ClientWithResponses) DeleteSloOpWithResponse(ctx context.Context, spaceId SpaceId, sloId SloId, reqEditors ...RequestEditorFn) (*DeleteSloOpResponse, error) {
	rsp, err := c.DeleteSloOp(ctx, spaceId, sloId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSloOpResponse(rsp)
}

// GetSloOpWithResponse request returning *GetSloOpResponse
func (c *ClientWithResponses) GetSloOpWithResponse(ctx context.Context, spaceId SpaceId, sloId SloId, params *GetSloOpParams, reqEditors ...RequestEditorFn) (*GetSloOpResponse, error) {
	rsp, err := c.GetSloOp(ctx, spaceId, sloId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSloOpResponse(rsp)
}

// UpdateSloOpWithBodyWithResponse request with arbitrary body returning *UpdateSloOpResponse
func (c *ClientWithResponses) UpdateSloOpWithBodyWithResponse(ctx context.Context, spaceId SpaceId, sloId SloId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSloOpResponse, error) {
	rsp, err := c.UpdateSloOpWithBody(ctx, spaceId, sloId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSloOpResponse(rsp)
}

func (c *ClientWithResponses) UpdateSloOpWithResponse(ctx context.Context, spaceId SpaceId, sloId SloId, body UpdateSloOpJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSloOpResponse, error) {
	rsp, err := c.UpdateSloOp(ctx, spaceId, sloId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSloOpResponse(rsp)
}

// GenerateServiceTokenWithResponse request returning *GenerateServiceTokenResponse
func (c *ClientWithResponses) GenerateServiceTokenWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GenerateServiceTokenResponse, error) {
	rsp, err := c.GenerateServiceToken(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateServiceTokenResponse(rsp)
}

// ParseAgentPolicyListResponse parses an HTTP response from a AgentPolicyListWithResponse call
func ParseAgentPolicyListResponse(rsp *http.Response) (*AgentPolicyListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AgentPolicyListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items   []AgentPolicy `json:"items"`
			Page    float32       `json:"page"`
			PerPage float32       `json:"perPage"`
			Total   float32       `json:"total"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreateAgentPolicyResponse parses an HTTP response from a CreateAgentPolicyWithResponse call
func ParseCreateAgentPolicyResponse(rsp *http.Response) (*CreateAgentPolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAgentPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Item *AgentPolicy `json:"item,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDeleteAgentPolicyResponse parses an HTTP response from a DeleteAgentPolicyWithResponse call
func ParseDeleteAgentPolicyResponse(rsp *http.Response) (*DeleteAgentPolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAgentPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Id      string `json:"id"`
			Success bool   `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseAgentPolicyInfoResponse parses an HTTP response from a AgentPolicyInfoWithResponse call
func ParseAgentPolicyInfoResponse(rsp *http.Response) (*AgentPolicyInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AgentPolicyInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Item AgentPolicy `json:"item"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUpdateAgentPolicyResponse parses an HTTP response from a UpdateAgentPolicyWithResponse call
func ParseUpdateAgentPolicyResponse(rsp *http.Response) (*UpdateAgentPolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAgentPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Item AgentPolicy `json:"item"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreateRuleResponse parses an HTTP response from a CreateRuleWithResponse call
func ParseCreateRuleResponse(rsp *http.Response) (*CreateRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RuleResponseProperties
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteRuleResponse parses an HTTP response from a DeleteRuleWithResponse call
func ParseDeleteRuleResponse(rsp *http.Response) (*DeleteRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetRuleResponse parses an HTTP response from a GetRuleWithResponse call
func ParseGetRuleResponse(rsp *http.Response) (*GetRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RuleResponseProperties
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateRuleIdResponse parses an HTTP response from a CreateRuleIdWithResponse call
func ParseCreateRuleIdResponse(rsp *http.Response) (*CreateRuleIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRuleIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RuleResponseProperties
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateRuleResponse parses an HTTP response from a UpdateRuleWithResponse call
func ParseUpdateRuleResponse(rsp *http.Response) (*UpdateRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RuleResponseProperties
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindRulesResponse parses an HTTP response from a FindRulesWithResponse call
func ParseFindRulesResponse(rsp *http.Response) (*FindRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data    []RuleResponseProperties `json:"data,omitempty"`
			Page    *int                     `json:"page,omitempty"`
			PerPage *int                     `json:"per_page,omitempty"`
			Total   *int                     `json:"total,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetAllDataViewsDefaultResponse parses an HTTP response from a GetAllDataViewsDefaultWithResponse call
func ParseGetAllDataViewsDefaultResponse(rsp *http.Response) (*GetAllDataViewsDefaultResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllDataViewsDefaultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			DataView []struct {
				Id         *string                `json:"id,omitempty"`
				Name       *string                `json:"name,omitempty"`
				Namespaces []string               `json:"namespaces,omitempty"`
				Title      *string                `json:"title,omitempty"`
				TypeMeta   map[string]interface{} `json:"typeMeta,omitempty"`
			} `json:"data_view,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreateDataViewDefaultwResponse parses an HTTP response from a CreateDataViewDefaultwWithResponse call
func ParseCreateDataViewDefaultwResponse(rsp *http.Response) (*CreateDataViewDefaultwResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDataViewDefaultwResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DataViewResponseObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDeleteDataViewDefaultResponse parses an HTTP response from a DeleteDataViewDefaultWithResponse call
func ParseDeleteDataViewDefaultResponse(rsp *http.Response) (*DeleteDataViewDefaultResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDataViewDefaultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetDataViewDefaultResponse parses an HTTP response from a GetDataViewDefaultWithResponse call
func ParseGetDataViewDefaultResponse(rsp *http.Response) (*GetDataViewDefaultResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDataViewDefaultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DataViewResponseObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateDataViewDefaultResponse parses an HTTP response from a UpdateDataViewDefaultWithResponse call
func ParseUpdateDataViewDefaultResponse(rsp *http.Response) (*UpdateDataViewDefaultResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateDataViewDefaultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DataViewResponseObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseImportSavedObjectsDefaultResponse parses an HTTP response from a ImportSavedObjectsDefaultWithResponse call
func ParseImportSavedObjectsDefaultResponse(rsp *http.Response) (*ImportSavedObjectsDefaultResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ImportSavedObjectsDefaultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Errors Indicates the import was unsuccessful and specifies the objects that failed to import.
			//
			// NOTE: One object may result in multiple errors, which requires separate steps to resolve. For instance, a `missing_references` error and conflict error.
			Errors []map[string]interface{} `json:"errors,omitempty"`

			// Success Indicates when the import was successfully completed. When set to false, some objects may not have been created. For additional information, refer to the `errors` and `successResults` properties.
			Success *bool `json:"success,omitempty"`

			// SuccessCount Indicates the number of successfully imported records.
			SuccessCount *int `json:"successCount,omitempty"`

			// SuccessResults Indicates the objects that are successfully imported, with any metadata if applicable.
			//
			// NOTE: Objects are created only when all resolvable errors are addressed, including conflicts and missing references. If objects are created as new copies, each entry in the `successResults` array includes a `destinationId` attribute.
			SuccessResults []map[string]interface{} `json:"successResults,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetEnrollmentApiKeysResponse parses an HTTP response from a GetEnrollmentApiKeysWithResponse call
func ParseGetEnrollmentApiKeysResponse(rsp *http.Response) (*GetEnrollmentApiKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEnrollmentApiKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items []EnrollmentApiKey `json:"items"`
			// Deprecated:
			List    []EnrollmentApiKey `json:"list,omitempty"`
			Page    float32            `json:"page"`
			PerPage float32            `json:"perPage"`
			Total   float32            `json:"total"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreateEnrollmentApiKeysResponse parses an HTTP response from a CreateEnrollmentApiKeysWithResponse call
func ParseCreateEnrollmentApiKeysResponse(rsp *http.Response) (*CreateEnrollmentApiKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateEnrollmentApiKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Action *N200Action       `json:"action,omitempty"`
			Item   *EnrollmentApiKey `json:"item,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListAllPackagesResponse parses an HTTP response from a ListAllPackagesWithResponse call
func ParseListAllPackagesResponse(rsp *http.Response) (*ListAllPackagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAllPackagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPackagesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseInstallPackageByUploadResponse parses an HTTP response from a InstallPackageByUploadWithResponse call
func ParseInstallPackageByUploadResponse(rsp *http.Response) (*InstallPackageByUploadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InstallPackageByUploadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				InstallSource *PackageInstallSource `json:"install_source,omitempty"`
			} `json:"_meta,omitempty"`
			Items PackageItem `json:"items"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseDeletePackageResponse parses an HTTP response from a DeletePackageWithResponse call
func ParseDeletePackageResponse(rsp *http.Response) (*DeletePackageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePackageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items PackageItem `json:"items"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetPackageResponse parses an HTTP response from a GetPackageWithResponse call
func ParseGetPackageResponse(rsp *http.Response) (*GetPackageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPackageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Item                 *PackageInfo `json:"item,omitempty"`
			KeepPoliciesUpToDate *bool        `json:"keepPoliciesUpToDate,omitempty"`
			LatestVersion        *string      `json:"latestVersion,omitempty"`
			LicensePath          *string      `json:"licensePath,omitempty"`
			Notice               *string      `json:"notice,omitempty"`
			// Deprecated:
			SavedObject map[string]interface{} `json:"savedObject"`
			Status      PackageStatus          `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseInstallPackageResponse parses an HTTP response from a InstallPackageWithResponse call
func ParseInstallPackageResponse(rsp *http.Response) (*InstallPackageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InstallPackageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				InstallSource *PackageInstallSource `json:"install_source,omitempty"`
			} `json:"_meta,omitempty"`
			Items PackageItem `json:"items"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUpdatePackageResponse parses an HTTP response from a UpdatePackageWithResponse call
func ParseUpdatePackageResponse(rsp *http.Response) (*UpdatePackageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePackageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items PackageItem `json:"items"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetFleetServerHostsResponse parses an HTTP response from a GetFleetServerHostsWithResponse call
func ParseGetFleetServerHostsResponse(rsp *http.Response) (*GetFleetServerHostsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFleetServerHostsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items   []FleetServerHost `json:"items,omitempty"`
			Page    *int              `json:"page,omitempty"`
			PerPage *int              `json:"perPage,omitempty"`
			Total   *int              `json:"total,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostFleetServerHostsResponse parses an HTTP response from a PostFleetServerHostsWithResponse call
func ParsePostFleetServerHostsResponse(rsp *http.Response) (*PostFleetServerHostsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostFleetServerHostsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Item *FleetServerHost `json:"item,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDeleteFleetServerHostsResponse parses an HTTP response from a DeleteFleetServerHostsWithResponse call
func ParseDeleteFleetServerHostsResponse(rsp *http.Response) (*DeleteFleetServerHostsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFleetServerHostsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Id string `json:"id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetOneFleetServerHostsResponse parses an HTTP response from a GetOneFleetServerHostsWithResponse call
func ParseGetOneFleetServerHostsResponse(rsp *http.Response) (*GetOneFleetServerHostsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOneFleetServerHostsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Item FleetServerHost `json:"item"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUpdateFleetServerHostsResponse parses an HTTP response from a UpdateFleetServerHostsWithResponse call
func ParseUpdateFleetServerHostsResponse(rsp *http.Response) (*UpdateFleetServerHostsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateFleetServerHostsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Item FleetServerHost `json:"item"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetOutputsResponse parses an HTTP response from a GetOutputsWithResponse call
func ParseGetOutputsResponse(rsp *http.Response) (*GetOutputsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOutputsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items   []OutputCreateRequest `json:"items,omitempty"`
			Page    *int                  `json:"page,omitempty"`
			PerPage *int                  `json:"perPage,omitempty"`
			Total   *int                  `json:"total,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostOutputsResponse parses an HTTP response from a PostOutputsWithResponse call
func ParsePostOutputsResponse(rsp *http.Response) (*PostOutputsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOutputsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Item *OutputCreateRequest `json:"item,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDeleteOutputResponse parses an HTTP response from a DeleteOutputWithResponse call
func ParseDeleteOutputResponse(rsp *http.Response) (*DeleteOutputResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOutputResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Id string `json:"id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetOutputResponse parses an HTTP response from a GetOutputWithResponse call
func ParseGetOutputResponse(rsp *http.Response) (*GetOutputResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOutputResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Item *OutputCreateRequest `json:"item,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUpdateOutputResponse parses an HTTP response from a UpdateOutputWithResponse call
func ParseUpdateOutputResponse(rsp *http.Response) (*UpdateOutputResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateOutputResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Item *OutputUpdateRequest `json:"item,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetPackagePoliciesResponse parses an HTTP response from a GetPackagePoliciesWithResponse call
func ParseGetPackagePoliciesResponse(rsp *http.Response) (*GetPackagePoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPackagePoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items   []PackagePolicy `json:"items"`
			Page    *float32        `json:"page,omitempty"`
			PerPage *float32        `json:"perPage,omitempty"`
			Total   *float32        `json:"total,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreatePackagePolicyResponse parses an HTTP response from a CreatePackagePolicyWithResponse call
func ParseCreatePackagePolicyResponse(rsp *http.Response) (*CreatePackagePolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePackagePolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Item PackagePolicy `json:"item"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseDeletePackagePolicyResponse parses an HTTP response from a DeletePackagePolicyWithResponse call
func ParseDeletePackagePolicyResponse(rsp *http.Response) (*DeletePackagePolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePackagePolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Id string `json:"id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetPackagePolicyResponse parses an HTTP response from a GetPackagePolicyWithResponse call
func ParseGetPackagePolicyResponse(rsp *http.Response) (*GetPackagePolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPackagePolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Item PackagePolicy `json:"item"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUpdatePackagePolicyResponse parses an HTTP response from a UpdatePackagePolicyWithResponse call
func ParseUpdatePackagePolicyResponse(rsp *http.Response) (*UpdatePackagePolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePackagePolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Item   PackagePolicy `json:"item"`
			Sucess bool          `json:"sucess"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseFindSlosOpResponse parses an HTTP response from a FindSlosOpWithResponse call
func ParseFindSlosOpResponse(rsp *http.Response) (*FindSlosOpResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindSlosOpResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FindSloResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateSloOpResponse parses an HTTP response from a CreateSloOpWithResponse call
func ParseCreateSloOpResponse(rsp *http.Response) (*CreateSloOpResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSloOpResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateSloResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest N409Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseDeleteSloOpResponse parses an HTTP response from a DeleteSloOpWithResponse call
func ParseDeleteSloOpResponse(rsp *http.Response) (*DeleteSloOpResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSloOpResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetSloOpResponse parses an HTTP response from a GetSloOpWithResponse call
func ParseGetSloOpResponse(rsp *http.Response) (*GetSloOpResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSloOpResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SloWithSummaryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateSloOpResponse parses an HTTP response from a UpdateSloOpWithResponse call
func ParseUpdateSloOpResponse(rsp *http.Response) (*UpdateSloOpResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSloOpResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SloDefinitionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGenerateServiceTokenResponse parses an HTTP response from a GenerateServiceTokenWithResponse call
func ParseGenerateServiceTokenResponse(rsp *http.Response) (*GenerateServiceTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenerateServiceTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Name  *string `json:"name,omitempty"`
			Value *string `json:"value,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}
