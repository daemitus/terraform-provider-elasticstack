// Package kibana provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package kibana

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

const (
	BasicAuthScopes = "basicAuth.Scopes"
)

// AgentPolicyInfoResponseObject defines model for agent-policy-info_response_object.
type AgentPolicyInfoResponseObject struct {
	Item AgentPolicy `json:"item"`
}

// AgentPolicyListResponseObject defines model for agent-policy-list_response_object.
type AgentPolicyListResponseObject struct {
	Items   []AgentPolicy `json:"items"`
	Page    float32       `json:"page"`
	PerPage float32       `json:"perPage"`
	Total   float32       `json:"total"`
}

// AgentPolicy defines model for agent_policy.
type AgentPolicy struct {
	// AdvancedSettings Advanced settings stored in the agent policy, e.g. agent_limits_go_max_procs
	AdvancedSettings  map[string]interface{}                                       `json:"advanced_settings"`
	AgentFeatures     []AgentPolicyAgentFeaturesItem                               `json:"agent_features,omitempty"`
	Agents            *float32                                                     `json:"agents,omitempty"`
	DataOutputId      *string                                                      `json:"data_output_id"`
	Description       *string                                                      `json:"description,omitempty"`
	DownloadSourceId  *string                                                      `json:"download_source_id"`
	FleetServerHostId *string                                                      `json:"fleet_server_host_id"`
	GlobalDataTags    []map[string]AgentPolicy_GlobalDataTags_AdditionalProperties `json:"global_data_tags,omitempty"`
	Id                string                                                       `json:"id"`
	InactivityTimeout *int                                                         `json:"inactivity_timeout,omitempty"`

	// IsProtected Indicates whether the agent policy has tamper protection enabled. Default false.
	IsProtected *bool `json:"is_protected,omitempty"`

	// KeepMonitoringAlive When set to true, monitoring will be enabled but logs/metrics collection will be disabled
	KeepMonitoringAlive    *bool                             `json:"keep_monitoring_alive"`
	MonitoringDiagnostics  *AgentPolicyMonitoringDiagnostics `json:"monitoring_diagnostics,omitempty"`
	MonitoringEnabled      []string                          `json:"monitoring_enabled,omitempty"`
	MonitoringHttp         *AgentPolicyMonitoringHttp        `json:"monitoring_http,omitempty"`
	MonitoringOutputId     *string                           `json:"monitoring_output_id"`
	MonitoringPprofEnabled *bool                             `json:"monitoring_pprof_enabled,omitempty"`
	Name                   string                            `json:"name"`
	Namespace              string                            `json:"namespace"`

	// Overrides Override settings that are defined in the agent policy. Input settings cannot be overridden. The override option should be used only in unusual circumstances and not as a routine procedure.
	Overrides map[string]interface{} `json:"overrides"`

	// PackagePolicies This field is present only when retrieving a single agent policy, or when retrieving a list of agent policies with the ?full=true parameter
	PackagePolicies []PackagePolicy `json:"package_policies,omitempty"`
	Revision        *float32        `json:"revision,omitempty"`

	// SupportsAgentless Indicates whether the agent policy supports agentless integrations. Only allowed in a serverless environment.
	SupportsAgentless  *bool      `json:"supports_agentless,omitempty"`
	UnenrollTimeout    *int       `json:"unenroll_timeout,omitempty"`
	UnprivilegedAgents *float32   `json:"unprivileged_agents,omitempty"`
	UpdatedBy          *string    `json:"updated_by,omitempty"`
	UpdatedOn          *time.Time `json:"updated_on,omitempty"`
}

// AgentPolicyGlobalDataTags0 defines model for .
type AgentPolicyGlobalDataTags0 = string

// AgentPolicyGlobalDataTags1 defines model for .
type AgentPolicyGlobalDataTags1 = float32

// AgentPolicy_GlobalDataTags_AdditionalProperties defines model for agent_policy.global_data_tags.AdditionalProperties.
type AgentPolicy_GlobalDataTags_AdditionalProperties struct {
	union json.RawMessage
}

// AgentPolicyAgentFeaturesItem defines model for agent_policy_agent_features_item.
type AgentPolicyAgentFeaturesItem struct {
	Enabled bool   `json:"enabled"`
	Name    string `json:"name"`
}

// AgentPolicyCreateRequest defines model for agent_policy_create_request.
type AgentPolicyCreateRequest struct {
	AgentFeatures     []AgentPolicyCreateRequestAgentFeaturesItem `json:"agent_features,omitempty"`
	DataOutputId      *string                                     `json:"data_output_id"`
	Description       *string                                     `json:"description,omitempty"`
	DownloadSourceId  *string                                     `json:"download_source_id"`
	FleetServerHostId *string                                     `json:"fleet_server_host_id"`

	// Force Force agent policy creation even if packages are not verified.
	Force              *bool                                                                     `json:"force,omitempty"`
	GlobalDataTags     []map[string]AgentPolicyCreateRequest_GlobalDataTags_AdditionalProperties `json:"global_data_tags,omitempty"`
	Id                 *string                                                                   `json:"id,omitempty"`
	InactivityTimeout  *int                                                                      `json:"inactivity_timeout,omitempty"`
	IsProtected        *bool                                                                     `json:"is_protected,omitempty"`
	MonitoringEnabled  []string                                                                  `json:"monitoring_enabled,omitempty"`
	MonitoringOutputId *string                                                                   `json:"monitoring_output_id"`
	Name               string                                                                    `json:"name"`
	Namespace          string                                                                    `json:"namespace"`
	UnenrollTimeout    *int                                                                      `json:"unenroll_timeout,omitempty"`
}

// AgentPolicyCreateRequestGlobalDataTags0 defines model for .
type AgentPolicyCreateRequestGlobalDataTags0 = string

// AgentPolicyCreateRequestGlobalDataTags1 defines model for .
type AgentPolicyCreateRequestGlobalDataTags1 = float32

// AgentPolicyCreateRequest_GlobalDataTags_AdditionalProperties defines model for agent_policy_create_request.global_data_tags.AdditionalProperties.
type AgentPolicyCreateRequest_GlobalDataTags_AdditionalProperties struct {
	union json.RawMessage
}

// AgentPolicyCreateRequestAgentFeaturesItem defines model for agent_policy_create_request_agent_features_item.
type AgentPolicyCreateRequestAgentFeaturesItem struct {
	Enabled bool   `json:"enabled"`
	Name    string `json:"name"`
}

// AgentPolicyMonitoringDiagnostics defines model for agent_policy_monitoring_diagnostics.
type AgentPolicyMonitoringDiagnostics struct {
	Limit    *AgentPolicyMonitoringDiagnosticsLimit    `json:"limit,omitempty"`
	Uploader *AgentPolicyMonitoringDiagnosticsUploader `json:"uploader,omitempty"`
}

// AgentPolicyMonitoringDiagnosticsLimit defines model for agent_policy_monitoring_diagnostics_limit.
type AgentPolicyMonitoringDiagnosticsLimit struct {
	Burst    *float32 `json:"burst,omitempty"`
	Interval *string  `json:"interval,omitempty"`
}

// AgentPolicyMonitoringDiagnosticsUploader defines model for agent_policy_monitoring_diagnostics_uploader.
type AgentPolicyMonitoringDiagnosticsUploader struct {
	InitDur    *string  `json:"init_dur,omitempty"`
	MaxDur     *string  `json:"max_dur,omitempty"`
	MaxRetries *float32 `json:"max_retries,omitempty"`
}

// AgentPolicyMonitoringHttp defines model for agent_policy_monitoring_http.
type AgentPolicyMonitoringHttp struct {
	Enabled bool     `json:"enabled"`
	Host    *string  `json:"host,omitempty"`
	Port    *float32 `json:"port,omitempty"`
}

// AgentPolicyUpdateRequest defines model for agent_policy_update_request.
type AgentPolicyUpdateRequest struct {
	AgentFeatures     []AgentPolicyUpdateRequestAgentFeaturesItem `json:"agent_features,omitempty"`
	DataOutputId      *string                                     `json:"data_output_id"`
	Description       *string                                     `json:"description,omitempty"`
	DownloadSourceId  *string                                     `json:"download_source_id"`
	FleetServerHostId *string                                     `json:"fleet_server_host_id"`

	// Force Force agent policy creation even if packages are not verified.
	Force              *bool    `json:"force,omitempty"`
	InactivityTimeout  *int     `json:"inactivity_timeout,omitempty"`
	IsProtected        *bool    `json:"is_protected,omitempty"`
	MonitoringEnabled  []string `json:"monitoring_enabled,omitempty"`
	MonitoringOutputId *string  `json:"monitoring_output_id"`
	Name               string   `json:"name"`
	Namespace          string   `json:"namespace"`
	UnenrollTimeout    *int     `json:"unenroll_timeout,omitempty"`
}

// AgentPolicyUpdateRequestAgentFeaturesItem defines model for agent_policy_update_request_agent_features_item.
type AgentPolicyUpdateRequestAgentFeaturesItem struct {
	Enabled bool   `json:"enabled"`
	Name    string `json:"name"`
}

// Allownoindex Allows the data view saved object to exist before the data is available.
type Allownoindex = bool

// BudgetingMethod The budgeting method to use when computing the rollup data.
type BudgetingMethod = string

// CreateAgentPolicyResponseObject defines model for create-agent-policy_response_object.
type CreateAgentPolicyResponseObject struct {
	Item *AgentPolicy `json:"item,omitempty"`
}

// CreatePackagePolicyResponseObject defines model for create-package-policy_response_object.
type CreatePackagePolicyResponseObject struct {
	Item PackagePolicy `json:"item"`
}

// CreateConnectorRequest defines model for create_connector_request.
type CreateConnectorRequest struct {
	Config map[string]interface{} `json:"config,omitempty"`

	// ConnectorTypeId The type of connector.
	ConnectorTypeId string `json:"connector_type_id"`

	// Name The display name for the connector.
	Name    string                 `json:"name"`
	Secrets map[string]interface{} `json:"secrets,omitempty"`
}

// CreateConnectorResponseObject defines model for create_connector_response_object.
type CreateConnectorResponseObject struct {
	Config map[string]interface{} `json:"config,omitempty"`

	// ConnectorTypeId The connector type identifier.
	ConnectorTypeId string `json:"connector_type_id"`

	// Id The identifier for the connector.
	Id string `json:"id"`

	// IsDeprecated Indicates whether the connector is deprecated.
	IsDeprecated bool `json:"is_deprecated"`

	// IsMissingSecrets Indicates whether the connector is missing secrets.
	IsMissingSecrets *bool `json:"is_missing_secrets,omitempty"`

	// IsPreconfigured Indicates whether the connector is preconfigured. If true, the `config` and `is_missing_secrets` properties are omitted from the response.
	IsPreconfigured bool `json:"is_preconfigured"`

	// IsSystemAction Indicates whether the connector is used for system actions.
	IsSystemAction bool `json:"is_system_action"`

	// Name  The name of the rule.
	Name string `json:"name"`
}

// CreateDataViewRequestObject defines model for create_data_view_request_object.
type CreateDataViewRequestObject struct {
	// DataView The data view object.
	DataView CreateDataViewRequestObjectDataView `json:"data_view"`

	// Override Override an existing data view if a data view with the provided title already exists.
	Override *bool `json:"override,omitempty"`
}

// CreateDataViewRequestObjectDataView The data view object.
type CreateDataViewRequestObjectDataView struct {
	// AllowNoIndex Allows the data view saved object to exist before the data is available.
	AllowNoIndex *Allownoindex         `json:"allowNoIndex,omitempty"`
	FieldAttrs   map[string]Fieldattrs `json:"fieldAttrs,omitempty"`

	// FieldFormats A map of field formats by field name.
	FieldFormats Fieldformats           `json:"fieldFormats,omitempty"`
	Fields       map[string]interface{} `json:"fields,omitempty"`
	Id           *string                `json:"id,omitempty"`

	// Name The data view name.
	Name *string `json:"name,omitempty"`

	// Namespaces An array of space identifiers for sharing the data view between multiple spaces.
	Namespaces      Namespaces                 `json:"namespaces,omitempty"`
	RuntimeFieldMap map[string]Runtimefieldmap `json:"runtimeFieldMap,omitempty"`

	// SourceFilters The array of field names you want to filter out in Discover.
	SourceFilters Sourcefilters `json:"sourceFilters,omitempty"`

	// TimeFieldName The timestamp field name, which you use for time-based data views.
	TimeFieldName *Timefieldname `json:"timeFieldName,omitempty"`

	// Title Comma-separated list of data streams, indices, and aliases that you want to search. Supports wildcards (`*`).
	Title Title `json:"title"`

	// Type When set to `rollup`, identifies the rollup data views.
	Type *Type `json:"type,omitempty"`

	// TypeMeta When you use rollup indices, contains the field list for the rollup data view API endpoints.
	TypeMeta *Typemeta `json:"typeMeta,omitempty"`
	Version  *string   `json:"version,omitempty"`
}

// CreateRuleRequest defines model for create_rule_request.
type CreateRuleRequest struct {
	Actions []CreateRuleRequestActionsItem `json:"actions,omitempty"`

	// AlertDelay Indicates that an alert occurs only when the specified number of consecutive runs met the rule conditions.
	AlertDelay *CreateRuleRequestAlertDelay `json:"alert_delay,omitempty"`

	// Consumer The name of the application or feature that owns the rule. For example: `alerts`, `apm`, `discover`, `infrastructure`, `logs`, `metrics`, `ml`, `monitoring`, `securitySolution`, `siem`, `stackAlerts`, or `uptime`.
	Consumer string `json:"consumer"`

	// Enabled Indicates whether you want to run the rule on an interval basis after it is created.
	Enabled *bool `json:"enabled,omitempty"`

	// Name The name of the rule. While this name does not have to be unique, a distinctive name can help you identify a rule.
	Name string `json:"name"`

	// NotifyWhen Indicates how often alerts generate actions. Valid values include: `onActionGroupChange`: Actions run when the alert status changes; `onActiveAlert`: Actions run when the alert becomes active and at each check interval while the rule conditions are met; `onThrottleInterval`: Actions run when the alert becomes active and at the interval specified in the throttle property while the rule conditions are met. NOTE: You cannot specify `notify_when` at both the rule and action level. The recommended method is to set it for each action. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	NotifyWhen *string `json:"notify_when"`

	// Params The parameters for the rule.
	Params map[string]interface{} `json:"params,omitempty"`

	// RuleTypeId The rule type identifier.
	RuleTypeId string `json:"rule_type_id"`

	// Schedule The check interval, which specifies how frequently the rule conditions are checked.
	Schedule CreateRuleRequestSchedule `json:"schedule"`

	// Tags The tags for the rule.
	Tags []string `json:"tags,omitempty"`

	// Throttle Use the `throttle` property in the action `frequency` object instead. The throttle interval, which defines how often an alert generates repeated actions. NOTE: You cannot specify the throttle interval at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	Throttle *string `json:"throttle"`
}

// CreateRuleRequestActionsItem An action that runs under defined conditions.
type CreateRuleRequestActionsItem struct {
	// AlertsFilter Conditions that affect whether the action runs. If you specify multiple conditions, all conditions must be met for the action to run. For example, if an alert occurs within the specified time frame and matches the query, the action runs.
	AlertsFilter *CreateRuleRequestActionsItemAlertsFilter `json:"alerts_filter,omitempty"`
	Frequency    *CreateRuleRequestActionsItemFrequency    `json:"frequency,omitempty"`

	// Group The group name, which affects when the action runs (for example, when the threshold is met or when the alert is recovered). Each rule type has a list of valid action group names. If you don't need to group actions, set to `default`.
	Group *string `json:"group,omitempty"`

	// Id The identifier for the connector saved object.
	Id string `json:"id"`

	// Params The parameters for the action, which are sent to the connector. The `params` are handled as Mustache templates and passed a default set of context.
	Params map[string]interface{} `json:"params,omitempty"`

	// UseAlertDataForTemplate Indicates whether to use alert data as a template.
	UseAlertDataForTemplate *bool `json:"use_alert_data_for_template,omitempty"`

	// Uuid A universally unique identifier (UUID) for the action.
	Uuid *string `json:"uuid,omitempty"`
}

// CreateRuleRequestActionsItemAlertsFilter Conditions that affect whether the action runs. If you specify multiple conditions, all conditions must be met for the action to run. For example, if an alert occurs within the specified time frame and matches the query, the action runs.
type CreateRuleRequestActionsItemAlertsFilter struct {
	Query *CreateRuleRequestActionsItemAlertsFilterQuery `json:"query,omitempty"`

	// Timeframe Defines a period that limits whether the action runs.
	Timeframe *CreateRuleRequestActionsItemAlertsFilterTimeframe `json:"timeframe,omitempty"`
}

// CreateRuleRequestActionsItemAlertsFilterQuery defines model for create_rule_request_actions_item_alerts_filter_query.
type CreateRuleRequestActionsItemAlertsFilterQuery struct {
	// Dsl A filter written in Elasticsearch Query Domain Specific Language (DSL).
	Dsl *string `json:"dsl,omitempty"`

	// Filters A filter written in Elasticsearch Query Domain Specific Language (DSL) as defined in the `kbn-es-query` package.
	Filters []CreateRuleRequestActionsItemAlertsFilterQueryFiltersItem `json:"filters"`

	// Kql A filter written in Kibana Query Language (KQL).
	Kql string `json:"kql"`
}

// CreateRuleRequestActionsItemAlertsFilterQueryFiltersItem defines model for create_rule_request_actions_item_alerts_filter_query_filters_item.
type CreateRuleRequestActionsItemAlertsFilterQueryFiltersItem struct {
	State *CreateRuleRequestActionsItemAlertsFilterQueryFiltersItemState `json:"$state,omitempty"`
	Meta  map[string]interface{}                                         `json:"meta"`
	Query map[string]interface{}                                         `json:"query,omitempty"`
}

// CreateRuleRequestActionsItemAlertsFilterQueryFiltersItemState defines model for create_rule_request_actions_item_alerts_filter_query_filters_item_$state.
type CreateRuleRequestActionsItemAlertsFilterQueryFiltersItemState struct {
	// Store A filter can be either specific to an application context or applied globally.
	Store string `json:"store"`
}

// CreateRuleRequestActionsItemAlertsFilterTimeframe Defines a period that limits whether the action runs.
type CreateRuleRequestActionsItemAlertsFilterTimeframe struct {
	// Days Defines the days of the week that the action can run, represented as an array of numbers. For example, `1` represents Monday. An empty array is equivalent to specifying all the days of the week.
	Days []int `json:"days"`

	// Hours Defines the range of time in a day that the action can run. If the `start` value is `00:00` and the `end` value is `24:00`, actions be generated all day.
	Hours CreateRuleRequestActionsItemAlertsFilterTimeframeHours `json:"hours"`

	// Timezone The ISO time zone for the `hours` values. Values such as `UTC` and `UTC+1` also work but lack built-in daylight savings time support and are not recommended.
	Timezone string `json:"timezone"`
}

// CreateRuleRequestActionsItemAlertsFilterTimeframeHours Defines the range of time in a day that the action can run. If the `start` value is `00:00` and the `end` value is `24:00`, actions be generated all day.
type CreateRuleRequestActionsItemAlertsFilterTimeframeHours struct {
	// End The end of the time frame in 24-hour notation (`hh:mm`).
	End string `json:"end"`

	// Start The start of the time frame in 24-hour notation (`hh:mm`).
	Start string `json:"start"`
}

// CreateRuleRequestActionsItemFrequency defines model for create_rule_request_actions_item_frequency.
type CreateRuleRequestActionsItemFrequency struct {
	// NotifyWhen Indicates how often alerts generate actions. Valid values include: `onActionGroupChange`: Actions run when the alert status changes; `onActiveAlert`: Actions run when the alert becomes active and at each check interval while the rule conditions are met; `onThrottleInterval`: Actions run when the alert becomes active and at the interval specified in the throttle property while the rule conditions are met. NOTE: You cannot specify `notify_when` at both the rule and action level. The recommended method is to set it for each action. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	NotifyWhen string `json:"notify_when"`

	// Summary Indicates whether the action is a summary.
	Summary bool `json:"summary"`

	// Throttle The throttle interval, which defines how often an alert generates repeated actions. It is specified in seconds, minutes, hours, or days and is applicable only if `notify_when` is set to `onThrottleInterval`. NOTE: You cannot specify the throttle interval at both the rule and action level. The recommended method is to set it for each action. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	Throttle *string `json:"throttle"`
}

// CreateRuleRequestAlertDelay Indicates that an alert occurs only when the specified number of consecutive runs met the rule conditions.
type CreateRuleRequestAlertDelay struct {
	// Active The number of consecutive runs that must meet the rule conditions.
	Active float32 `json:"active"`
}

// CreateRuleRequestSchedule The check interval, which specifies how frequently the rule conditions are checked.
type CreateRuleRequestSchedule struct {
	// Interval The interval is specified in seconds, minutes, hours, or days.
	Interval string `json:"interval"`
}

// CreateRuleResponseObject defines model for create_rule_response_object.
type CreateRuleResponseObject struct {
	Actions       []CreateRuleResponseObjectActionsItem `json:"actions"`
	ActiveSnoozes []string                              `json:"active_snoozes,omitempty"`

	// AlertDelay Indicates that an alert occurs only when the specified number of consecutive runs met the rule conditions.
	AlertDelay *CreateRuleResponseObjectAlertDelay `json:"alert_delay,omitempty"`

	// ApiKeyCreatedByUser Indicates whether the API key that is associated with the rule was created by the user.
	ApiKeyCreatedByUser *bool `json:"api_key_created_by_user"`

	// ApiKeyOwner The owner of the API key that is associated with the rule and used to run background tasks.
	ApiKeyOwner *string `json:"api_key_owner"`

	// Consumer The name of the application or feature that owns the rule. For example: `alerts`, `apm`, `discover`, `infrastructure`, `logs`, `metrics`, `ml`, `monitoring`, `securitySolution`, `siem`, `stackAlerts`, or `uptime`.
	Consumer string `json:"consumer"`

	// CreatedAt The date and time that the rule was created.
	CreatedAt string `json:"created_at"`

	// CreatedBy The identifier for the user that created the rule.
	CreatedBy *string `json:"created_by"`

	// Enabled Indicates whether you want to run the rule on an interval basis after it is created.
	Enabled         bool                                    `json:"enabled"`
	ExecutionStatus CreateRuleResponseObjectExecutionStatus `json:"execution_status"`

	// Id The identifier for the rule.
	Id string `json:"id"`

	// IsSnoozedUntil The date when the rule will no longer be snoozed.
	IsSnoozedUntil *string                          `json:"is_snoozed_until"`
	LastRun        *CreateRuleResponseObjectLastRun `json:"last_run"`
	MappedParams   map[string]interface{}           `json:"mapped_params,omitempty"`

	// Monitoring Monitoring details of the rule.
	Monitoring *CreateRuleResponseObjectMonitoring `json:"monitoring,omitempty"`

	// MuteAll Indicates whether all alerts are muted.
	MuteAll       bool     `json:"mute_all"`
	MutedAlertIds []string `json:"muted_alert_ids"`

	// Name  The name of the rule.
	Name string `json:"name"`

	// NextRun Date and time of the next run of the rule.
	NextRun *string `json:"next_run"`

	// NotifyWhen Indicates how often alerts generate actions. Valid values include: `onActionGroupChange`: Actions run when the alert status changes; `onActiveAlert`: Actions run when the alert becomes active and at each check interval while the rule conditions are met; `onThrottleInterval`: Actions run when the alert becomes active and at the interval specified in the throttle property while the rule conditions are met. NOTE: You cannot specify `notify_when` at both the rule and action level. The recommended method is to set it for each action. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	NotifyWhen *string `json:"notify_when"`

	// Params The parameters for the rule.
	Params map[string]interface{} `json:"params"`

	// Revision The rule revision number.
	Revision float32 `json:"revision"`

	// RuleTypeId The rule type identifier.
	RuleTypeId string `json:"rule_type_id"`

	// Running Indicates whether the rule is running.
	Running  *bool                            `json:"running"`
	Schedule CreateRuleResponseObjectSchedule `json:"schedule"`

	// ScheduledTaskId Identifier of the scheduled task.
	ScheduledTaskId *string                                      `json:"scheduled_task_id,omitempty"`
	SnoozeSchedule  []CreateRuleResponseObjectSnoozeScheduleItem `json:"snooze_schedule,omitempty"`
	Tags            []string                                     `json:"tags"`

	// Throttle Deprecated in 8.13.0. Use the `throttle` property in the action `frequency` object instead. The throttle interval, which defines how often an alert generates repeated actions. NOTE: You cannot specify the throttle interval at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	Throttle *string `json:"throttle"`

	// UpdatedAt The date and time that the rule was updated most recently.
	UpdatedAt string `json:"updated_at"`

	// UpdatedBy The identifier for the user that updated this rule most recently.
	UpdatedBy *string `json:"updated_by"`

	// ViewInAppRelativeUrl Relative URL to view rule in the app.
	ViewInAppRelativeUrl *string `json:"view_in_app_relative_url"`
}

// CreateRuleResponseObjectActionsItem defines model for create_rule_response_object_actions_item.
type CreateRuleResponseObjectActionsItem struct {
	// AlertsFilter Defines a period that limits whether the action runs.
	AlertsFilter *CreateRuleResponseObjectActionsItemAlertsFilter `json:"alerts_filter,omitempty"`

	// ConnectorTypeId The type of connector. This property appears in responses but cannot be set in requests.
	ConnectorTypeId string                                        `json:"connector_type_id"`
	Frequency       *CreateRuleResponseObjectActionsItemFrequency `json:"frequency,omitempty"`

	// Group The group name, which affects when the action runs (for example, when the threshold is met or when the alert is recovered). Each rule type has a list of valid action group names. If you don't need to group actions, set to `default`.
	Group *string `json:"group,omitempty"`

	// Id The identifier for the connector saved object.
	Id string `json:"id"`

	// Params The parameters for the action, which are sent to the connector. The `params` are handled as Mustache templates and passed a default set of context.
	Params map[string]interface{} `json:"params"`

	// UseAlertDataForTemplate Indicates whether to use alert data as a template.
	UseAlertDataForTemplate *bool `json:"use_alert_data_for_template,omitempty"`

	// Uuid A universally unique identifier (UUID) for the action.
	Uuid *string `json:"uuid,omitempty"`
}

// CreateRuleResponseObjectActionsItemAlertsFilter Defines a period that limits whether the action runs.
type CreateRuleResponseObjectActionsItemAlertsFilter struct {
	Query     *CreateRuleResponseObjectActionsItemAlertsFilterQuery     `json:"query,omitempty"`
	Timeframe *CreateRuleResponseObjectActionsItemAlertsFilterTimeframe `json:"timeframe,omitempty"`
}

// CreateRuleResponseObjectActionsItemAlertsFilterQuery defines model for create_rule_response_object_actions_item_alerts_filter_query.
type CreateRuleResponseObjectActionsItemAlertsFilterQuery struct {
	// Dsl A filter written in Elasticsearch Query Domain Specific Language (DSL).
	Dsl *string `json:"dsl,omitempty"`

	// Filters A filter written in Elasticsearch Query Domain Specific Language (DSL) as defined in the `kbn-es-query` package.
	Filters []CreateRuleResponseObjectActionsItemAlertsFilterQueryFiltersItem `json:"filters"`

	// Kql A filter written in Kibana Query Language (KQL).
	Kql string `json:"kql"`
}

// CreateRuleResponseObjectActionsItemAlertsFilterQueryFiltersItem defines model for create_rule_response_object_actions_item_alerts_filter_query_filters_item.
type CreateRuleResponseObjectActionsItemAlertsFilterQueryFiltersItem struct {
	State *CreateRuleResponseObjectActionsItemAlertsFilterQueryFiltersItemState `json:"$state,omitempty"`
	Meta  map[string]interface{}                                                `json:"meta"`
	Query map[string]interface{}                                                `json:"query,omitempty"`
}

// CreateRuleResponseObjectActionsItemAlertsFilterQueryFiltersItemState defines model for create_rule_response_object_actions_item_alerts_filter_query_filters_item_$state.
type CreateRuleResponseObjectActionsItemAlertsFilterQueryFiltersItemState struct {
	// Store A filter can be either specific to an application context or applied globally.
	Store string `json:"store"`
}

// CreateRuleResponseObjectActionsItemAlertsFilterTimeframe defines model for create_rule_response_object_actions_item_alerts_filter_timeframe.
type CreateRuleResponseObjectActionsItemAlertsFilterTimeframe struct {
	// Days Defines the days of the week that the action can run, represented as an array of numbers. For example, `1` represents Monday. An empty array is equivalent to specifying all the days of the week.
	Days  []int                                                         `json:"days"`
	Hours CreateRuleResponseObjectActionsItemAlertsFilterTimeframeHours `json:"hours"`

	// Timezone The ISO time zone for the `hours` values. Values such as `UTC` and `UTC+1` also work but lack built-in daylight savings time support and are not recommended.
	Timezone string `json:"timezone"`
}

// CreateRuleResponseObjectActionsItemAlertsFilterTimeframeHours defines model for create_rule_response_object_actions_item_alerts_filter_timeframe_hours.
type CreateRuleResponseObjectActionsItemAlertsFilterTimeframeHours struct {
	// End The end of the time frame in 24-hour notation (`hh:mm`).
	End string `json:"end"`

	// Start The start of the time frame in 24-hour notation (`hh:mm`).
	Start string `json:"start"`
}

// CreateRuleResponseObjectActionsItemFrequency defines model for create_rule_response_object_actions_item_frequency.
type CreateRuleResponseObjectActionsItemFrequency struct {
	// NotifyWhen Indicates how often alerts generate actions. Valid values include: `onActionGroupChange`: Actions run when the alert status changes; `onActiveAlert`: Actions run when the alert becomes active and at each check interval while the rule conditions are met; `onThrottleInterval`: Actions run when the alert becomes active and at the interval specified in the throttle property while the rule conditions are met. NOTE: You cannot specify `notify_when` at both the rule and action level. The recommended method is to set it for each action. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	NotifyWhen string `json:"notify_when"`

	// Summary Indicates whether the action is a summary.
	Summary bool `json:"summary"`

	// Throttle The throttle interval, which defines how often an alert generates repeated actions. It is specified in seconds, minutes, hours, or days and is applicable only if 'notify_when' is set to 'onThrottleInterval'. NOTE: You cannot specify the throttle interval at both the rule and action level. The recommended method is to set it for each action. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	Throttle *string `json:"throttle"`
}

// CreateRuleResponseObjectAlertDelay Indicates that an alert occurs only when the specified number of consecutive runs met the rule conditions.
type CreateRuleResponseObjectAlertDelay struct {
	// Active The number of consecutive runs that must meet the rule conditions.
	Active float32 `json:"active"`
}

// CreateRuleResponseObjectExecutionStatus defines model for create_rule_response_object_execution_status.
type CreateRuleResponseObjectExecutionStatus struct {
	Error *CreateRuleResponseObjectExecutionStatusError `json:"error,omitempty"`

	// LastDuration Duration of last execution of the rule.
	LastDuration *float32 `json:"last_duration,omitempty"`

	// LastExecutionDate The date and time when rule was executed last.
	LastExecutionDate string `json:"last_execution_date"`

	// Status Status of rule execution.
	Status  string                                          `json:"status"`
	Warning *CreateRuleResponseObjectExecutionStatusWarning `json:"warning,omitempty"`
}

// CreateRuleResponseObjectExecutionStatusError defines model for create_rule_response_object_execution_status_error.
type CreateRuleResponseObjectExecutionStatusError struct {
	// Message Error message.
	Message string `json:"message"`

	// Reason Reason for error.
	Reason string `json:"reason"`
}

// CreateRuleResponseObjectExecutionStatusWarning defines model for create_rule_response_object_execution_status_warning.
type CreateRuleResponseObjectExecutionStatusWarning struct {
	// Message Warning message.
	Message string `json:"message"`

	// Reason Reason for warning.
	Reason string `json:"reason"`
}

// CreateRuleResponseObjectLastRun defines model for create_rule_response_object_last_run.
type CreateRuleResponseObjectLastRun struct {
	AlertsCount CreateRuleResponseObjectLastRunAlertsCount `json:"alerts_count"`

	// Outcome Outcome of last run of the rule. Value could be succeeded, warning or failed.
	Outcome    string   `json:"outcome"`
	OutcomeMsg []string `json:"outcome_msg"`

	// OutcomeOrder Order of the outcome.
	OutcomeOrder *float32 `json:"outcome_order,omitempty"`

	// Warning Warning of last rule execution.
	Warning *string `json:"warning"`
}

// CreateRuleResponseObjectLastRunAlertsCount defines model for create_rule_response_object_last_run_alerts_count.
type CreateRuleResponseObjectLastRunAlertsCount struct {
	// Active Number of active alerts during last run.
	Active *float32 `json:"active"`

	// Ignored Number of ignored alerts during last run.
	Ignored *float32 `json:"ignored"`

	// New Number of new alerts during last run.
	New *float32 `json:"new"`

	// Recovered Number of recovered alerts during last run.
	Recovered *float32 `json:"recovered"`
}

// CreateRuleResponseObjectMonitoring Monitoring details of the rule.
type CreateRuleResponseObjectMonitoring struct {
	// Run Rule run details.
	Run CreateRuleResponseObjectMonitoringRun `json:"run"`
}

// CreateRuleResponseObjectMonitoringRun Rule run details.
type CreateRuleResponseObjectMonitoringRun struct {
	// CalculatedMetrics Calculation of different percentiles and success ratio.
	CalculatedMetrics CreateRuleResponseObjectMonitoringRunCalculatedMetrics `json:"calculated_metrics"`

	// History History of the rule run.
	History []CreateRuleResponseObjectMonitoringRunHistoryItem `json:"history"`
	LastRun CreateRuleResponseObjectMonitoringRunLastRun       `json:"last_run"`
}

// CreateRuleResponseObjectMonitoringRunCalculatedMetrics Calculation of different percentiles and success ratio.
type CreateRuleResponseObjectMonitoringRunCalculatedMetrics struct {
	P50          *float32 `json:"p50,omitempty"`
	P95          *float32 `json:"p95,omitempty"`
	P99          *float32 `json:"p99,omitempty"`
	SuccessRatio float32  `json:"success_ratio"`
}

// CreateRuleResponseObjectMonitoringRunHistoryItem defines model for create_rule_response_object_monitoring_run_history_item.
type CreateRuleResponseObjectMonitoringRunHistoryItem struct {
	// Duration Duration of the rule run.
	Duration *float32                                                 `json:"duration,omitempty"`
	Outcome  *CreateRuleResponseObjectMonitoringRunHistoryItemOutcome `json:"outcome,omitempty"`

	// Success Indicates whether the rule run was successful.
	Success bool `json:"success"`

	// Timestamp Time of rule run.
	Timestamp float32 `json:"timestamp"`
}

// CreateRuleResponseObjectMonitoringRunHistoryItemOutcome defines model for create_rule_response_object_monitoring_run_history_item_outcome.
type CreateRuleResponseObjectMonitoringRunHistoryItemOutcome struct {
	AlertsCount CreateRuleResponseObjectMonitoringRunHistoryItemOutcomeAlertsCount `json:"alerts_count"`

	// Outcome Outcome of last run of the rule. Value could be succeeded, warning or failed.
	Outcome    string   `json:"outcome"`
	OutcomeMsg []string `json:"outcome_msg"`

	// OutcomeOrder Order of the outcome.
	OutcomeOrder *float32 `json:"outcome_order,omitempty"`

	// Warning Warning of last rule execution.
	Warning *string `json:"warning"`
}

// CreateRuleResponseObjectMonitoringRunHistoryItemOutcomeAlertsCount defines model for create_rule_response_object_monitoring_run_history_item_outcome_alerts_count.
type CreateRuleResponseObjectMonitoringRunHistoryItemOutcomeAlertsCount struct {
	// Active Number of active alerts during last run.
	Active *float32 `json:"active"`

	// Ignored Number of ignored alerts during last run.
	Ignored *float32 `json:"ignored"`

	// New Number of new alerts during last run.
	New *float32 `json:"new"`

	// Recovered Number of recovered alerts during last run.
	Recovered *float32 `json:"recovered"`
}

// CreateRuleResponseObjectMonitoringRunLastRun defines model for create_rule_response_object_monitoring_run_last_run.
type CreateRuleResponseObjectMonitoringRunLastRun struct {
	Metrics CreateRuleResponseObjectMonitoringRunLastRunMetrics `json:"metrics"`

	// Timestamp Time of the most recent rule run.
	Timestamp string `json:"timestamp"`
}

// CreateRuleResponseObjectMonitoringRunLastRunMetrics defines model for create_rule_response_object_monitoring_run_last_run_metrics.
type CreateRuleResponseObjectMonitoringRunLastRunMetrics struct {
	// Duration Duration of most recent rule run.
	Duration *float32 `json:"duration,omitempty"`

	// GapDurationS Duration in seconds of rule run gap.
	GapDurationS *float32 `json:"gap_duration_s"`

	// TotalAlertsCreated Total number of alerts created during last rule run.
	TotalAlertsCreated *float32 `json:"total_alerts_created"`

	// TotalAlertsDetected Total number of alerts detected during last rule run.
	TotalAlertsDetected *float32 `json:"total_alerts_detected"`

	// TotalIndexingDurationMs Total time spent indexing documents during last rule run in milliseconds.
	TotalIndexingDurationMs *float32 `json:"total_indexing_duration_ms"`

	// TotalSearchDurationMs Total time spent performing Elasticsearch searches as measured by Kibana; includes network latency and time spent serializing or deserializing the request and response.
	TotalSearchDurationMs *float32 `json:"total_search_duration_ms"`
}

// CreateRuleResponseObjectSchedule defines model for create_rule_response_object_schedule.
type CreateRuleResponseObjectSchedule struct {
	// Interval The interval is specified in seconds, minutes, hours, or days.
	Interval string `json:"interval"`
}

// CreateRuleResponseObjectSnoozeScheduleItem defines model for create_rule_response_object_snooze_schedule_item.
type CreateRuleResponseObjectSnoozeScheduleItem struct {
	// Duration Duration of the rule snooze schedule.
	Duration float32 `json:"duration"`

	// Id Identifier of the rule snooze schedule.
	Id              *string                                         `json:"id,omitempty"`
	RRule           CreateRuleResponseObjectSnoozeScheduleItemRRule `json:"rRule"`
	SkipRecurrences []string                                        `json:"skipRecurrences,omitempty"`
}

// CreateRuleResponseObjectSnoozeScheduleItemRRule defines model for create_rule_response_object_snooze_schedule_item_rRule.
type CreateRuleResponseObjectSnoozeScheduleItemRRule struct {
	Byhour     []float32                                                        `json:"byhour,omitempty"`
	Byminute   []float32                                                        `json:"byminute,omitempty"`
	Bymonth    []float32                                                        `json:"bymonth,omitempty"`
	Bymonthday []float32                                                        `json:"bymonthday,omitempty"`
	Bysecond   []float32                                                        `json:"bysecond,omitempty"`
	Bysetpos   []float32                                                        `json:"bysetpos,omitempty"`
	Byweekday  []CreateRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item `json:"byweekday,omitempty"`
	Byweekno   []float32                                                        `json:"byweekno,omitempty"`
	Byyearday  []float32                                                        `json:"byyearday,omitempty"`

	// Count Number of times the rule should recur until it stops.
	Count *float32 `json:"count,omitempty"`

	// Dtstart Rule start date in Coordinated Universal Time (UTC).
	Dtstart string `json:"dtstart"`

	// Freq Indicates frequency of the rule. Options are YEARLY, MONTHLY, WEEKLY, DAILY.
	Freq *int `json:"freq,omitempty"`

	// Interval Indicates the interval of frequency. For example, 1 and YEARLY is every 1 year, 2 and WEEKLY is every 2 weeks.
	Interval *float32 `json:"interval,omitempty"`

	// Tzid Indicates timezone abbreviation.
	Tzid string `json:"tzid"`

	// Until Recur the rule until this date.
	Until *string `json:"until,omitempty"`

	// Wkst Indicates the start of week, defaults to Monday.
	Wkst *string `json:"wkst,omitempty"`
}

// CreateRuleResponseObjectSnoozeScheduleItemRRuleByweekday0 defines model for .
type CreateRuleResponseObjectSnoozeScheduleItemRRuleByweekday0 = string

// CreateRuleResponseObjectSnoozeScheduleItemRRuleByweekday1 defines model for .
type CreateRuleResponseObjectSnoozeScheduleItemRRuleByweekday1 = float32

// CreateRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item Indicates the days of the week to recur or else nth-day-of-month strings. For example, "+2TU" second Tuesday of month, "-1FR" last Friday of the month, which are internally converted to a `byweekday/bysetpos` combination.
type CreateRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item struct {
	union json.RawMessage
}

// CreateSloRequest The create SLO API request body varies depending on the type of indicator, time window and budgeting method.
type CreateSloRequest struct {
	// BudgetingMethod The budgeting method to use when computing the rollup data.
	BudgetingMethod BudgetingMethod `json:"budgetingMethod"`

	// Description A description for the SLO.
	Description string `json:"description"`

	// GroupBy optional group by field to use to generate an SLO per distinct value
	GroupBy *string `json:"groupBy,omitempty"`

	// Id A optional and unique identifier for the SLO. Must be between 8 and 36 chars
	Id        *string                    `json:"id,omitempty"`
	Indicator CreateSloRequest_Indicator `json:"indicator"`

	// Name A name for the SLO.
	Name string `json:"name"`

	// Objective Defines properties for the SLO objective
	Objective Objective `json:"objective"`

	// Settings Defines properties for SLO settings.
	Settings *Settings `json:"settings,omitempty"`

	// Tags List of tags
	Tags []string `json:"tags,omitempty"`

	// TimeWindow Defines properties for the SLO time window
	TimeWindow TimeWindow `json:"timeWindow"`
}

// CreateSloRequest_Indicator defines model for CreateSloRequest.Indicator.
type CreateSloRequest_Indicator struct {
	union json.RawMessage
}

// CreateSloResponse defines model for create_slo_response.
type CreateSloResponse struct {
	Id string `json:"id"`
}

// DataViewResponseObject defines model for data_view_response_object.
type DataViewResponseObject struct {
	DataView *DataViewResponseObjectDataView `json:"data_view,omitempty"`
}

// DataViewResponseObjectDataView defines model for data_view_response_object_data_view.
type DataViewResponseObjectDataView struct {
	// AllowNoIndex Allows the data view saved object to exist before the data is available.
	AllowNoIndex *Allownoindex         `json:"allowNoIndex,omitempty"`
	FieldAttrs   map[string]Fieldattrs `json:"fieldAttrs,omitempty"`

	// FieldFormats A map of field formats by field name.
	FieldFormats Fieldformats           `json:"fieldFormats,omitempty"`
	Fields       map[string]interface{} `json:"fields,omitempty"`
	Id           *string                `json:"id,omitempty"`

	// Name The data view name.
	Name *string `json:"name,omitempty"`

	// Namespaces An array of space identifiers for sharing the data view between multiple spaces.
	Namespaces      Namespaces                 `json:"namespaces,omitempty"`
	RuntimeFieldMap map[string]Runtimefieldmap `json:"runtimeFieldMap,omitempty"`

	// SourceFilters The array of field names you want to filter out in Discover.
	SourceFilters Sourcefilters `json:"sourceFilters,omitempty"`

	// TimeFieldName The timestamp field name, which you use for time-based data views.
	TimeFieldName *Timefieldname `json:"timeFieldName,omitempty"`

	// Title Comma-separated list of data streams, indices, and aliases that you want to search. Supports wildcards (`*`).
	Title *Title `json:"title,omitempty"`

	// TypeMeta When you use rollup indices, contains the field list for the rollup data view API endpoints.
	TypeMeta *TypemetaResponse `json:"typeMeta"`
	Version  *string           `json:"version,omitempty"`
}

// DeleteAgentPolicyRequest defines model for delete-agent-policy_request.
type DeleteAgentPolicyRequest struct {
	AgentPolicyId string `json:"agentPolicyId"`

	// Force bypass validation checks that can prevent agent policy deletion
	Force *bool `json:"force,omitempty"`
}

// DeleteAgentPolicyResponseObject defines model for delete-agent-policy_response_object.
type DeleteAgentPolicyResponseObject struct {
	Id      string `json:"id"`
	Success bool   `json:"success"`
}

// DeleteFleetServerHostsResponseObject defines model for delete-fleet-server-hosts_response_object.
type DeleteFleetServerHostsResponseObject struct {
	Id string `json:"id"`
}

// DeleteOutputResponseObject defines model for delete-output_response_object.
type DeleteOutputResponseObject struct {
	Id string `json:"id"`
}

// DeletePackagePolicyResponseObject defines model for delete-package-policy_response_object.
type DeletePackagePolicyResponseObject struct {
	Id string `json:"id"`
}

// DeletePackageRequest defines model for delete-package_request.
type DeletePackageRequest struct {
	Force *bool `json:"force,omitempty"`
}

// DeletePackageResponseObject defines model for delete-package_response_object.
type DeletePackageResponseObject struct {
	Items []DeletePackageResponseObjectItemItem `json:"items"`
}

// DeletePackageResponseObjectItemItem defines model for delete-package_response_object_item_item.
type DeletePackageResponseObjectItemItem struct {
	Id   string                                   `json:"id"`
	Type DeletePackageResponseObjectItemItem_Type `json:"type"`
}

// DeletePackageResponseObjectItemItem_Type defines model for DeletePackageResponseObjectItemItem.Type.
type DeletePackageResponseObjectItemItem_Type struct {
	union json.RawMessage
}

// ElasticsearchAssetType defines model for elasticsearch_asset_type.
type ElasticsearchAssetType = string

// EnrollmentApiKey defines model for enrollment_api_key.
type EnrollmentApiKey struct {
	// Active When false, the enrollment API key is revoked and cannot be used for enrolling Elastic Agents.
	Active bool `json:"active"`

	// ApiKey The enrollment API key (token) used for enrolling Elastic Agents.
	ApiKey string `json:"api_key"`

	// ApiKeyId The ID of the API key in the Security API.
	ApiKeyId  string `json:"api_key_id"`
	CreatedAt string `json:"created_at"`
	Id        string `json:"id"`

	// Name The name of the enrollment API key.
	Name *string `json:"name,omitempty"`

	// PolicyId The ID of the agent policy the Elastic Agent will be enrolled in.
	PolicyId *string `json:"policy_id,omitempty"`
}

// ErrorBudget defines model for error_budget.
type ErrorBudget struct {
	// Consumed The error budget consummed, as a percentage of the initial value.
	Consumed float32 `json:"consumed"`

	// Initial The initial error budget, as 1 - objective
	Initial float32 `json:"initial"`

	// IsEstimated Only for SLO defined with occurrences budgeting method and calendar aligned time window.
	IsEstimated bool `json:"isEstimated"`

	// Remaining The error budget remaining, as a percentage of the initial value.
	Remaining float32 `json:"remaining"`
}

// Fieldattrs A map of field attributes by field name.
type Fieldattrs struct {
	// Count Popularity count for the field.
	Count *int `json:"count,omitempty"`

	// CustomDescription Custom description for the field.
	CustomDescription *string `json:"customDescription,omitempty"`

	// CustomLabel Custom label for the field.
	CustomLabel *string `json:"customLabel,omitempty"`
}

// Fieldformats A map of field formats by field name.
type Fieldformats = map[string]interface{}

// Filter Defines properties for a filter
type Filter struct {
	// Meta Defines properties for a filter
	Meta  *FilterMeta            `json:"meta,omitempty"`
	Query map[string]interface{} `json:"query,omitempty"`
}

// FilterMeta Defines properties for a filter
type FilterMeta struct {
	Alias        *string                `json:"alias"`
	ControlledBy *string                `json:"controlledBy,omitempty"`
	Disabled     *bool                  `json:"disabled,omitempty"`
	Field        *string                `json:"field,omitempty"`
	Group        *string                `json:"group,omitempty"`
	Index        *string                `json:"index,omitempty"`
	IsMultiIndex *bool                  `json:"isMultiIndex,omitempty"`
	Key          *string                `json:"key,omitempty"`
	Negate       *bool                  `json:"negate,omitempty"`
	Params       map[string]interface{} `json:"params,omitempty"`
	Type         *string                `json:"type,omitempty"`
	Value        *string                `json:"value,omitempty"`
}

// FindRuleResponseObject defines model for find_rule_response_object.
type FindRuleResponseObject struct {
	Actions       []FindRuleResponseObjectActionsItem `json:"actions"`
	ActiveSnoozes []string                            `json:"active_snoozes,omitempty"`

	// AlertDelay Indicates that an alert occurs only when the specified number of consecutive runs met the rule conditions.
	AlertDelay *FindRuleResponseObjectAlertDelay `json:"alert_delay,omitempty"`

	// ApiKeyCreatedByUser Indicates whether the API key that is associated with the rule was created by the user.
	ApiKeyCreatedByUser *bool `json:"api_key_created_by_user"`

	// ApiKeyOwner The owner of the API key that is associated with the rule and used to run background tasks.
	ApiKeyOwner *string `json:"api_key_owner"`

	// Consumer The name of the application or feature that owns the rule. For example: `alerts`, `apm`, `discover`, `infrastructure`, `logs`, `metrics`, `ml`, `monitoring`, `securitySolution`, `siem`, `stackAlerts`, or `uptime`.
	Consumer string `json:"consumer"`

	// CreatedAt The date and time that the rule was created.
	CreatedAt string `json:"created_at"`

	// CreatedBy The identifier for the user that created the rule.
	CreatedBy *string `json:"created_by"`

	// Enabled Indicates whether you want to run the rule on an interval basis after it is created.
	Enabled         bool                                  `json:"enabled"`
	ExecutionStatus FindRuleResponseObjectExecutionStatus `json:"execution_status"`

	// Id The identifier for the rule.
	Id string `json:"id"`

	// IsSnoozedUntil The date when the rule will no longer be snoozed.
	IsSnoozedUntil *string                        `json:"is_snoozed_until"`
	LastRun        *FindRuleResponseObjectLastRun `json:"last_run"`
	MappedParams   map[string]interface{}         `json:"mapped_params,omitempty"`

	// Monitoring Monitoring details of the rule.
	Monitoring *FindRuleResponseObjectMonitoring `json:"monitoring,omitempty"`

	// MuteAll Indicates whether all alerts are muted.
	MuteAll       bool     `json:"mute_all"`
	MutedAlertIds []string `json:"muted_alert_ids"`

	// Name  The name of the rule.
	Name string `json:"name"`

	// NextRun Date and time of the next run of the rule.
	NextRun *string `json:"next_run"`

	// NotifyWhen Indicates how often alerts generate actions. Valid values include: `onActionGroupChange`: Actions run when the alert status changes; `onActiveAlert`: Actions run when the alert becomes active and at each check interval while the rule conditions are met; `onThrottleInterval`: Actions run when the alert becomes active and at the interval specified in the throttle property while the rule conditions are met. NOTE: You cannot specify `notify_when` at both the rule and action level. The recommended method is to set it for each action. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	NotifyWhen *string `json:"notify_when"`

	// Params The parameters for the rule.
	Params map[string]interface{} `json:"params"`

	// Revision The rule revision number.
	Revision float32 `json:"revision"`

	// RuleTypeId The rule type identifier.
	RuleTypeId string `json:"rule_type_id"`

	// Running Indicates whether the rule is running.
	Running  *bool                          `json:"running"`
	Schedule FindRuleResponseObjectSchedule `json:"schedule"`

	// ScheduledTaskId Identifier of the scheduled task.
	ScheduledTaskId *string                                    `json:"scheduled_task_id,omitempty"`
	SnoozeSchedule  []FindRuleResponseObjectSnoozeScheduleItem `json:"snooze_schedule,omitempty"`
	Tags            []string                                   `json:"tags"`

	// Throttle Deprecated in 8.13.0. Use the `throttle` property in the action `frequency` object instead. The throttle interval, which defines how often an alert generates repeated actions. NOTE: You cannot specify the throttle interval at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	Throttle *string `json:"throttle"`

	// UpdatedAt The date and time that the rule was updated most recently.
	UpdatedAt string `json:"updated_at"`

	// UpdatedBy The identifier for the user that updated this rule most recently.
	UpdatedBy *string `json:"updated_by"`

	// ViewInAppRelativeUrl Relative URL to view rule in the app.
	ViewInAppRelativeUrl *string `json:"view_in_app_relative_url"`
}

// FindRuleResponseObjectActionsItem defines model for find_rule_response_object_actions_item.
type FindRuleResponseObjectActionsItem struct {
	// AlertsFilter Defines a period that limits whether the action runs.
	AlertsFilter *FindRuleResponseObjectActionsItemAlertsFilter `json:"alerts_filter,omitempty"`

	// ConnectorTypeId The type of connector. This property appears in responses but cannot be set in requests.
	ConnectorTypeId string                                      `json:"connector_type_id"`
	Frequency       *FindRuleResponseObjectActionsItemFrequency `json:"frequency,omitempty"`

	// Group The group name, which affects when the action runs (for example, when the threshold is met or when the alert is recovered). Each rule type has a list of valid action group names. If you don't need to group actions, set to `default`.
	Group *string `json:"group,omitempty"`

	// Id The identifier for the connector saved object.
	Id string `json:"id"`

	// Params The parameters for the action, which are sent to the connector. The `params` are handled as Mustache templates and passed a default set of context.
	Params map[string]interface{} `json:"params"`

	// UseAlertDataForTemplate Indicates whether to use alert data as a template.
	UseAlertDataForTemplate *bool `json:"use_alert_data_for_template,omitempty"`

	// Uuid A universally unique identifier (UUID) for the action.
	Uuid *string `json:"uuid,omitempty"`
}

// FindRuleResponseObjectActionsItemAlertsFilter Defines a period that limits whether the action runs.
type FindRuleResponseObjectActionsItemAlertsFilter struct {
	Query     *FindRuleResponseObjectActionsItemAlertsFilterQuery     `json:"query,omitempty"`
	Timeframe *FindRuleResponseObjectActionsItemAlertsFilterTimeframe `json:"timeframe,omitempty"`
}

// FindRuleResponseObjectActionsItemAlertsFilterQuery defines model for find_rule_response_object_actions_item_alerts_filter_query.
type FindRuleResponseObjectActionsItemAlertsFilterQuery struct {
	// Dsl A filter written in Elasticsearch Query Domain Specific Language (DSL).
	Dsl *string `json:"dsl,omitempty"`

	// Filters A filter written in Elasticsearch Query Domain Specific Language (DSL) as defined in the `kbn-es-query` package.
	Filters []FindRuleResponseObjectActionsItemAlertsFilterQueryFiltersItem `json:"filters"`

	// Kql A filter written in Kibana Query Language (KQL).
	Kql string `json:"kql"`
}

// FindRuleResponseObjectActionsItemAlertsFilterQueryFiltersItem defines model for find_rule_response_object_actions_item_alerts_filter_query_filters_item.
type FindRuleResponseObjectActionsItemAlertsFilterQueryFiltersItem struct {
	State *FindRuleResponseObjectActionsItemAlertsFilterQueryFiltersItemState `json:"$state,omitempty"`
	Meta  map[string]interface{}                                              `json:"meta"`
	Query map[string]interface{}                                              `json:"query,omitempty"`
}

// FindRuleResponseObjectActionsItemAlertsFilterQueryFiltersItemState defines model for find_rule_response_object_actions_item_alerts_filter_query_filters_item_$state.
type FindRuleResponseObjectActionsItemAlertsFilterQueryFiltersItemState struct {
	// Store A filter can be either specific to an application context or applied globally.
	Store string `json:"store"`
}

// FindRuleResponseObjectActionsItemAlertsFilterTimeframe defines model for find_rule_response_object_actions_item_alerts_filter_timeframe.
type FindRuleResponseObjectActionsItemAlertsFilterTimeframe struct {
	// Days Defines the days of the week that the action can run, represented as an array of numbers. For example, `1` represents Monday. An empty array is equivalent to specifying all the days of the week.
	Days  []int                                                       `json:"days"`
	Hours FindRuleResponseObjectActionsItemAlertsFilterTimeframeHours `json:"hours"`

	// Timezone The ISO time zone for the `hours` values. Values such as `UTC` and `UTC+1` also work but lack built-in daylight savings time support and are not recommended.
	Timezone string `json:"timezone"`
}

// FindRuleResponseObjectActionsItemAlertsFilterTimeframeHours defines model for find_rule_response_object_actions_item_alerts_filter_timeframe_hours.
type FindRuleResponseObjectActionsItemAlertsFilterTimeframeHours struct {
	// End The end of the time frame in 24-hour notation (`hh:mm`).
	End string `json:"end"`

	// Start The start of the time frame in 24-hour notation (`hh:mm`).
	Start string `json:"start"`
}

// FindRuleResponseObjectActionsItemFrequency defines model for find_rule_response_object_actions_item_frequency.
type FindRuleResponseObjectActionsItemFrequency struct {
	// NotifyWhen Indicates how often alerts generate actions. Valid values include: `onActionGroupChange`: Actions run when the alert status changes; `onActiveAlert`: Actions run when the alert becomes active and at each check interval while the rule conditions are met; `onThrottleInterval`: Actions run when the alert becomes active and at the interval specified in the throttle property while the rule conditions are met. NOTE: You cannot specify `notify_when` at both the rule and action level. The recommended method is to set it for each action. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	NotifyWhen string `json:"notify_when"`

	// Summary Indicates whether the action is a summary.
	Summary bool `json:"summary"`

	// Throttle The throttle interval, which defines how often an alert generates repeated actions. It is specified in seconds, minutes, hours, or days and is applicable only if 'notify_when' is set to 'onThrottleInterval'. NOTE: You cannot specify the throttle interval at both the rule and action level. The recommended method is to set it for each action. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	Throttle *string `json:"throttle"`
}

// FindRuleResponseObjectAlertDelay Indicates that an alert occurs only when the specified number of consecutive runs met the rule conditions.
type FindRuleResponseObjectAlertDelay struct {
	// Active The number of consecutive runs that must meet the rule conditions.
	Active float32 `json:"active"`
}

// FindRuleResponseObjectExecutionStatus defines model for find_rule_response_object_execution_status.
type FindRuleResponseObjectExecutionStatus struct {
	Error *FindRuleResponseObjectExecutionStatusError `json:"error,omitempty"`

	// LastDuration Duration of last execution of the rule.
	LastDuration *float32 `json:"last_duration,omitempty"`

	// LastExecutionDate The date and time when rule was executed last.
	LastExecutionDate string `json:"last_execution_date"`

	// Status Status of rule execution.
	Status  string                                        `json:"status"`
	Warning *FindRuleResponseObjectExecutionStatusWarning `json:"warning,omitempty"`
}

// FindRuleResponseObjectExecutionStatusError defines model for find_rule_response_object_execution_status_error.
type FindRuleResponseObjectExecutionStatusError struct {
	// Message Error message.
	Message string `json:"message"`

	// Reason Reason for error.
	Reason string `json:"reason"`
}

// FindRuleResponseObjectExecutionStatusWarning defines model for find_rule_response_object_execution_status_warning.
type FindRuleResponseObjectExecutionStatusWarning struct {
	// Message Warning message.
	Message string `json:"message"`

	// Reason Reason for warning.
	Reason string `json:"reason"`
}

// FindRuleResponseObjectLastRun defines model for find_rule_response_object_last_run.
type FindRuleResponseObjectLastRun struct {
	AlertsCount FindRuleResponseObjectLastRunAlertsCount `json:"alerts_count"`

	// Outcome Outcome of last run of the rule. Value could be succeeded, warning or failed.
	Outcome    string   `json:"outcome"`
	OutcomeMsg []string `json:"outcome_msg"`

	// OutcomeOrder Order of the outcome.
	OutcomeOrder *float32 `json:"outcome_order,omitempty"`

	// Warning Warning of last rule execution.
	Warning *string `json:"warning"`
}

// FindRuleResponseObjectLastRunAlertsCount defines model for find_rule_response_object_last_run_alerts_count.
type FindRuleResponseObjectLastRunAlertsCount struct {
	// Active Number of active alerts during last run.
	Active *float32 `json:"active"`

	// Ignored Number of ignored alerts during last run.
	Ignored *float32 `json:"ignored"`

	// New Number of new alerts during last run.
	New *float32 `json:"new"`

	// Recovered Number of recovered alerts during last run.
	Recovered *float32 `json:"recovered"`
}

// FindRuleResponseObjectMonitoring Monitoring details of the rule.
type FindRuleResponseObjectMonitoring struct {
	// Run Rule run details.
	Run FindRuleResponseObjectMonitoringRun `json:"run"`
}

// FindRuleResponseObjectMonitoringRun Rule run details.
type FindRuleResponseObjectMonitoringRun struct {
	// CalculatedMetrics Calculation of different percentiles and success ratio.
	CalculatedMetrics FindRuleResponseObjectMonitoringRunCalculatedMetrics `json:"calculated_metrics"`

	// History History of the rule run.
	History []FindRuleResponseObjectMonitoringRunHistoryItem `json:"history"`
	LastRun FindRuleResponseObjectMonitoringRunLastRun       `json:"last_run"`
}

// FindRuleResponseObjectMonitoringRunCalculatedMetrics Calculation of different percentiles and success ratio.
type FindRuleResponseObjectMonitoringRunCalculatedMetrics struct {
	P50          *float32 `json:"p50,omitempty"`
	P95          *float32 `json:"p95,omitempty"`
	P99          *float32 `json:"p99,omitempty"`
	SuccessRatio float32  `json:"success_ratio"`
}

// FindRuleResponseObjectMonitoringRunHistoryItem defines model for find_rule_response_object_monitoring_run_history_item.
type FindRuleResponseObjectMonitoringRunHistoryItem struct {
	// Duration Duration of the rule run.
	Duration *float32                                               `json:"duration,omitempty"`
	Outcome  *FindRuleResponseObjectMonitoringRunHistoryItemOutcome `json:"outcome,omitempty"`

	// Success Indicates whether the rule run was successful.
	Success bool `json:"success"`

	// Timestamp Time of rule run.
	Timestamp float32 `json:"timestamp"`
}

// FindRuleResponseObjectMonitoringRunHistoryItemOutcome defines model for find_rule_response_object_monitoring_run_history_item_outcome.
type FindRuleResponseObjectMonitoringRunHistoryItemOutcome struct {
	AlertsCount FindRuleResponseObjectMonitoringRunHistoryItemOutcomeAlertsCount `json:"alerts_count"`

	// Outcome Outcome of last run of the rule. Value could be succeeded, warning or failed.
	Outcome    string   `json:"outcome"`
	OutcomeMsg []string `json:"outcome_msg"`

	// OutcomeOrder Order of the outcome.
	OutcomeOrder *float32 `json:"outcome_order,omitempty"`

	// Warning Warning of last rule execution.
	Warning *string `json:"warning"`
}

// FindRuleResponseObjectMonitoringRunHistoryItemOutcomeAlertsCount defines model for find_rule_response_object_monitoring_run_history_item_outcome_alerts_count.
type FindRuleResponseObjectMonitoringRunHistoryItemOutcomeAlertsCount struct {
	// Active Number of active alerts during last run.
	Active *float32 `json:"active"`

	// Ignored Number of ignored alerts during last run.
	Ignored *float32 `json:"ignored"`

	// New Number of new alerts during last run.
	New *float32 `json:"new"`

	// Recovered Number of recovered alerts during last run.
	Recovered *float32 `json:"recovered"`
}

// FindRuleResponseObjectMonitoringRunLastRun defines model for find_rule_response_object_monitoring_run_last_run.
type FindRuleResponseObjectMonitoringRunLastRun struct {
	Metrics FindRuleResponseObjectMonitoringRunLastRunMetrics `json:"metrics"`

	// Timestamp Time of the most recent rule run.
	Timestamp string `json:"timestamp"`
}

// FindRuleResponseObjectMonitoringRunLastRunMetrics defines model for find_rule_response_object_monitoring_run_last_run_metrics.
type FindRuleResponseObjectMonitoringRunLastRunMetrics struct {
	// Duration Duration of most recent rule run.
	Duration *float32 `json:"duration,omitempty"`

	// GapDurationS Duration in seconds of rule run gap.
	GapDurationS *float32 `json:"gap_duration_s"`

	// TotalAlertsCreated Total number of alerts created during last rule run.
	TotalAlertsCreated *float32 `json:"total_alerts_created"`

	// TotalAlertsDetected Total number of alerts detected during last rule run.
	TotalAlertsDetected *float32 `json:"total_alerts_detected"`

	// TotalIndexingDurationMs Total time spent indexing documents during last rule run in milliseconds.
	TotalIndexingDurationMs *float32 `json:"total_indexing_duration_ms"`

	// TotalSearchDurationMs Total time spent performing Elasticsearch searches as measured by Kibana; includes network latency and time spent serializing or deserializing the request and response.
	TotalSearchDurationMs *float32 `json:"total_search_duration_ms"`
}

// FindRuleResponseObjectSchedule defines model for find_rule_response_object_schedule.
type FindRuleResponseObjectSchedule struct {
	// Interval The interval is specified in seconds, minutes, hours, or days.
	Interval string `json:"interval"`
}

// FindRuleResponseObjectSnoozeScheduleItem defines model for find_rule_response_object_snooze_schedule_item.
type FindRuleResponseObjectSnoozeScheduleItem struct {
	// Duration Duration of the rule snooze schedule.
	Duration float32 `json:"duration"`

	// Id Identifier of the rule snooze schedule.
	Id              *string                                       `json:"id,omitempty"`
	RRule           FindRuleResponseObjectSnoozeScheduleItemRRule `json:"rRule"`
	SkipRecurrences []string                                      `json:"skipRecurrences,omitempty"`
}

// FindRuleResponseObjectSnoozeScheduleItemRRule defines model for find_rule_response_object_snooze_schedule_item_rRule.
type FindRuleResponseObjectSnoozeScheduleItemRRule struct {
	Byhour     []float32                                                      `json:"byhour,omitempty"`
	Byminute   []float32                                                      `json:"byminute,omitempty"`
	Bymonth    []float32                                                      `json:"bymonth,omitempty"`
	Bymonthday []float32                                                      `json:"bymonthday,omitempty"`
	Bysecond   []float32                                                      `json:"bysecond,omitempty"`
	Bysetpos   []float32                                                      `json:"bysetpos,omitempty"`
	Byweekday  []FindRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item `json:"byweekday,omitempty"`
	Byweekno   []float32                                                      `json:"byweekno,omitempty"`
	Byyearday  []float32                                                      `json:"byyearday,omitempty"`

	// Count Number of times the rule should recur until it stops.
	Count *float32 `json:"count,omitempty"`

	// Dtstart Rule start date in Coordinated Universal Time (UTC).
	Dtstart string `json:"dtstart"`

	// Freq Indicates frequency of the rule. Options are YEARLY, MONTHLY, WEEKLY, DAILY.
	Freq *int `json:"freq,omitempty"`

	// Interval Indicates the interval of frequency. For example, 1 and YEARLY is every 1 year, 2 and WEEKLY is every 2 weeks.
	Interval *float32 `json:"interval,omitempty"`

	// Tzid Indicates timezone abbreviation.
	Tzid string `json:"tzid"`

	// Until Recur the rule until this date.
	Until *string `json:"until,omitempty"`

	// Wkst Indicates the start of week, defaults to Monday.
	Wkst *string `json:"wkst,omitempty"`
}

// FindRuleResponseObjectSnoozeScheduleItemRRuleByweekday0 defines model for .
type FindRuleResponseObjectSnoozeScheduleItemRRuleByweekday0 = string

// FindRuleResponseObjectSnoozeScheduleItemRRuleByweekday1 defines model for .
type FindRuleResponseObjectSnoozeScheduleItemRRuleByweekday1 = float32

// FindRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item Indicates the days of the week to recur or else nth-day-of-month strings. For example, "+2TU" second Tuesday of month, "-1FR" last Friday of the month, which are internally converted to a `byweekday/bysetpos` combination.
type FindRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item struct {
	union json.RawMessage
}

// FindSloResponse A paginated response of SLOs matching the query.
type FindSloResponse struct {
	Page    *float32                 `json:"page,omitempty"`
	PerPage *float32                 `json:"perPage,omitempty"`
	Results []SloWithSummaryResponse `json:"results,omitempty"`
	Total   *float32                 `json:"total,omitempty"`
}

// FleetServerHost defines model for fleet_server_host.
type FleetServerHost struct {
	HostUrls        []string `json:"host_urls"`
	Id              string   `json:"id"`
	IsDefault       bool     `json:"is_default"`
	IsInternal      *bool    `json:"is_internal,omitempty"`
	IsPreconfigured bool     `json:"is_preconfigured"`
	Name            *string  `json:"name,omitempty"`
	ProxyId         *string  `json:"proxy_id,omitempty"`
}

// GenerateServiceTokenResponseObject defines model for generate-service-token_response_object.
type GenerateServiceTokenResponseObject struct {
	Name  *string `json:"name,omitempty"`
	Value *string `json:"value,omitempty"`
}

// GetEnrollmentApiKeysResponseObject defines model for get-enrollment-api-keys_response_object.
type GetEnrollmentApiKeysResponseObject struct {
	Items []EnrollmentApiKey `json:"items"`
	// Deprecated:
	List    []EnrollmentApiKey `json:"list,omitempty"`
	Page    float32            `json:"page"`
	PerPage float32            `json:"perPage"`
	Total   float32            `json:"total"`
}

// GetFleetServerHostsResponseObject defines model for get-fleet-server-hosts_response_object.
type GetFleetServerHostsResponseObject struct {
	Items   []FleetServerHost `json:"items,omitempty"`
	Page    *int              `json:"page,omitempty"`
	PerPage *int              `json:"perPage,omitempty"`
	Total   *int              `json:"total,omitempty"`
}

// GetOneFleetServerHostsResponseObject defines model for get-one-fleet-server-hosts_response_object.
type GetOneFleetServerHostsResponseObject struct {
	Item FleetServerHost `json:"item"`
}

// GetOutputResponseObject defines model for get-output_response_object.
type GetOutputResponseObject struct {
	Item *OutputCreateRequest `json:"item,omitempty"`
}

// GetOutputsResponseObject defines model for get-outputs_response_object.
type GetOutputsResponseObject struct {
	Items   []OutputCreateRequest `json:"items,omitempty"`
	Page    *int                  `json:"page,omitempty"`
	PerPage *int                  `json:"perPage,omitempty"`
	Total   *int                  `json:"total,omitempty"`
}

// GetPackagePoliciesResponseObject defines model for get-package-policies_response_object.
type GetPackagePoliciesResponseObject struct {
	Items   []PackagePolicy `json:"items"`
	Page    *float32        `json:"page,omitempty"`
	PerPage *float32        `json:"perPage,omitempty"`
	Total   *float32        `json:"total,omitempty"`
}

// GetPackagePolicyResponseObject defines model for get-package-policy_response_object.
type GetPackagePolicyResponseObject struct {
	Item PackagePolicy `json:"item"`
}

// GetPackageResponseObject defines model for get-package_response_object.
type GetPackageResponseObject struct {
	Item                 *PackageInfo `json:"item,omitempty"`
	KeepPoliciesUpToDate *bool        `json:"keepPoliciesUpToDate,omitempty"`
	LatestVersion        *string      `json:"latestVersion,omitempty"`
	LicensePath          *string      `json:"licensePath,omitempty"`
	Notice               *string      `json:"notice,omitempty"`
	// Deprecated:
	SavedObject map[string]interface{} `json:"savedObject"`
	Status      string                 `json:"status"`
}

// GetPackageResponseObjectAllOf0 defines model for get-package_response_object_allOf_0.
type GetPackageResponseObjectAllOf0 struct {
	Item *PackageInfo `json:"item,omitempty"`
}

// GetPackageResponseObjectAllOf1 defines model for get-package_response_object_allOf_1.
type GetPackageResponseObjectAllOf1 struct {
	KeepPoliciesUpToDate *bool   `json:"keepPoliciesUpToDate,omitempty"`
	LatestVersion        *string `json:"latestVersion,omitempty"`
	LicensePath          *string `json:"licensePath,omitempty"`
	Notice               *string `json:"notice,omitempty"`
	// Deprecated:
	SavedObject map[string]interface{} `json:"savedObject"`
	Status      string                 `json:"status"`
}

// GetAllDataViewsResponseObject defines model for get_all_data_views_response_object.
type GetAllDataViewsResponseObject struct {
	DataView []GetAllDataViewsResponseObjectDataViewItem `json:"data_view,omitempty"`
}

// GetAllDataViewsResponseObjectDataViewItem defines model for get_all_data_views_response_object_data_view_item.
type GetAllDataViewsResponseObjectDataViewItem struct {
	Id         *string                `json:"id,omitempty"`
	Name       *string                `json:"name,omitempty"`
	Namespaces []string               `json:"namespaces,omitempty"`
	Title      *string                `json:"title,omitempty"`
	TypeMeta   map[string]interface{} `json:"typeMeta,omitempty"`
}

// GetConnectorResponseObject defines model for get_connector_response_object.
type GetConnectorResponseObject struct {
	Config map[string]interface{} `json:"config,omitempty"`

	// ConnectorTypeId The connector type identifier.
	ConnectorTypeId string `json:"connector_type_id"`

	// Id The identifier for the connector.
	Id string `json:"id"`

	// IsDeprecated Indicates whether the connector is deprecated.
	IsDeprecated bool `json:"is_deprecated"`

	// IsMissingSecrets Indicates whether the connector is missing secrets.
	IsMissingSecrets *bool `json:"is_missing_secrets,omitempty"`

	// IsPreconfigured Indicates whether the connector is preconfigured. If true, the `config` and `is_missing_secrets` properties are omitted from the response.
	IsPreconfigured bool `json:"is_preconfigured"`

	// IsSystemAction Indicates whether the connector is used for system actions.
	IsSystemAction bool `json:"is_system_action"`

	// Name  The name of the rule.
	Name string `json:"name"`
}

// GetPackagesResponse defines model for get_packages_response.
type GetPackagesResponse struct {
	Items []SearchResult `json:"items"`
	// Deprecated:
	Response []SearchResult `json:"response,omitempty"`
}

// GetRuleResponseObject defines model for get_rule_response_object.
type GetRuleResponseObject struct {
	Actions       []GetRuleResponseObjectActionsItem `json:"actions"`
	ActiveSnoozes []string                           `json:"active_snoozes,omitempty"`

	// AlertDelay Indicates that an alert occurs only when the specified number of consecutive runs met the rule conditions.
	AlertDelay *GetRuleResponseObjectAlertDelay `json:"alert_delay,omitempty"`

	// ApiKeyCreatedByUser Indicates whether the API key that is associated with the rule was created by the user.
	ApiKeyCreatedByUser *bool `json:"api_key_created_by_user"`

	// ApiKeyOwner The owner of the API key that is associated with the rule and used to run background tasks.
	ApiKeyOwner *string `json:"api_key_owner"`

	// Consumer The name of the application or feature that owns the rule. For example: `alerts`, `apm`, `discover`, `infrastructure`, `logs`, `metrics`, `ml`, `monitoring`, `securitySolution`, `siem`, `stackAlerts`, or `uptime`.
	Consumer string `json:"consumer"`

	// CreatedAt The date and time that the rule was created.
	CreatedAt string `json:"created_at"`

	// CreatedBy The identifier for the user that created the rule.
	CreatedBy *string `json:"created_by"`

	// Enabled Indicates whether you want to run the rule on an interval basis after it is created.
	Enabled         bool                                 `json:"enabled"`
	ExecutionStatus GetRuleResponseObjectExecutionStatus `json:"execution_status"`

	// Id The identifier for the rule.
	Id string `json:"id"`

	// IsSnoozedUntil The date when the rule will no longer be snoozed.
	IsSnoozedUntil *string                       `json:"is_snoozed_until"`
	LastRun        *GetRuleResponseObjectLastRun `json:"last_run"`
	MappedParams   map[string]interface{}        `json:"mapped_params,omitempty"`

	// Monitoring Monitoring details of the rule.
	Monitoring *GetRuleResponseObjectMonitoring `json:"monitoring,omitempty"`

	// MuteAll Indicates whether all alerts are muted.
	MuteAll       bool     `json:"mute_all"`
	MutedAlertIds []string `json:"muted_alert_ids"`

	// Name  The name of the rule.
	Name string `json:"name"`

	// NextRun Date and time of the next run of the rule.
	NextRun *string `json:"next_run"`

	// NotifyWhen Indicates how often alerts generate actions. Valid values include: `onActionGroupChange`: Actions run when the alert status changes; `onActiveAlert`: Actions run when the alert becomes active and at each check interval while the rule conditions are met; `onThrottleInterval`: Actions run when the alert becomes active and at the interval specified in the throttle property while the rule conditions are met. NOTE: You cannot specify `notify_when` at both the rule and action level. The recommended method is to set it for each action. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	NotifyWhen *string `json:"notify_when"`

	// Params The parameters for the rule.
	Params map[string]interface{} `json:"params"`

	// Revision The rule revision number.
	Revision float32 `json:"revision"`

	// RuleTypeId The rule type identifier.
	RuleTypeId string `json:"rule_type_id"`

	// Running Indicates whether the rule is running.
	Running  *bool                         `json:"running"`
	Schedule GetRuleResponseObjectSchedule `json:"schedule"`

	// ScheduledTaskId Identifier of the scheduled task.
	ScheduledTaskId *string                                   `json:"scheduled_task_id,omitempty"`
	SnoozeSchedule  []GetRuleResponseObjectSnoozeScheduleItem `json:"snooze_schedule,omitempty"`
	Tags            []string                                  `json:"tags"`

	// Throttle Deprecated in 8.13.0. Use the `throttle` property in the action `frequency` object instead. The throttle interval, which defines how often an alert generates repeated actions. NOTE: You cannot specify the throttle interval at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	Throttle *string `json:"throttle"`

	// UpdatedAt The date and time that the rule was updated most recently.
	UpdatedAt string `json:"updated_at"`

	// UpdatedBy The identifier for the user that updated this rule most recently.
	UpdatedBy *string `json:"updated_by"`

	// ViewInAppRelativeUrl Relative URL to view rule in the app.
	ViewInAppRelativeUrl *string `json:"view_in_app_relative_url"`
}

// GetRuleResponseObjectActionsItem defines model for get_rule_response_object_actions_item.
type GetRuleResponseObjectActionsItem struct {
	// AlertsFilter Defines a period that limits whether the action runs.
	AlertsFilter *GetRuleResponseObjectActionsItemAlertsFilter `json:"alerts_filter,omitempty"`

	// ConnectorTypeId The type of connector. This property appears in responses but cannot be set in requests.
	ConnectorTypeId string                                     `json:"connector_type_id"`
	Frequency       *GetRuleResponseObjectActionsItemFrequency `json:"frequency,omitempty"`

	// Group The group name, which affects when the action runs (for example, when the threshold is met or when the alert is recovered). Each rule type has a list of valid action group names. If you don't need to group actions, set to `default`.
	Group *string `json:"group,omitempty"`

	// Id The identifier for the connector saved object.
	Id string `json:"id"`

	// Params The parameters for the action, which are sent to the connector. The `params` are handled as Mustache templates and passed a default set of context.
	Params map[string]interface{} `json:"params"`

	// UseAlertDataForTemplate Indicates whether to use alert data as a template.
	UseAlertDataForTemplate *bool `json:"use_alert_data_for_template,omitempty"`

	// Uuid A universally unique identifier (UUID) for the action.
	Uuid *string `json:"uuid,omitempty"`
}

// GetRuleResponseObjectActionsItemAlertsFilter Defines a period that limits whether the action runs.
type GetRuleResponseObjectActionsItemAlertsFilter struct {
	Query     *GetRuleResponseObjectActionsItemAlertsFilterQuery     `json:"query,omitempty"`
	Timeframe *GetRuleResponseObjectActionsItemAlertsFilterTimeframe `json:"timeframe,omitempty"`
}

// GetRuleResponseObjectActionsItemAlertsFilterQuery defines model for get_rule_response_object_actions_item_alerts_filter_query.
type GetRuleResponseObjectActionsItemAlertsFilterQuery struct {
	// Dsl A filter written in Elasticsearch Query Domain Specific Language (DSL).
	Dsl *string `json:"dsl,omitempty"`

	// Filters A filter written in Elasticsearch Query Domain Specific Language (DSL) as defined in the `kbn-es-query` package.
	Filters []GetRuleResponseObjectActionsItemAlertsFilterQueryFiltersItem `json:"filters"`

	// Kql A filter written in Kibana Query Language (KQL).
	Kql string `json:"kql"`
}

// GetRuleResponseObjectActionsItemAlertsFilterQueryFiltersItem defines model for get_rule_response_object_actions_item_alerts_filter_query_filters_item.
type GetRuleResponseObjectActionsItemAlertsFilterQueryFiltersItem struct {
	State *GetRuleResponseObjectActionsItemAlertsFilterQueryFiltersItemState `json:"$state,omitempty"`
	Meta  map[string]interface{}                                             `json:"meta"`
	Query map[string]interface{}                                             `json:"query,omitempty"`
}

// GetRuleResponseObjectActionsItemAlertsFilterQueryFiltersItemState defines model for get_rule_response_object_actions_item_alerts_filter_query_filters_item_$state.
type GetRuleResponseObjectActionsItemAlertsFilterQueryFiltersItemState struct {
	// Store A filter can be either specific to an application context or applied globally.
	Store string `json:"store"`
}

// GetRuleResponseObjectActionsItemAlertsFilterTimeframe defines model for get_rule_response_object_actions_item_alerts_filter_timeframe.
type GetRuleResponseObjectActionsItemAlertsFilterTimeframe struct {
	// Days Defines the days of the week that the action can run, represented as an array of numbers. For example, `1` represents Monday. An empty array is equivalent to specifying all the days of the week.
	Days  []int                                                      `json:"days"`
	Hours GetRuleResponseObjectActionsItemAlertsFilterTimeframeHours `json:"hours"`

	// Timezone The ISO time zone for the `hours` values. Values such as `UTC` and `UTC+1` also work but lack built-in daylight savings time support and are not recommended.
	Timezone string `json:"timezone"`
}

// GetRuleResponseObjectActionsItemAlertsFilterTimeframeHours defines model for get_rule_response_object_actions_item_alerts_filter_timeframe_hours.
type GetRuleResponseObjectActionsItemAlertsFilterTimeframeHours struct {
	// End The end of the time frame in 24-hour notation (`hh:mm`).
	End string `json:"end"`

	// Start The start of the time frame in 24-hour notation (`hh:mm`).
	Start string `json:"start"`
}

// GetRuleResponseObjectActionsItemFrequency defines model for get_rule_response_object_actions_item_frequency.
type GetRuleResponseObjectActionsItemFrequency struct {
	// NotifyWhen Indicates how often alerts generate actions. Valid values include: `onActionGroupChange`: Actions run when the alert status changes; `onActiveAlert`: Actions run when the alert becomes active and at each check interval while the rule conditions are met; `onThrottleInterval`: Actions run when the alert becomes active and at the interval specified in the throttle property while the rule conditions are met. NOTE: You cannot specify `notify_when` at both the rule and action level. The recommended method is to set it for each action. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	NotifyWhen string `json:"notify_when"`

	// Summary Indicates whether the action is a summary.
	Summary bool `json:"summary"`

	// Throttle The throttle interval, which defines how often an alert generates repeated actions. It is specified in seconds, minutes, hours, or days and is applicable only if 'notify_when' is set to 'onThrottleInterval'. NOTE: You cannot specify the throttle interval at both the rule and action level. The recommended method is to set it for each action. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	Throttle *string `json:"throttle"`
}

// GetRuleResponseObjectAlertDelay Indicates that an alert occurs only when the specified number of consecutive runs met the rule conditions.
type GetRuleResponseObjectAlertDelay struct {
	// Active The number of consecutive runs that must meet the rule conditions.
	Active float32 `json:"active"`
}

// GetRuleResponseObjectExecutionStatus defines model for get_rule_response_object_execution_status.
type GetRuleResponseObjectExecutionStatus struct {
	Error *GetRuleResponseObjectExecutionStatusError `json:"error,omitempty"`

	// LastDuration Duration of last execution of the rule.
	LastDuration *float32 `json:"last_duration,omitempty"`

	// LastExecutionDate The date and time when rule was executed last.
	LastExecutionDate string `json:"last_execution_date"`

	// Status Status of rule execution.
	Status  string                                       `json:"status"`
	Warning *GetRuleResponseObjectExecutionStatusWarning `json:"warning,omitempty"`
}

// GetRuleResponseObjectExecutionStatusError defines model for get_rule_response_object_execution_status_error.
type GetRuleResponseObjectExecutionStatusError struct {
	// Message Error message.
	Message string `json:"message"`

	// Reason Reason for error.
	Reason string `json:"reason"`
}

// GetRuleResponseObjectExecutionStatusWarning defines model for get_rule_response_object_execution_status_warning.
type GetRuleResponseObjectExecutionStatusWarning struct {
	// Message Warning message.
	Message string `json:"message"`

	// Reason Reason for warning.
	Reason string `json:"reason"`
}

// GetRuleResponseObjectLastRun defines model for get_rule_response_object_last_run.
type GetRuleResponseObjectLastRun struct {
	AlertsCount GetRuleResponseObjectLastRunAlertsCount `json:"alerts_count"`

	// Outcome Outcome of last run of the rule. Value could be succeeded, warning or failed.
	Outcome    string   `json:"outcome"`
	OutcomeMsg []string `json:"outcome_msg"`

	// OutcomeOrder Order of the outcome.
	OutcomeOrder *float32 `json:"outcome_order,omitempty"`

	// Warning Warning of last rule execution.
	Warning *string `json:"warning"`
}

// GetRuleResponseObjectLastRunAlertsCount defines model for get_rule_response_object_last_run_alerts_count.
type GetRuleResponseObjectLastRunAlertsCount struct {
	// Active Number of active alerts during last run.
	Active *float32 `json:"active"`

	// Ignored Number of ignored alerts during last run.
	Ignored *float32 `json:"ignored"`

	// New Number of new alerts during last run.
	New *float32 `json:"new"`

	// Recovered Number of recovered alerts during last run.
	Recovered *float32 `json:"recovered"`
}

// GetRuleResponseObjectMonitoring Monitoring details of the rule.
type GetRuleResponseObjectMonitoring struct {
	// Run Rule run details.
	Run GetRuleResponseObjectMonitoringRun `json:"run"`
}

// GetRuleResponseObjectMonitoringRun Rule run details.
type GetRuleResponseObjectMonitoringRun struct {
	// CalculatedMetrics Calculation of different percentiles and success ratio.
	CalculatedMetrics GetRuleResponseObjectMonitoringRunCalculatedMetrics `json:"calculated_metrics"`

	// History History of the rule run.
	History []GetRuleResponseObjectMonitoringRunHistoryItem `json:"history"`
	LastRun GetRuleResponseObjectMonitoringRunLastRun       `json:"last_run"`
}

// GetRuleResponseObjectMonitoringRunCalculatedMetrics Calculation of different percentiles and success ratio.
type GetRuleResponseObjectMonitoringRunCalculatedMetrics struct {
	P50          *float32 `json:"p50,omitempty"`
	P95          *float32 `json:"p95,omitempty"`
	P99          *float32 `json:"p99,omitempty"`
	SuccessRatio float32  `json:"success_ratio"`
}

// GetRuleResponseObjectMonitoringRunHistoryItem defines model for get_rule_response_object_monitoring_run_history_item.
type GetRuleResponseObjectMonitoringRunHistoryItem struct {
	// Duration Duration of the rule run.
	Duration *float32                                              `json:"duration,omitempty"`
	Outcome  *GetRuleResponseObjectMonitoringRunHistoryItemOutcome `json:"outcome,omitempty"`

	// Success Indicates whether the rule run was successful.
	Success bool `json:"success"`

	// Timestamp Time of rule run.
	Timestamp float32 `json:"timestamp"`
}

// GetRuleResponseObjectMonitoringRunHistoryItemOutcome defines model for get_rule_response_object_monitoring_run_history_item_outcome.
type GetRuleResponseObjectMonitoringRunHistoryItemOutcome struct {
	AlertsCount GetRuleResponseObjectMonitoringRunHistoryItemOutcomeAlertsCount `json:"alerts_count"`

	// Outcome Outcome of last run of the rule. Value could be succeeded, warning or failed.
	Outcome    string   `json:"outcome"`
	OutcomeMsg []string `json:"outcome_msg"`

	// OutcomeOrder Order of the outcome.
	OutcomeOrder *float32 `json:"outcome_order,omitempty"`

	// Warning Warning of last rule execution.
	Warning *string `json:"warning"`
}

// GetRuleResponseObjectMonitoringRunHistoryItemOutcomeAlertsCount defines model for get_rule_response_object_monitoring_run_history_item_outcome_alerts_count.
type GetRuleResponseObjectMonitoringRunHistoryItemOutcomeAlertsCount struct {
	// Active Number of active alerts during last run.
	Active *float32 `json:"active"`

	// Ignored Number of ignored alerts during last run.
	Ignored *float32 `json:"ignored"`

	// New Number of new alerts during last run.
	New *float32 `json:"new"`

	// Recovered Number of recovered alerts during last run.
	Recovered *float32 `json:"recovered"`
}

// GetRuleResponseObjectMonitoringRunLastRun defines model for get_rule_response_object_monitoring_run_last_run.
type GetRuleResponseObjectMonitoringRunLastRun struct {
	Metrics GetRuleResponseObjectMonitoringRunLastRunMetrics `json:"metrics"`

	// Timestamp Time of the most recent rule run.
	Timestamp string `json:"timestamp"`
}

// GetRuleResponseObjectMonitoringRunLastRunMetrics defines model for get_rule_response_object_monitoring_run_last_run_metrics.
type GetRuleResponseObjectMonitoringRunLastRunMetrics struct {
	// Duration Duration of most recent rule run.
	Duration *float32 `json:"duration,omitempty"`

	// GapDurationS Duration in seconds of rule run gap.
	GapDurationS *float32 `json:"gap_duration_s"`

	// TotalAlertsCreated Total number of alerts created during last rule run.
	TotalAlertsCreated *float32 `json:"total_alerts_created"`

	// TotalAlertsDetected Total number of alerts detected during last rule run.
	TotalAlertsDetected *float32 `json:"total_alerts_detected"`

	// TotalIndexingDurationMs Total time spent indexing documents during last rule run in milliseconds.
	TotalIndexingDurationMs *float32 `json:"total_indexing_duration_ms"`

	// TotalSearchDurationMs Total time spent performing Elasticsearch searches as measured by Kibana; includes network latency and time spent serializing or deserializing the request and response.
	TotalSearchDurationMs *float32 `json:"total_search_duration_ms"`
}

// GetRuleResponseObjectSchedule defines model for get_rule_response_object_schedule.
type GetRuleResponseObjectSchedule struct {
	// Interval The interval is specified in seconds, minutes, hours, or days.
	Interval string `json:"interval"`
}

// GetRuleResponseObjectSnoozeScheduleItem defines model for get_rule_response_object_snooze_schedule_item.
type GetRuleResponseObjectSnoozeScheduleItem struct {
	// Duration Duration of the rule snooze schedule.
	Duration float32 `json:"duration"`

	// Id Identifier of the rule snooze schedule.
	Id              *string                                      `json:"id,omitempty"`
	RRule           GetRuleResponseObjectSnoozeScheduleItemRRule `json:"rRule"`
	SkipRecurrences []string                                     `json:"skipRecurrences,omitempty"`
}

// GetRuleResponseObjectSnoozeScheduleItemRRule defines model for get_rule_response_object_snooze_schedule_item_rRule.
type GetRuleResponseObjectSnoozeScheduleItemRRule struct {
	Byhour     []float32                                                     `json:"byhour,omitempty"`
	Byminute   []float32                                                     `json:"byminute,omitempty"`
	Bymonth    []float32                                                     `json:"bymonth,omitempty"`
	Bymonthday []float32                                                     `json:"bymonthday,omitempty"`
	Bysecond   []float32                                                     `json:"bysecond,omitempty"`
	Bysetpos   []float32                                                     `json:"bysetpos,omitempty"`
	Byweekday  []GetRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item `json:"byweekday,omitempty"`
	Byweekno   []float32                                                     `json:"byweekno,omitempty"`
	Byyearday  []float32                                                     `json:"byyearday,omitempty"`

	// Count Number of times the rule should recur until it stops.
	Count *float32 `json:"count,omitempty"`

	// Dtstart Rule start date in Coordinated Universal Time (UTC).
	Dtstart string `json:"dtstart"`

	// Freq Indicates frequency of the rule. Options are YEARLY, MONTHLY, WEEKLY, DAILY.
	Freq *int `json:"freq,omitempty"`

	// Interval Indicates the interval of frequency. For example, 1 and YEARLY is every 1 year, 2 and WEEKLY is every 2 weeks.
	Interval *float32 `json:"interval,omitempty"`

	// Tzid Indicates timezone abbreviation.
	Tzid string `json:"tzid"`

	// Until Recur the rule until this date.
	Until *string `json:"until,omitempty"`

	// Wkst Indicates the start of week, defaults to Monday.
	Wkst *string `json:"wkst,omitempty"`
}

// GetRuleResponseObjectSnoozeScheduleItemRRuleByweekday0 defines model for .
type GetRuleResponseObjectSnoozeScheduleItemRRuleByweekday0 = string

// GetRuleResponseObjectSnoozeScheduleItemRRuleByweekday1 defines model for .
type GetRuleResponseObjectSnoozeScheduleItemRRuleByweekday1 = float32

// GetRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item Indicates the days of the week to recur or else nth-day-of-month strings. For example, "+2TU" second Tuesday of month, "-1FR" last Friday of the month, which are internally converted to a `byweekday/bysetpos` combination.
type GetRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item struct {
	union json.RawMessage
}

// ImportSavedObjectsResponseObject defines model for import_saved_objects_response_object.
type ImportSavedObjectsResponseObject struct {
	// Errors Indicates the import was unsuccessful and specifies the objects that failed to import.
	//
	// NOTE: One object may result in multiple errors, which requires separate steps to resolve. For instance, a `missing_references` error and conflict error.
	Errors []map[string]interface{} `json:"errors,omitempty"`

	// Success Indicates when the import was successfully completed. When set to false, some objects may not have been created. For additional information, refer to the `errors` and `successResults` properties.
	Success *bool `json:"success,omitempty"`

	// SuccessCount Indicates the number of successfully imported records.
	SuccessCount *int `json:"successCount,omitempty"`

	// SuccessResults Indicates the objects that are successfully imported, with any metadata if applicable.
	//
	// NOTE: Objects are created only when all resolvable errors are addressed, including conflicts and missing references. If objects are created as new copies, each entry in the `successResults` array includes a `destinationId` attribute.
	SuccessResults []map[string]interface{} `json:"successResults,omitempty"`
}

// IndicatorPropertiesApmAvailability Defines properties for the APM availability indicator type
type IndicatorPropertiesApmAvailability struct {
	// Params An object containing the indicator parameters.
	Params IndicatorPropertiesApmAvailabilityParams `json:"params"`

	// Type The type of indicator.
	Type string `json:"type"`
}

// IndicatorPropertiesApmAvailabilityParams An object containing the indicator parameters.
type IndicatorPropertiesApmAvailabilityParams struct {
	// Environment The APM service environment or "*"
	Environment string `json:"environment"`

	// Filter KQL query used for filtering the data
	Filter *string `json:"filter,omitempty"`

	// Index The index used by APM metrics
	Index string `json:"index"`

	// Service The APM service name
	Service string `json:"service"`

	// TransactionName The APM transaction name or "*"
	TransactionName string `json:"transactionName"`

	// TransactionType The APM transaction type or "*"
	TransactionType string `json:"transactionType"`
}

// IndicatorPropertiesApmLatency Defines properties for the APM latency indicator type
type IndicatorPropertiesApmLatency struct {
	// Params An object containing the indicator parameters.
	Params IndicatorPropertiesApmLatencyParams `json:"params"`

	// Type The type of indicator.
	Type string `json:"type"`
}

// IndicatorPropertiesApmLatencyParams An object containing the indicator parameters.
type IndicatorPropertiesApmLatencyParams struct {
	// Environment The APM service environment or "*"
	Environment string `json:"environment"`

	// Filter KQL query used for filtering the data
	Filter *string `json:"filter,omitempty"`

	// Index The index used by APM metrics
	Index string `json:"index"`

	// Service The APM service name
	Service string `json:"service"`

	// Threshold The latency threshold in milliseconds
	Threshold float32 `json:"threshold"`

	// TransactionName The APM transaction name or "*"
	TransactionName string `json:"transactionName"`

	// TransactionType The APM transaction type or "*"
	TransactionType string `json:"transactionType"`
}

// IndicatorPropertiesCustomKql Defines properties for a custom query indicator type
type IndicatorPropertiesCustomKql struct {
	// Params An object containing the indicator parameters.
	Params IndicatorPropertiesCustomKqlParams `json:"params"`

	// Type The type of indicator.
	Type string `json:"type"`
}

// IndicatorPropertiesCustomKqlParams An object containing the indicator parameters.
type IndicatorPropertiesCustomKqlParams struct {
	// DataViewId The kibana data view id to use, primarily used to include data view runtime mappings. Make sure to save SLO again if you add/update run time fields to the data view and if those fields are being used in slo queries.
	DataViewId *string `json:"dataViewId,omitempty"`

	// Filter Defines properties for a filter
	Filter *KqlWithFilters `json:"filter,omitempty"`

	// Good The KQL query used to define the good events.
	Good KqlWithFiltersGood `json:"good"`

	// Index The index or index pattern to use
	Index string `json:"index"`

	// TimestampField The timestamp field used in the source indice.
	TimestampField string `json:"timestampField"`

	// Total The KQL query used to define all events.
	Total KqlWithFiltersTotal `json:"total"`
}

// IndicatorPropertiesCustomMetric Defines properties for a custom metric indicator type
type IndicatorPropertiesCustomMetric struct {
	// Params An object containing the indicator parameters.
	Params IndicatorPropertiesCustomMetricParams `json:"params"`

	// Type The type of indicator.
	Type string `json:"type"`
}

// IndicatorPropertiesCustomMetricParams An object containing the indicator parameters.
type IndicatorPropertiesCustomMetricParams struct {
	// DataViewId The kibana data view id to use, primarily used to include data view runtime mappings. Make sure to save SLO again if you add/update run time fields to the data view and if those fields are being used in slo queries.
	DataViewId *string `json:"dataViewId,omitempty"`

	// Filter the KQL query to filter the documents with.
	Filter *string `json:"filter,omitempty"`

	// Good An object defining the "good" metrics and equation
	Good IndicatorPropertiesCustomMetricParamsGood `json:"good"`

	// Index The index or index pattern to use
	Index string `json:"index"`

	// TimestampField The timestamp field used in the source indice.
	TimestampField string `json:"timestampField"`

	// Total An object defining the "total" metrics and equation
	Total IndicatorPropertiesCustomMetricParamsTotal `json:"total"`
}

// IndicatorPropertiesCustomMetricParamsGood An object defining the "good" metrics and equation
type IndicatorPropertiesCustomMetricParamsGood struct {
	// Equation The equation to calculate the "good" metric.
	Equation string `json:"equation"`

	// Metrics List of metrics with their name, aggregation type, and field.
	Metrics []IndicatorPropertiesCustomMetricParamsGoodMetricsItem `json:"metrics"`
}

// IndicatorPropertiesCustomMetricParamsGoodMetricsItem defines model for indicator_properties_custom_metric_params_good_metrics_item.
type IndicatorPropertiesCustomMetricParamsGoodMetricsItem struct {
	// Aggregation The aggregation type of the metric. Only valid option is "sum"
	Aggregation string `json:"aggregation"`

	// Field The field of the metric.
	Field string `json:"field"`

	// Filter The filter to apply to the metric.
	Filter *string `json:"filter,omitempty"`

	// Name The name of the metric. Only valid options are A-Z
	Name string `json:"name"`
}

// IndicatorPropertiesCustomMetricParamsTotal An object defining the "total" metrics and equation
type IndicatorPropertiesCustomMetricParamsTotal struct {
	// Equation The equation to calculate the "total" metric.
	Equation string `json:"equation"`

	// Metrics List of metrics with their name, aggregation type, and field.
	Metrics []IndicatorPropertiesCustomMetricParamsTotalMetricsItem `json:"metrics"`
}

// IndicatorPropertiesCustomMetricParamsTotalMetricsItem defines model for indicator_properties_custom_metric_params_total_metrics_item.
type IndicatorPropertiesCustomMetricParamsTotalMetricsItem struct {
	// Aggregation The aggregation type of the metric. Only valid option is "sum"
	Aggregation string `json:"aggregation"`

	// Field The field of the metric.
	Field string `json:"field"`

	// Filter The filter to apply to the metric.
	Filter *string `json:"filter,omitempty"`

	// Name The name of the metric. Only valid options are A-Z
	Name string `json:"name"`
}

// IndicatorPropertiesHistogram Defines properties for a histogram indicator type
type IndicatorPropertiesHistogram struct {
	// Params An object containing the indicator parameters.
	Params IndicatorPropertiesHistogramParams `json:"params"`

	// Type The type of indicator.
	Type string `json:"type"`
}

// IndicatorPropertiesHistogramParams An object containing the indicator parameters.
type IndicatorPropertiesHistogramParams struct {
	// DataViewId The kibana data view id to use, primarily used to include data view runtime mappings. Make sure to save SLO again if you add/update run time fields to the data view and if those fields are being used in slo queries.
	DataViewId *string `json:"dataViewId,omitempty"`

	// Filter the KQL query to filter the documents with.
	Filter *string `json:"filter,omitempty"`

	// Good An object defining the "good" events
	Good IndicatorPropertiesHistogramParamsGood `json:"good"`

	// Index The index or index pattern to use
	Index string `json:"index"`

	// TimestampField The timestamp field used in the source indice.
	TimestampField string `json:"timestampField"`

	// Total An object defining the "total" events
	Total IndicatorPropertiesHistogramParamsTotal `json:"total"`
}

// IndicatorPropertiesHistogramParamsGood An object defining the "good" events
type IndicatorPropertiesHistogramParamsGood struct {
	// Aggregation The type of aggregation to use.
	Aggregation string `json:"aggregation"`

	// Field The field use to aggregate the good events.
	Field string `json:"field"`

	// Filter The filter for good events.
	Filter *string `json:"filter,omitempty"`

	// From The starting value of the range. Only required for "range" aggregations.
	From *float32 `json:"from,omitempty"`

	// To The ending value of the range. Only required for "range" aggregations.
	To *float32 `json:"to,omitempty"`
}

// IndicatorPropertiesHistogramParamsTotal An object defining the "total" events
type IndicatorPropertiesHistogramParamsTotal struct {
	// Aggregation The type of aggregation to use.
	Aggregation string `json:"aggregation"`

	// Field The field use to aggregate the good events.
	Field string `json:"field"`

	// Filter The filter for total events.
	Filter *string `json:"filter,omitempty"`

	// From The starting value of the range. Only required for "range" aggregations.
	From *float32 `json:"from,omitempty"`

	// To The ending value of the range. Only required for "range" aggregations.
	To *float32 `json:"to,omitempty"`
}

// IndicatorPropertiesTimesliceMetric Defines properties for a timeslice metric indicator type
type IndicatorPropertiesTimesliceMetric struct {
	// Params An object containing the indicator parameters.
	Params IndicatorPropertiesTimesliceMetricParams `json:"params"`

	// Type The type of indicator.
	Type string `json:"type"`
}

// IndicatorPropertiesTimesliceMetricParams An object containing the indicator parameters.
type IndicatorPropertiesTimesliceMetricParams struct {
	// DataViewId The kibana data view id to use, primarily used to include data view runtime mappings. Make sure to save SLO again if you add/update run time fields to the data view and if those fields are being used in slo queries.
	DataViewId *string `json:"dataViewId,omitempty"`

	// Filter the KQL query to filter the documents with.
	Filter *string `json:"filter,omitempty"`

	// Index The index or index pattern to use
	Index string `json:"index"`

	// Metric An object defining the metrics, equation, and threshold to determine if it's a good slice or not
	Metric IndicatorPropertiesTimesliceMetricParamsMetric `json:"metric"`

	// TimestampField The timestamp field used in the source indice.
	TimestampField string `json:"timestampField"`
}

// IndicatorPropertiesTimesliceMetricParamsMetric An object defining the metrics, equation, and threshold to determine if it's a good slice or not
type IndicatorPropertiesTimesliceMetricParamsMetric struct {
	// Comparator The comparator to use to compare the equation to the threshold.
	Comparator string `json:"comparator"`

	// Equation The equation to calculate the metric.
	Equation string `json:"equation"`

	// Metrics List of metrics with their name, aggregation type, and field.
	Metrics []IndicatorPropertiesTimesliceMetricParamsMetric_Metrics_Item `json:"metrics"`

	// Threshold The threshold used to determine if the metric is a good slice or not.
	Threshold float32 `json:"threshold"`
}

// IndicatorPropertiesTimesliceMetricParamsMetric_Metrics_Item defines model for indicator_properties_timeslice_metric_params_metric.metrics.Item.
type IndicatorPropertiesTimesliceMetricParamsMetric_Metrics_Item struct {
	union json.RawMessage
}

// InstallPackageByUploadResponseObject defines model for install-package-by-upload_response_object.
type InstallPackageByUploadResponseObject struct {
	Meta  *InstallPackageByUploadResponseObjectMeta      `json:"_meta,omitempty"`
	Items []InstallPackageByUploadResponseObjectItemItem `json:"items"`
}

// InstallPackageByUploadResponseObjectMeta defines model for install-package-by-upload_response_object__meta.
type InstallPackageByUploadResponseObjectMeta struct {
	InstallSource *string `json:"install_source,omitempty"`
}

// InstallPackageByUploadResponseObjectItemItem defines model for install-package-by-upload_response_object_item_item.
type InstallPackageByUploadResponseObjectItemItem struct {
	Id   string                                            `json:"id"`
	Type InstallPackageByUploadResponseObjectItemItem_Type `json:"type"`
}

// InstallPackageByUploadResponseObjectItemItem_Type defines model for InstallPackageByUploadResponseObjectItemItem.Type.
type InstallPackageByUploadResponseObjectItemItem_Type struct {
	union json.RawMessage
}

// InstallPackageRequest defines model for install-package_request.
type InstallPackageRequest struct {
	Force             *bool `json:"force,omitempty"`
	IgnoreConstraints *bool `json:"ignore_constraints,omitempty"`
}

// InstallPackageResponseObject defines model for install-package_response_object.
type InstallPackageResponseObject struct {
	Meta  *InstallPackageResponseObjectMeta      `json:"_meta,omitempty"`
	Items []InstallPackageResponseObjectItemItem `json:"items"`
}

// InstallPackageResponseObjectMeta defines model for install-package_response_object__meta.
type InstallPackageResponseObjectMeta struct {
	InstallSource *string `json:"install_source,omitempty"`
}

// InstallPackageResponseObjectItemItem defines model for install-package_response_object_item_item.
type InstallPackageResponseObjectItemItem struct {
	Id   string                                    `json:"id"`
	Type InstallPackageResponseObjectItemItem_Type `json:"type"`
}

// InstallPackageResponseObjectItemItem_Type defines model for InstallPackageResponseObjectItemItem.Type.
type InstallPackageResponseObjectItemItem_Type struct {
	union json.RawMessage
}

// InstallationInfo defines model for installation_info.
type InstallationInfo struct {
	CreatedAt                      *string                                        `json:"created_at,omitempty"`
	ExperimentalDataStreamFeatures InstallationInfoExperimentalDataStreamFeatures `json:"experimental_data_stream_features,omitempty"`
	InstallFormatSchemaVersion     *string                                        `json:"install_format_schema_version,omitempty"`
	InstallKibanaSpaceId           *string                                        `json:"install_kibana_space_id,omitempty"`
	InstallSource                  string                                         `json:"install_source"`
	InstallStatus                  string                                         `json:"install_status"`
	InstalledEs                    InstallationInfoInstalledEs                    `json:"installed_es"`
	InstalledKibana                InstallationInfoInstalledKibana                `json:"installed_kibana"`

	// LatestExecutedState Latest successfully executed state in package install state machine
	LatestExecutedState *InstallationInfoLatestExecutedState `json:"latest_executed_state,omitempty"`

	// LatestInstallFailedAttempts Latest failed install errors
	LatestInstallFailedAttempts []InstallationInfoLatestInstallFailedAttemptsItem `json:"latest_install_failed_attempts"`
	Name                        string                                            `json:"name"`
	Namespaces                  []string                                          `json:"namespaces,omitempty"`
	Type                        *string                                           `json:"type,omitempty"`
	UpdatedAt                   *string                                           `json:"updated_at,omitempty"`
	VerificationKeyId           *string                                           `json:"verification_key_id"`
	VerificationStatus          string                                            `json:"verification_status"`
	Version                     string                                            `json:"version"`
}

// InstallationInfoExperimentalDataStreamFeatures defines model for installation_info_experimental_data_stream_features.
type InstallationInfoExperimentalDataStreamFeatures = []interface{}

// InstallationInfoExperimentalDataStreamFeaturesFeatures defines model for installation_info_experimental_data_stream_features_features.
type InstallationInfoExperimentalDataStreamFeaturesFeatures struct {
	DocValueOnlyNumeric *bool `json:"doc_value_only_numeric"`
	DocValueOnlyOther   *bool `json:"doc_value_only_other"`
	SyntheticSource     *bool `json:"synthetic_source"`
	Tsdb                *bool `json:"tsdb"`
}

// InstallationInfoInstalledEs defines model for installation_info_installed_es.
type InstallationInfoInstalledEs struct {
	Deferred *bool                   `json:"deferred,omitempty"`
	Id       *string                 `json:"id,omitempty"`
	Type     *ElasticsearchAssetType `json:"type,omitempty"`
}

// InstallationInfoInstalledKibana defines model for installation_info_installed_kibana.
type InstallationInfoInstalledKibana struct {
	Id   *string                `json:"id,omitempty"`
	Type *KibanaSavedObjectType `json:"type,omitempty"`
}

// InstallationInfoLatestExecutedState Latest successfully executed state in package install state machine
type InstallationInfoLatestExecutedState struct {
	Error     *string `json:"error,omitempty"`
	Name      *string `json:"name,omitempty"`
	StartedAt *string `json:"started_at,omitempty"`
}

// InstallationInfoLatestInstallFailedAttemptsItem defines model for installation_info_latest_install_failed_attempts_item.
type InstallationInfoLatestInstallFailedAttemptsItem struct {
	CreatedAt     *string                                               `json:"created_at,omitempty"`
	Error         *InstallationInfoLatestInstallFailedAttemptsItemError `json:"error,omitempty"`
	TargetVersion *string                                               `json:"target_version,omitempty"`
}

// InstallationInfoLatestInstallFailedAttemptsItemError defines model for installation_info_latest_install_failed_attempts_item_error.
type InstallationInfoLatestInstallFailedAttemptsItemError struct {
	Message *string `json:"message,omitempty"`
	Name    *string `json:"name,omitempty"`
	Stack   *string `json:"stack,omitempty"`
}

// KibanaSavedObjectType defines model for kibana_saved_object_type.
type KibanaSavedObjectType = string

// KqlWithFilters Defines properties for a filter
type KqlWithFilters struct {
	union json.RawMessage
}

// KqlWithFilters0 the KQL query to filter the documents with.
type KqlWithFilters0 = string

// KqlWithFiltersGood The KQL query used to define the good events.
type KqlWithFiltersGood struct {
	union json.RawMessage
}

// KqlWithFiltersGood0 the KQL query to filter the documents with.
type KqlWithFiltersGood0 = string

// KqlWithFiltersGoodOneOf1 defines model for kql_with_filters_good_oneOf_1.
type KqlWithFiltersGoodOneOf1 struct {
	Filters  []Filter `json:"filters,omitempty"`
	KqlQuery *string  `json:"kqlQuery,omitempty"`
}

// KqlWithFiltersOneOf1 defines model for kql_with_filters_oneOf_1.
type KqlWithFiltersOneOf1 struct {
	Filters  []Filter `json:"filters,omitempty"`
	KqlQuery *string  `json:"kqlQuery,omitempty"`
}

// KqlWithFiltersTotal The KQL query used to define all events.
type KqlWithFiltersTotal struct {
	union json.RawMessage
}

// KqlWithFiltersTotal0 the KQL query to filter the documents with.
type KqlWithFiltersTotal0 = string

// KqlWithFiltersTotalOneOf1 defines model for kql_with_filters_total_oneOf_1.
type KqlWithFiltersTotalOneOf1 struct {
	Filters  []Filter `json:"filters,omitempty"`
	KqlQuery *string  `json:"kqlQuery,omitempty"`
}

// Namespaces An array of space identifiers for sharing the data view between multiple spaces.
type Namespaces = []string

// NewPackagePolicy defines model for new_package_policy.
type NewPackagePolicy struct {
	Description *string                               `json:"description,omitempty"`
	Enabled     *bool                                 `json:"enabled,omitempty"`
	Inputs      map[string]NewPackagePolicyInputsItem `json:"inputs"`
	Name        string                                `json:"name"`
	Namespace   *string                               `json:"namespace,omitempty"`
	OutputId    *string                               `json:"output_id,omitempty"`
	Overrides   map[string]interface{}                `json:"overrides,omitempty"`
	Package     *NewPackagePolicyPackage              `json:"package,omitempty"`
	// Deprecated:
	PolicyId         *string                                `json:"policy_id"`
	PolicyIds        []string                               `json:"policy_ids,omitempty"`
	SecretReferences []NewPackagePolicySecretReferencesItem `json:"secret_references,omitempty"`
	Vars             map[string]interface{}                 `json:"vars,omitempty"`
}

// NewPackagePolicyInputsItem defines model for new_package_policy_inputs_item.
type NewPackagePolicyInputsItem struct {
	Config     map[string]interface{}                           `json:"config,omitempty"`
	Enabled    bool                                             `json:"enabled"`
	Processors []string                                         `json:"processors,omitempty"`
	Streams    map[string]NewPackagePolicyInputsItemStreamsItem `json:"streams,omitempty"`
	Type       string                                           `json:"type"`
	Vars       map[string]interface{}                           `json:"vars,omitempty"`
}

// NewPackagePolicyInputsItemStreamsItem defines model for new_package_policy_inputs_item_streams_item.
type NewPackagePolicyInputsItemStreamsItem struct {
	Enabled *bool                  `json:"enabled,omitempty"`
	Vars    map[string]interface{} `json:"vars,omitempty"`
}

// NewPackagePolicyPackage defines model for new_package_policy_package.
type NewPackagePolicyPackage struct {
	Name         string  `json:"name"`
	RequiresRoot *bool   `json:"requires_root,omitempty"`
	Title        *string `json:"title,omitempty"`
	Version      string  `json:"version"`
}

// NewPackagePolicySecretReferencesItem defines model for new_package_policy_secret_references_item.
type NewPackagePolicySecretReferencesItem struct {
	Id *string `json:"id,omitempty"`
}

// Objective Defines properties for the SLO objective
type Objective struct {
	// Target the target objective between 0 and 1 excluded
	Target float32 `json:"target"`

	// TimesliceTarget the target objective for each slice when using a timeslices budgeting method
	TimesliceTarget *float32 `json:"timesliceTarget,omitempty"`

	// TimesliceWindow the duration of each slice when using a timeslices budgeting method, as {duraton}{unit}
	TimesliceWindow *string `json:"timesliceWindow,omitempty"`
}

// OutputCreateRequest defines model for output_create_request.
type OutputCreateRequest struct {
	union json.RawMessage
}

// OutputCreateRequestElasticsearch defines model for output_create_request_elasticsearch.
type OutputCreateRequestElasticsearch struct {
	CaSha256             *string                                  `json:"ca_sha256,omitempty"`
	CaTrustedFingerprint *string                                  `json:"ca_trusted_fingerprint,omitempty"`
	Config               map[string]interface{}                   `json:"config,omitempty"`
	ConfigYaml           *string                                  `json:"config_yaml,omitempty"`
	Hosts                []string                                 `json:"hosts,omitempty"`
	Id                   *string                                  `json:"id,omitempty"`
	IsDefault            *bool                                    `json:"is_default,omitempty"`
	IsDefaultMonitoring  *bool                                    `json:"is_default_monitoring,omitempty"`
	IsInternal           *bool                                    `json:"is_internal,omitempty"`
	Name                 string                                   `json:"name"`
	Preset               *string                                  `json:"preset,omitempty"`
	ProxyId              *string                                  `json:"proxy_id,omitempty"`
	Shipper              *OutputCreateRequestElasticsearchShipper `json:"shipper,omitempty"`
	Ssl                  *OutputCreateRequestElasticsearchSsl     `json:"ssl,omitempty"`
	Type                 string                                   `json:"type"`
}

// OutputCreateRequestElasticsearchShipper defines model for output_create_request_elasticsearch_shipper.
type OutputCreateRequestElasticsearchShipper struct {
	CompressionLevel            *float32 `json:"compression_level,omitempty"`
	DiskQueueCompressionEnabled *bool    `json:"disk_queue_compression_enabled,omitempty"`
	DiskQueueEnabled            *bool    `json:"disk_queue_enabled,omitempty"`
	DiskQueueEncryptionEnabled  *bool    `json:"disk_queue_encryption_enabled,omitempty"`
	DiskQueueMaxSize            *float32 `json:"disk_queue_max_size,omitempty"`
	DiskQueuePath               *string  `json:"disk_queue_path,omitempty"`
	Loadbalance                 *bool    `json:"loadbalance,omitempty"`
}

// OutputCreateRequestElasticsearchSsl defines model for output_create_request_elasticsearch_ssl.
type OutputCreateRequestElasticsearchSsl struct {
	Certificate            *string  `json:"certificate,omitempty"`
	CertificateAuthorities []string `json:"certificate_authorities,omitempty"`
	Key                    *string  `json:"key,omitempty"`
}

// OutputCreateRequestKafka defines model for output_create_request_kafka.
type OutputCreateRequestKafka struct {
	AuthType             string                                `json:"auth_type"`
	BrokerTimeout        *float32                              `json:"broker_timeout,omitempty"`
	CaSha256             *string                               `json:"ca_sha256,omitempty"`
	CaTrustedFingerprint *string                               `json:"ca_trusted_fingerprint,omitempty"`
	ClientId             *string                               `json:"client_id,omitempty"`
	Compression          *string                               `json:"compression,omitempty"`
	CompressionLevel     *float32                              `json:"compression_level,omitempty"`
	Config               map[string]interface{}                `json:"config,omitempty"`
	ConfigYaml           *string                               `json:"config_yaml,omitempty"`
	ConnectionType       *string                               `json:"connection_type,omitempty"`
	Headers              []OutputCreateRequestKafkaHeadersItem `json:"headers,omitempty"`
	Hosts                []string                              `json:"hosts"`
	Id                   *string                               `json:"id,omitempty"`
	IsDefault            *bool                                 `json:"is_default,omitempty"`
	IsDefaultMonitoring  *bool                                 `json:"is_default_monitoring,omitempty"`
	IsInternal           *bool                                 `json:"is_internal,omitempty"`
	Key                  *string                               `json:"key,omitempty"`
	Name                 string                                `json:"name"`
	Partition            *string                               `json:"partition,omitempty"`
	Password             *string                               `json:"password,omitempty"`
	ProxyId              *string                               `json:"proxy_id,omitempty"`
	Random               *OutputCreateRequestKafkaRandom       `json:"random,omitempty"`
	RequiredAcks         *float32                              `json:"required_acks,omitempty"`
	RoundRobin           *OutputCreateRequestKafkaRoundRobin   `json:"round_robin,omitempty"`
	Sasl                 *OutputCreateRequestKafkaSasl         `json:"sasl,omitempty"`
	Secrets              *OutputCreateRequestKafkaSecrets      `json:"secrets,omitempty"`
	Shipper              *OutputCreateRequestKafkaShipper      `json:"shipper,omitempty"`
	Ssl                  *OutputCreateRequestKafkaSsl          `json:"ssl,omitempty"`
	Timeout              *float32                              `json:"timeout,omitempty"`
	Topic                *string                               `json:"topic,omitempty"`

	// Topics Use topic instead.
	// Deprecated:
	Topics   []OutputCreateRequestKafkaTopicsItem `json:"topics"`
	Type     string                               `json:"type"`
	Username *string                              `json:"username,omitempty"`
	Version  *string                              `json:"version,omitempty"`
}

// OutputCreateRequestKafkaHeadersItem defines model for output_create_request_kafka_headers_item.
type OutputCreateRequestKafkaHeadersItem struct {
	Key   *string `json:"key,omitempty"`
	Value *string `json:"value,omitempty"`
}

// OutputCreateRequestKafkaRandom defines model for output_create_request_kafka_random.
type OutputCreateRequestKafkaRandom struct {
	GroupEvents *float32 `json:"group_events,omitempty"`
}

// OutputCreateRequestKafkaRoundRobin defines model for output_create_request_kafka_round_robin.
type OutputCreateRequestKafkaRoundRobin struct {
	GroupEvents *float32 `json:"group_events,omitempty"`
}

// OutputCreateRequestKafkaSasl defines model for output_create_request_kafka_sasl.
type OutputCreateRequestKafkaSasl struct {
	Mechanism *string `json:"mechanism,omitempty"`
}

// OutputCreateRequestKafkaSecrets defines model for output_create_request_kafka_secrets.
type OutputCreateRequestKafkaSecrets struct {
	Password *string                             `json:"password,omitempty"`
	Ssl      *OutputCreateRequestKafkaSecretsSsl `json:"ssl,omitempty"`
}

// OutputCreateRequestKafkaSecretsSsl defines model for output_create_request_kafka_secrets_ssl.
type OutputCreateRequestKafkaSecretsSsl struct {
	Key *string `json:"key,omitempty"`
}

// OutputCreateRequestKafkaShipper defines model for output_create_request_kafka_shipper.
type OutputCreateRequestKafkaShipper struct {
	CompressionLevel            *float32 `json:"compression_level,omitempty"`
	DiskQueueCompressionEnabled *bool    `json:"disk_queue_compression_enabled,omitempty"`
	DiskQueueEnabled            *bool    `json:"disk_queue_enabled,omitempty"`
	DiskQueueEncryptionEnabled  *bool    `json:"disk_queue_encryption_enabled,omitempty"`
	DiskQueueMaxSize            *float32 `json:"disk_queue_max_size,omitempty"`
	DiskQueuePath               *string  `json:"disk_queue_path,omitempty"`
	Loadbalance                 *bool    `json:"loadbalance,omitempty"`
}

// OutputCreateRequestKafkaSsl defines model for output_create_request_kafka_ssl.
type OutputCreateRequestKafkaSsl struct {
	Certificate            *string  `json:"certificate,omitempty"`
	CertificateAuthorities []string `json:"certificate_authorities,omitempty"`
	Key                    *string  `json:"key,omitempty"`
	VerificationMode       *string  `json:"verification_mode,omitempty"`
}

// OutputCreateRequestKafkaTopicsItem defines model for output_create_request_kafka_topics_item.
type OutputCreateRequestKafkaTopicsItem struct {
	Topic *string `json:"topic,omitempty"`

	// When Deprecated, kafka output do not support conditionnal topics anymore.
	// Deprecated:
	When *OutputCreateRequestKafkaTopicsItemWhen `json:"when,omitempty"`
}

// OutputCreateRequestKafkaTopicsItemWhen Deprecated, kafka output do not support conditionnal topics anymore.
type OutputCreateRequestKafkaTopicsItemWhen struct {
	Condition *string `json:"condition,omitempty"`
	Type      *string `json:"type,omitempty"`
}

// OutputCreateRequestLogstash defines model for output_create_request_logstash.
type OutputCreateRequestLogstash struct {
	CaSha256             *string                             `json:"ca_sha256,omitempty"`
	CaTrustedFingerprint *string                             `json:"ca_trusted_fingerprint,omitempty"`
	Config               map[string]interface{}              `json:"config,omitempty"`
	ConfigYaml           *string                             `json:"config_yaml,omitempty"`
	Hosts                []string                            `json:"hosts"`
	Id                   *string                             `json:"id,omitempty"`
	IsDefault            *bool                               `json:"is_default,omitempty"`
	IsDefaultMonitoring  *bool                               `json:"is_default_monitoring,omitempty"`
	IsInternal           *bool                               `json:"is_internal,omitempty"`
	Name                 string                              `json:"name"`
	ProxyId              *string                             `json:"proxy_id,omitempty"`
	Secrets              *OutputCreateRequestLogstashSecrets `json:"secrets,omitempty"`
	Shipper              *OutputCreateRequestLogstashShipper `json:"shipper,omitempty"`
	Ssl                  *OutputCreateRequestLogstashSsl     `json:"ssl,omitempty"`
	Type                 string                              `json:"type"`
}

// OutputCreateRequestLogstashSecrets defines model for output_create_request_logstash_secrets.
type OutputCreateRequestLogstashSecrets struct {
	Ssl *OutputCreateRequestLogstashSecretsSsl `json:"ssl,omitempty"`
}

// OutputCreateRequestLogstashSecretsSsl defines model for output_create_request_logstash_secrets_ssl.
type OutputCreateRequestLogstashSecretsSsl struct {
	Key *string `json:"key,omitempty"`
}

// OutputCreateRequestLogstashShipper defines model for output_create_request_logstash_shipper.
type OutputCreateRequestLogstashShipper struct {
	CompressionLevel            *float32 `json:"compression_level,omitempty"`
	DiskQueueCompressionEnabled *bool    `json:"disk_queue_compression_enabled,omitempty"`
	DiskQueueEnabled            *bool    `json:"disk_queue_enabled,omitempty"`
	DiskQueueEncryptionEnabled  *bool    `json:"disk_queue_encryption_enabled,omitempty"`
	DiskQueueMaxSize            *float32 `json:"disk_queue_max_size,omitempty"`
	DiskQueuePath               *string  `json:"disk_queue_path,omitempty"`
	Loadbalance                 *bool    `json:"loadbalance,omitempty"`
}

// OutputCreateRequestLogstashSsl defines model for output_create_request_logstash_ssl.
type OutputCreateRequestLogstashSsl struct {
	Certificate            *string  `json:"certificate,omitempty"`
	CertificateAuthorities []string `json:"certificate_authorities,omitempty"`
	Key                    *string  `json:"key,omitempty"`
}

// OutputCreateRequestRemoteElasticsearch defines model for output_create_request_remote_elasticsearch.
type OutputCreateRequestRemoteElasticsearch struct {
	Hosts               []string                                       `json:"hosts,omitempty"`
	Id                  *string                                        `json:"id,omitempty"`
	IsDefault           *bool                                          `json:"is_default,omitempty"`
	IsDefaultMonitoring *bool                                          `json:"is_default_monitoring,omitempty"`
	IsInternal          *bool                                          `json:"is_internal,omitempty"`
	Name                string                                         `json:"name"`
	Secrets             *OutputCreateRequestRemoteElasticsearchSecrets `json:"secrets,omitempty"`
	ServiceToken        *string                                        `json:"service_token,omitempty"`
	Type                string                                         `json:"type"`
}

// OutputCreateRequestRemoteElasticsearchSecrets defines model for output_create_request_remote_elasticsearch_secrets.
type OutputCreateRequestRemoteElasticsearchSecrets struct {
	ServiceToken *string `json:"service_token,omitempty"`
}

// OutputUpdateRequest defines model for output_update_request.
type OutputUpdateRequest struct {
	union json.RawMessage
}

// OutputUpdateRequestElasticsearch defines model for output_update_request_elasticsearch.
type OutputUpdateRequestElasticsearch struct {
	CaSha256             *string                                  `json:"ca_sha256,omitempty"`
	CaTrustedFingerprint *string                                  `json:"ca_trusted_fingerprint,omitempty"`
	Config               map[string]interface{}                   `json:"config,omitempty"`
	ConfigYaml           *string                                  `json:"config_yaml,omitempty"`
	Hosts                []string                                 `json:"hosts"`
	Id                   *string                                  `json:"id,omitempty"`
	IsDefault            *bool                                    `json:"is_default,omitempty"`
	IsDefaultMonitoring  *bool                                    `json:"is_default_monitoring,omitempty"`
	IsInternal           *bool                                    `json:"is_internal,omitempty"`
	Name                 string                                   `json:"name"`
	Preset               *string                                  `json:"preset,omitempty"`
	ProxyId              *string                                  `json:"proxy_id,omitempty"`
	Shipper              *OutputUpdateRequestElasticsearchShipper `json:"shipper,omitempty"`
	Ssl                  *OutputUpdateRequestElasticsearchSsl     `json:"ssl,omitempty"`
	Type                 string                                   `json:"type"`
}

// OutputUpdateRequestElasticsearchShipper defines model for output_update_request_elasticsearch_shipper.
type OutputUpdateRequestElasticsearchShipper struct {
	CompressionLevel            *float32 `json:"compression_level,omitempty"`
	DiskQueueCompressionEnabled *bool    `json:"disk_queue_compression_enabled,omitempty"`
	DiskQueueEnabled            *bool    `json:"disk_queue_enabled,omitempty"`
	DiskQueueEncryptionEnabled  *bool    `json:"disk_queue_encryption_enabled,omitempty"`
	DiskQueueMaxSize            *float32 `json:"disk_queue_max_size,omitempty"`
	DiskQueuePath               *string  `json:"disk_queue_path,omitempty"`
	Loadbalance                 *bool    `json:"loadbalance,omitempty"`
}

// OutputUpdateRequestElasticsearchSsl defines model for output_update_request_elasticsearch_ssl.
type OutputUpdateRequestElasticsearchSsl struct {
	Certificate            *string  `json:"certificate,omitempty"`
	CertificateAuthorities []string `json:"certificate_authorities,omitempty"`
	Key                    *string  `json:"key,omitempty"`
}

// OutputUpdateRequestKafka defines model for output_update_request_kafka.
type OutputUpdateRequestKafka struct {
	AuthType             *string                               `json:"auth_type,omitempty"`
	BrokerTimeout        *float32                              `json:"broker_timeout,omitempty"`
	CaSha256             *string                               `json:"ca_sha256,omitempty"`
	CaTrustedFingerprint *string                               `json:"ca_trusted_fingerprint,omitempty"`
	ClientId             *string                               `json:"client_id,omitempty"`
	Compression          *string                               `json:"compression,omitempty"`
	CompressionLevel     *float32                              `json:"compression_level,omitempty"`
	Config               map[string]interface{}                `json:"config,omitempty"`
	ConfigYaml           *string                               `json:"config_yaml,omitempty"`
	ConnectionType       *string                               `json:"connection_type,omitempty"`
	Headers              []OutputUpdateRequestKafkaHeadersItem `json:"headers,omitempty"`
	Hosts                []string                              `json:"hosts,omitempty"`
	Id                   *string                               `json:"id,omitempty"`
	IsDefault            *bool                                 `json:"is_default,omitempty"`
	IsDefaultMonitoring  *bool                                 `json:"is_default_monitoring,omitempty"`
	IsInternal           *bool                                 `json:"is_internal,omitempty"`
	Key                  *string                               `json:"key,omitempty"`
	Name                 string                                `json:"name"`
	Partition            *string                               `json:"partition,omitempty"`
	Password             *string                               `json:"password,omitempty"`
	ProxyId              *string                               `json:"proxy_id,omitempty"`
	Random               *OutputUpdateRequestKafkaRandom       `json:"random,omitempty"`
	RequiredAcks         *float32                              `json:"required_acks,omitempty"`
	RoundRobin           *OutputUpdateRequestKafkaRoundRobin   `json:"round_robin,omitempty"`
	Sasl                 *OutputUpdateRequestKafkaSasl         `json:"sasl,omitempty"`
	Shipper              *OutputUpdateRequestKafkaShipper      `json:"shipper,omitempty"`
	Ssl                  *OutputUpdateRequestKafkaSsl          `json:"ssl,omitempty"`
	Timeout              *float32                              `json:"timeout,omitempty"`
	Topic                *string                               `json:"topic,omitempty"`

	// Topics Use topic instead.
	// Deprecated:
	Topics   []OutputUpdateRequestKafkaTopicsItem `json:"topics,omitempty"`
	Type     string                               `json:"type"`
	Username *string                              `json:"username,omitempty"`
	Version  *string                              `json:"version,omitempty"`
}

// OutputUpdateRequestKafkaHeadersItem defines model for output_update_request_kafka_headers_item.
type OutputUpdateRequestKafkaHeadersItem struct {
	Key   *string `json:"key,omitempty"`
	Value *string `json:"value,omitempty"`
}

// OutputUpdateRequestKafkaRandom defines model for output_update_request_kafka_random.
type OutputUpdateRequestKafkaRandom struct {
	GroupEvents *float32 `json:"group_events,omitempty"`
}

// OutputUpdateRequestKafkaRoundRobin defines model for output_update_request_kafka_round_robin.
type OutputUpdateRequestKafkaRoundRobin struct {
	GroupEvents *float32 `json:"group_events,omitempty"`
}

// OutputUpdateRequestKafkaSasl defines model for output_update_request_kafka_sasl.
type OutputUpdateRequestKafkaSasl struct {
	Mechanism *string `json:"mechanism,omitempty"`
}

// OutputUpdateRequestKafkaShipper defines model for output_update_request_kafka_shipper.
type OutputUpdateRequestKafkaShipper struct {
	CompressionLevel            *float32 `json:"compression_level,omitempty"`
	DiskQueueCompressionEnabled *bool    `json:"disk_queue_compression_enabled,omitempty"`
	DiskQueueEnabled            *bool    `json:"disk_queue_enabled,omitempty"`
	DiskQueueEncryptionEnabled  *bool    `json:"disk_queue_encryption_enabled,omitempty"`
	DiskQueueMaxSize            *float32 `json:"disk_queue_max_size,omitempty"`
	DiskQueuePath               *string  `json:"disk_queue_path,omitempty"`
	Loadbalance                 *bool    `json:"loadbalance,omitempty"`
}

// OutputUpdateRequestKafkaSsl defines model for output_update_request_kafka_ssl.
type OutputUpdateRequestKafkaSsl struct {
	Certificate            *string  `json:"certificate,omitempty"`
	CertificateAuthorities []string `json:"certificate_authorities,omitempty"`
	Key                    *string  `json:"key,omitempty"`
	VerificationMode       *string  `json:"verification_mode,omitempty"`
}

// OutputUpdateRequestKafkaTopicsItem defines model for output_update_request_kafka_topics_item.
type OutputUpdateRequestKafkaTopicsItem struct {
	Topic *string `json:"topic,omitempty"`

	// When Deprecated, kafka output do not support conditionnal topics anymore.
	// Deprecated:
	When *OutputUpdateRequestKafkaTopicsItemWhen `json:"when,omitempty"`
}

// OutputUpdateRequestKafkaTopicsItemWhen Deprecated, kafka output do not support conditionnal topics anymore.
type OutputUpdateRequestKafkaTopicsItemWhen struct {
	Condition *string `json:"condition,omitempty"`
	Type      *string `json:"type,omitempty"`
}

// OutputUpdateRequestLogstash defines model for output_update_request_logstash.
type OutputUpdateRequestLogstash struct {
	CaSha256             *string                             `json:"ca_sha256,omitempty"`
	CaTrustedFingerprint *string                             `json:"ca_trusted_fingerprint,omitempty"`
	Config               map[string]interface{}              `json:"config,omitempty"`
	ConfigYaml           *string                             `json:"config_yaml,omitempty"`
	Hosts                []string                            `json:"hosts,omitempty"`
	Id                   *string                             `json:"id,omitempty"`
	IsDefault            *bool                               `json:"is_default,omitempty"`
	IsDefaultMonitoring  *bool                               `json:"is_default_monitoring,omitempty"`
	IsInternal           *bool                               `json:"is_internal,omitempty"`
	Name                 string                              `json:"name"`
	ProxyId              *string                             `json:"proxy_id,omitempty"`
	Shipper              *OutputUpdateRequestLogstashShipper `json:"shipper,omitempty"`
	Ssl                  *OutputUpdateRequestLogstashSsl     `json:"ssl,omitempty"`
	Type                 string                              `json:"type"`
}

// OutputUpdateRequestLogstashShipper defines model for output_update_request_logstash_shipper.
type OutputUpdateRequestLogstashShipper struct {
	CompressionLevel            *float32 `json:"compression_level,omitempty"`
	DiskQueueCompressionEnabled *bool    `json:"disk_queue_compression_enabled,omitempty"`
	DiskQueueEnabled            *bool    `json:"disk_queue_enabled,omitempty"`
	DiskQueueEncryptionEnabled  *bool    `json:"disk_queue_encryption_enabled,omitempty"`
	DiskQueueMaxSize            *float32 `json:"disk_queue_max_size,omitempty"`
	DiskQueuePath               *string  `json:"disk_queue_path,omitempty"`
	Loadbalance                 *bool    `json:"loadbalance,omitempty"`
}

// OutputUpdateRequestLogstashSsl defines model for output_update_request_logstash_ssl.
type OutputUpdateRequestLogstashSsl struct {
	Certificate            *string  `json:"certificate,omitempty"`
	CertificateAuthorities []string `json:"certificate_authorities,omitempty"`
	Key                    *string  `json:"key,omitempty"`
}

// PackageInfo defines model for package_info.
type PackageInfo struct {
	Assets        []string                     `json:"assets"`
	Categories    []string                     `json:"categories"`
	Conditions    PackageInfoConditions        `json:"conditions"`
	DataStreams   []PackageInfoDataStreamsItem `json:"data_streams,omitempty"`
	Description   string                       `json:"description"`
	Download      string                       `json:"download"`
	Elasticsearch *PackageInfoElasticsearch    `json:"elasticsearch,omitempty"`
	FormatVersion string                       `json:"format_version"`
	Icons         []string                     `json:"icons,omitempty"`
	Internal      *bool                        `json:"internal,omitempty"`
	Name          string                       `json:"name"`
	Path          string                       `json:"path"`
	Readme        *string                      `json:"readme,omitempty"`

	// Release release label is deprecated, derive from the version instead (packages follow semver)
	// Deprecated:
	Release     *string                      `json:"release,omitempty"`
	Screenshots []PackageInfoScreenshotsItem `json:"screenshots,omitempty"`
	Source      *PackageInfoSource           `json:"source,omitempty"`
	Title       string                       `json:"title"`
	Type        string                       `json:"type"`
	Version     string                       `json:"version"`
}

// PackageInfoConditions defines model for package_info_conditions.
type PackageInfoConditions struct {
	Elasticsearch *PackageInfoConditionsElasticsearch `json:"elasticsearch,omitempty"`
	Kibana        *PackageInfoConditionsKibana        `json:"kibana,omitempty"`
}

// PackageInfoConditionsElasticsearch defines model for package_info_conditions_elasticsearch.
type PackageInfoConditionsElasticsearch struct {
	Subscription *string `json:"subscription,omitempty"`
}

// PackageInfoConditionsKibana defines model for package_info_conditions_kibana.
type PackageInfoConditionsKibana struct {
	Versions *string `json:"versions,omitempty"`
}

// PackageInfoDataStreamsItem defines model for package_info_data_streams_item.
type PackageInfoDataStreamsItem struct {
	IngesetPipeline string                               `json:"ingeset_pipeline"`
	Name            string                               `json:"name"`
	Package         string                               `json:"package"`
	Release         string                               `json:"release"`
	Title           string                               `json:"title"`
	Type            string                               `json:"type"`
	Vars            []PackageInfoDataStreamsItemVarsItem `json:"vars,omitempty"`
}

// PackageInfoDataStreamsItemVarsItem defines model for package_info_data_streams_item_vars_item.
type PackageInfoDataStreamsItemVarsItem struct {
	Default string `json:"default"`
	Name    string `json:"name"`
}

// PackageInfoElasticsearch defines model for package_info_elasticsearch.
type PackageInfoElasticsearch struct {
	Privileges *PackageInfoElasticsearchPrivileges `json:"privileges,omitempty"`
}

// PackageInfoElasticsearchPrivileges defines model for package_info_elasticsearch_privileges.
type PackageInfoElasticsearchPrivileges struct {
	Cluster []string `json:"cluster,omitempty"`
}

// PackageInfoScreenshotsItem defines model for package_info_screenshots_item.
type PackageInfoScreenshotsItem struct {
	Path  string  `json:"path"`
	Size  *string `json:"size,omitempty"`
	Src   string  `json:"src"`
	Title *string `json:"title,omitempty"`
	Type  *string `json:"type,omitempty"`
}

// PackageInfoSource defines model for package_info_source.
type PackageInfoSource struct {
	License *string `json:"license,omitempty"`
}

// PackagePolicy defines model for package_policy.
type PackagePolicy struct {
	Description *string                               `json:"description,omitempty"`
	Enabled     *bool                                 `json:"enabled,omitempty"`
	Id          string                                `json:"id"`
	Inputs      map[string]NewPackagePolicyInputsItem `json:"inputs"`
	Name        string                                `json:"name"`
	Namespace   *string                               `json:"namespace,omitempty"`
	OutputId    *string                               `json:"output_id,omitempty"`
	Overrides   map[string]interface{}                `json:"overrides,omitempty"`
	Package     *NewPackagePolicyPackage              `json:"package,omitempty"`
	// Deprecated:
	PolicyId         *string                                `json:"policy_id"`
	PolicyIds        []string                               `json:"policy_ids,omitempty"`
	Revision         float32                                `json:"revision"`
	SecretReferences []NewPackagePolicySecretReferencesItem `json:"secret_references,omitempty"`
	Vars             map[string]interface{}                 `json:"vars,omitempty"`
}

// PackagePolicyAllOf0 defines model for package_policy_allOf_0.
type PackagePolicyAllOf0 struct {
	Id       string                      `json:"id"`
	Inputs   *PackagePolicyAllOf0_Inputs `json:"inputs,omitempty"`
	Revision float32                     `json:"revision"`
}

// PackagePolicyAllOf0Inputs0 defines model for .
type PackagePolicyAllOf0Inputs0 = []interface{}

// PackagePolicyAllOf0Inputs1 defines model for .
type PackagePolicyAllOf0Inputs1 = map[string]interface{}

// PackagePolicyAllOf0_Inputs defines model for PackagePolicyAllOf0.Inputs.
type PackagePolicyAllOf0_Inputs struct {
	union json.RawMessage
}

// PackagePolicyRequest defines model for package_policy_request.
type PackagePolicyRequest struct {
	// Description Package policy description
	Description *string `json:"description,omitempty"`

	// Force Force package policy creation even if package is not verified, or if the agent policy is managed.
	Force *bool `json:"force,omitempty"`

	// Id Package policy unique identifier
	Id *string `json:"id,omitempty"`

	// Inputs Package policy inputs (see integration documentation to know what inputs are available)
	Inputs map[string]PackagePolicyRequestInputsItem `json:"inputs,omitempty"`

	// Name Package policy name (should be unique)
	Name string `json:"name"`

	// Namespace The package policy namespace. Leave blank to inherit the agent policy's namespace.
	Namespace *string `json:"namespace,omitempty"`

	// OutputId Output ID to send package data to
	OutputId *string `json:"output_id"`

	// Overrides Override settings that are defined in the package policy. The override option should be used only in unusual circumstances and not as a routine procedure.
	Overrides *PackagePolicyRequestOverrides `json:"overrides"`
	Package   PackagePolicyRequestPackage    `json:"package"`

	// PolicyId Agent policy ID where that package policy will be added
	// Deprecated:
	PolicyId *string `json:"policy_id"`

	// PolicyIds Agent policy IDs where that package policy will be added
	PolicyIds []string `json:"policy_ids,omitempty"`

	// Vars Package root level variable (see integration documentation for more information)
	Vars map[string]interface{} `json:"vars,omitempty"`
}

// PackagePolicyRequestInputsItem defines model for package_policy_request_inputs_item.
type PackagePolicyRequestInputsItem struct {
	// Enabled enable or disable that input, (default to true)
	Enabled *bool `json:"enabled,omitempty"`

	// Streams Input streams (see integration documentation to know what streams are available)
	Streams map[string]PackagePolicyRequestInputsItemStreamsItem `json:"streams,omitempty"`

	// Vars Input level variable (see integration documentation for more information)
	Vars map[string]interface{} `json:"vars,omitempty"`
}

// PackagePolicyRequestInputsItemStreamsItem defines model for package_policy_request_inputs_item_streams_item.
type PackagePolicyRequestInputsItemStreamsItem struct {
	// Enabled enable or disable that stream, (default to true)
	Enabled *bool `json:"enabled,omitempty"`

	// Vars Stream level variable (see integration documentation for more information)
	Vars map[string]interface{} `json:"vars,omitempty"`
}

// PackagePolicyRequestOverrides Override settings that are defined in the package policy. The override option should be used only in unusual circumstances and not as a routine procedure.
type PackagePolicyRequestOverrides struct {
	Inputs map[string]interface{} `json:"inputs,omitempty"`
}

// PackagePolicyRequestPackage defines model for package_policy_request_package.
type PackagePolicyRequestPackage struct {
	// Name Package name
	Name string `json:"name"`

	// Version Package version
	Version string `json:"version"`
}

// PostFleetServerHostsRequest defines model for post-fleet-server-hosts_request.
type PostFleetServerHostsRequest struct {
	HostUrls   []string `json:"host_urls"`
	Id         *string  `json:"id,omitempty"`
	IsDefault  *bool    `json:"is_default,omitempty"`
	IsInternal *bool    `json:"is_internal,omitempty"`
	Name       string   `json:"name"`

	// ProxyId The ID of the proxy to use for this fleet server host. See the proxies API for more information.
	ProxyId *string `json:"proxy_id,omitempty"`
}

// PostFleetServerHostsResponseObject defines model for post-fleet-server-hosts_response_object.
type PostFleetServerHostsResponseObject struct {
	Item *FleetServerHost `json:"item,omitempty"`
}

// PostOutputsResponseObject defines model for post-outputs_response_object.
type PostOutputsResponseObject struct {
	Item *OutputCreateRequest `json:"item,omitempty"`
}

// Runtimefieldmap A map of runtime field definitions by field name.
type Runtimefieldmap struct {
	Script RuntimefieldmapScript `json:"script"`

	// Type Mapping type of the runtime field.
	Type string `json:"type"`
}

// RuntimefieldmapScript defines model for runtimefieldmap_script.
type RuntimefieldmapScript struct {
	// Source Script for the runtime field.
	Source *string `json:"source,omitempty"`
}

// SearchResult defines model for search_result.
type SearchResult struct {
	Description      string            `json:"description"`
	Download         string            `json:"download"`
	Icons            string            `json:"icons"`
	InstallationInfo *InstallationInfo `json:"installationInfo,omitempty"`
	Name             string            `json:"name"`
	Path             string            `json:"path"`
	// Deprecated:
	SavedObject map[string]interface{} `json:"savedObject,omitempty"`
	Status      string                 `json:"status"`
	Title       string                 `json:"title"`
	Type        string                 `json:"type"`
	Version     string                 `json:"version"`
}

// Settings Defines properties for SLO settings.
type Settings struct {
	// Frequency Configure how often the transform runs, default 1m
	Frequency *string `json:"frequency,omitempty"`

	// PreventInitialBackfill Prevents the transform from backfilling data when it starts.
	PreventInitialBackfill *bool `json:"preventInitialBackfill,omitempty"`

	// SyncDelay The synch delay to apply to the transform. Default 1m
	SyncDelay *string `json:"syncDelay,omitempty"`
}

// SloDefinitionResponse defines model for slo_definition_response.
type SloDefinitionResponse struct {
	// BudgetingMethod The budgeting method to use when computing the rollup data.
	BudgetingMethod BudgetingMethod `json:"budgetingMethod"`

	// CreatedAt The creation date
	CreatedAt string `json:"createdAt"`

	// Description The description of the SLO.
	Description string `json:"description"`

	// Enabled Indicate if the SLO is enabled
	Enabled bool `json:"enabled"`

	// GroupBy optional group by field to use to generate an SLO per distinct value
	GroupBy string `json:"groupBy"`

	// Id The identifier of the SLO.
	Id        string                          `json:"id"`
	Indicator SloDefinitionResponse_Indicator `json:"indicator"`

	// Name The name of the SLO.
	Name string `json:"name"`

	// Objective Defines properties for the SLO objective
	Objective Objective `json:"objective"`

	// Revision The SLO revision
	Revision float32 `json:"revision"`

	// Settings Defines properties for SLO settings.
	Settings Settings `json:"settings"`

	// Tags List of tags
	Tags []string `json:"tags"`

	// TimeWindow Defines properties for the SLO time window
	TimeWindow TimeWindow `json:"timeWindow"`

	// UpdatedAt The last update date
	UpdatedAt string `json:"updatedAt"`

	// Version The internal SLO version
	Version float32 `json:"version"`
}

// SloDefinitionResponse_Indicator defines model for SloDefinitionResponse.Indicator.
type SloDefinitionResponse_Indicator struct {
	union json.RawMessage
}

// SloWithSummaryResponse defines model for slo_with_summary_response.
type SloWithSummaryResponse struct {
	// BudgetingMethod The budgeting method to use when computing the rollup data.
	BudgetingMethod BudgetingMethod `json:"budgetingMethod"`

	// CreatedAt The creation date
	CreatedAt string `json:"createdAt"`

	// Description The description of the SLO.
	Description string `json:"description"`

	// Enabled Indicate if the SLO is enabled
	Enabled bool `json:"enabled"`

	// GroupBy optional group by field to use to generate an SLO per distinct value
	GroupBy string `json:"groupBy"`

	// Id The identifier of the SLO.
	Id        string                           `json:"id"`
	Indicator SloWithSummaryResponse_Indicator `json:"indicator"`

	// InstanceId the value derived from the groupBy field, if present, otherwise '*'
	InstanceId string `json:"instanceId"`

	// Name The name of the SLO.
	Name string `json:"name"`

	// Objective Defines properties for the SLO objective
	Objective Objective `json:"objective"`

	// Revision The SLO revision
	Revision float32 `json:"revision"`

	// Settings Defines properties for SLO settings.
	Settings Settings `json:"settings"`

	// Summary The SLO computed data
	Summary Summary `json:"summary"`

	// Tags List of tags
	Tags []string `json:"tags"`

	// TimeWindow Defines properties for the SLO time window
	TimeWindow TimeWindow `json:"timeWindow"`

	// UpdatedAt The last update date
	UpdatedAt string `json:"updatedAt"`

	// Version The internal SLO version
	Version float32 `json:"version"`
}

// SloWithSummaryResponse_Indicator defines model for SloWithSummaryResponse.Indicator.
type SloWithSummaryResponse_Indicator struct {
	union json.RawMessage
}

// Sourcefilters The array of field names you want to filter out in Discover.
type Sourcefilters = []SourcefiltersItem

// SourcefiltersItem defines model for sourcefilters_item.
type SourcefiltersItem struct {
	Value string `json:"value"`
}

// Summary The SLO computed data
type Summary struct {
	ErrorBudget ErrorBudget   `json:"errorBudget"`
	SliValue    float32       `json:"sliValue"`
	Status      SummaryStatus `json:"status"`
}

// SummaryStatus defines model for summary_status.
type SummaryStatus = string

// TimeWindow Defines properties for the SLO time window
type TimeWindow struct {
	// Duration the duration formatted as {duration}{unit}. Accepted values for rolling: 7d, 30d, 90d. Accepted values for calendar aligned: 1w (weekly) or 1M (monthly)
	Duration string `json:"duration"`

	// Type Indicates weither the time window is a rolling or a calendar aligned time window.
	Type string `json:"type"`
}

// Timefieldname The timestamp field name, which you use for time-based data views.
type Timefieldname = string

// TimesliceMetricBasicMetricWithField defines model for timeslice_metric_basic_metric_with_field.
type TimesliceMetricBasicMetricWithField struct {
	// Aggregation The aggregation type of the metric.
	Aggregation string `json:"aggregation"`

	// Field The field of the metric.
	Field string `json:"field"`

	// Filter The filter to apply to the metric.
	Filter *string `json:"filter,omitempty"`

	// Name The name of the metric. Only valid options are A-Z
	Name string `json:"name"`
}

// TimesliceMetricDocCountMetric defines model for timeslice_metric_doc_count_metric.
type TimesliceMetricDocCountMetric struct {
	// Aggregation The aggregation type of the metric. Only valid option is "doc_count"
	Aggregation string `json:"aggregation"`

	// Filter The filter to apply to the metric.
	Filter *string `json:"filter,omitempty"`

	// Name The name of the metric. Only valid options are A-Z
	Name string `json:"name"`
}

// TimesliceMetricPercentileMetric defines model for timeslice_metric_percentile_metric.
type TimesliceMetricPercentileMetric struct {
	// Aggregation The aggregation type of the metric. Only valid option is "percentile"
	Aggregation string `json:"aggregation"`

	// Field The field of the metric.
	Field string `json:"field"`

	// Filter The filter to apply to the metric.
	Filter *string `json:"filter,omitempty"`

	// Name The name of the metric. Only valid options are A-Z
	Name string `json:"name"`

	// Percentile The percentile value.
	Percentile float32 `json:"percentile"`
}

// Title Comma-separated list of data streams, indices, and aliases that you want to search. Supports wildcards (`*`).
type Title = string

// Type When set to `rollup`, identifies the rollup data views.
type Type = string

// Typemeta When you use rollup indices, contains the field list for the rollup data view API endpoints.
type Typemeta struct {
	// Aggs A map of rollup restrictions by aggregation type and field name.
	Aggs map[string]interface{} `json:"aggs"`

	// Params Properties for retrieving rollup fields.
	Params map[string]interface{} `json:"params"`
}

// TypemetaResponse When you use rollup indices, contains the field list for the rollup data view API endpoints.
type TypemetaResponse struct {
	// Aggs A map of rollup restrictions by aggregation type and field name.
	Aggs map[string]interface{} `json:"aggs,omitempty"`

	// Params Properties for retrieving rollup fields.
	Params map[string]interface{} `json:"params,omitempty"`
}

// UpdateAgentPolicyResponseObject defines model for update-agent-policy_response_object.
type UpdateAgentPolicyResponseObject struct {
	Item AgentPolicy `json:"item"`
}

// UpdateFleetServerHostsRequest defines model for update-fleet-server-hosts_request.
type UpdateFleetServerHostsRequest struct {
	HostUrls   []string `json:"host_urls,omitempty"`
	IsDefault  *bool    `json:"is_default,omitempty"`
	IsInternal *bool    `json:"is_internal,omitempty"`
	Name       *string  `json:"name,omitempty"`

	// ProxyId The ID of the proxy to use for this fleet server host. See the proxies API for more information.
	ProxyId *string `json:"proxy_id"`
}

// UpdateFleetServerHostsResponseObject defines model for update-fleet-server-hosts_response_object.
type UpdateFleetServerHostsResponseObject struct {
	Item FleetServerHost `json:"item"`
}

// UpdateOutputResponseObject defines model for update-output_response_object.
type UpdateOutputResponseObject struct {
	Item *OutputUpdateRequest `json:"item,omitempty"`
}

// UpdatePackagePolicyResponseObject defines model for update-package-policy_response_object.
type UpdatePackagePolicyResponseObject struct {
	Item   PackagePolicy `json:"item"`
	Sucess bool          `json:"sucess"`
}

// UpdatePackageRequest defines model for update-package_request.
type UpdatePackageRequest struct {
	KeepPoliciesUpToDate *bool `json:"keepPoliciesUpToDate,omitempty"`
}

// UpdatePackageResponseObject defines model for update-package_response_object.
type UpdatePackageResponseObject struct {
	Items []UpdatePackageResponseObjectItemItem `json:"items"`
}

// UpdatePackageResponseObjectItemItem defines model for update-package_response_object_item_item.
type UpdatePackageResponseObjectItemItem struct {
	Id   string                                   `json:"id"`
	Type UpdatePackageResponseObjectItemItem_Type `json:"type"`
}

// UpdatePackageResponseObjectItemItem_Type defines model for UpdatePackageResponseObjectItemItem.Type.
type UpdatePackageResponseObjectItemItem_Type struct {
	union json.RawMessage
}

// UpdateConnectorRequest defines model for update_connector_request.
type UpdateConnectorRequest struct {
	Config map[string]interface{} `json:"config,omitempty"`

	// Name The display name for the connector.
	Name    string                 `json:"name"`
	Secrets map[string]interface{} `json:"secrets,omitempty"`
}

// UpdateConnectorResponseObject defines model for update_connector_response_object.
type UpdateConnectorResponseObject struct {
	Config map[string]interface{} `json:"config,omitempty"`

	// ConnectorTypeId The connector type identifier.
	ConnectorTypeId string `json:"connector_type_id"`

	// Id The identifier for the connector.
	Id string `json:"id"`

	// IsDeprecated Indicates whether the connector is deprecated.
	IsDeprecated bool `json:"is_deprecated"`

	// IsMissingSecrets Indicates whether the connector is missing secrets.
	IsMissingSecrets *bool `json:"is_missing_secrets,omitempty"`

	// IsPreconfigured Indicates whether the connector is preconfigured. If true, the `config` and `is_missing_secrets` properties are omitted from the response.
	IsPreconfigured bool `json:"is_preconfigured"`

	// IsSystemAction Indicates whether the connector is used for system actions.
	IsSystemAction bool `json:"is_system_action"`

	// Name  The name of the rule.
	Name string `json:"name"`
}

// UpdateDataViewRequestObject defines model for update_data_view_request_object.
type UpdateDataViewRequestObject struct {
	// DataView The data view properties you want to update. Only the specified properties are updated in the data view. Unspecified fields stay as they are persisted.
	DataView UpdateDataViewRequestObjectDataView `json:"data_view"`

	// RefreshFields Reloads the data view fields after the data view is updated.
	RefreshFields *bool `json:"refresh_fields,omitempty"`
}

// UpdateDataViewRequestObjectDataView The data view properties you want to update. Only the specified properties are updated in the data view. Unspecified fields stay as they are persisted.
type UpdateDataViewRequestObjectDataView struct {
	// AllowNoIndex Allows the data view saved object to exist before the data is available.
	AllowNoIndex *Allownoindex `json:"allowNoIndex,omitempty"`

	// FieldFormats A map of field formats by field name.
	FieldFormats    Fieldformats               `json:"fieldFormats,omitempty"`
	Fields          map[string]interface{}     `json:"fields,omitempty"`
	Name            *string                    `json:"name,omitempty"`
	RuntimeFieldMap map[string]Runtimefieldmap `json:"runtimeFieldMap,omitempty"`

	// SourceFilters The array of field names you want to filter out in Discover.
	SourceFilters Sourcefilters `json:"sourceFilters,omitempty"`

	// TimeFieldName The timestamp field name, which you use for time-based data views.
	TimeFieldName *Timefieldname `json:"timeFieldName,omitempty"`

	// Title Comma-separated list of data streams, indices, and aliases that you want to search. Supports wildcards (`*`).
	Title *Title `json:"title,omitempty"`

	// Type When set to `rollup`, identifies the rollup data views.
	Type *Type `json:"type,omitempty"`

	// TypeMeta When you use rollup indices, contains the field list for the rollup data view API endpoints.
	TypeMeta *Typemeta `json:"typeMeta,omitempty"`
}

// UpdateRuleRequest defines model for update_rule_request.
type UpdateRuleRequest struct {
	Actions []UpdateRuleRequestActionsItem `json:"actions,omitempty"`

	// AlertDelay Indicates that an alert occurs only when the specified number of consecutive runs met the rule conditions.
	AlertDelay *UpdateRuleRequestAlertDelay `json:"alert_delay,omitempty"`

	// Name The name of the rule. While this name does not have to be unique, a distinctive name can help you identify a rule.
	Name string `json:"name"`

	// NotifyWhen Indicates how often alerts generate actions. Valid values include: `onActionGroupChange`: Actions run when the alert status changes; `onActiveAlert`: Actions run when the alert becomes active and at each check interval while the rule conditions are met; `onThrottleInterval`: Actions run when the alert becomes active and at the interval specified in the throttle property while the rule conditions are met. NOTE: You cannot specify `notify_when` at both the rule and action level. The recommended method is to set it for each action. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	NotifyWhen *string `json:"notify_when"`

	// Params The parameters for the rule.
	Params   map[string]interface{}    `json:"params,omitempty"`
	Schedule UpdateRuleRequestSchedule `json:"schedule"`
	Tags     []string                  `json:"tags,omitempty"`

	// Throttle Use the `throttle` property in the action `frequency` object instead. The throttle interval, which defines how often an alert generates repeated actions. NOTE: You cannot specify the throttle interval at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	Throttle *string `json:"throttle"`
}

// UpdateRuleRequestActionsItem An action that runs under defined conditions.
type UpdateRuleRequestActionsItem struct {
	AlertsFilter *UpdateRuleRequestActionsItemAlertsFilter `json:"alerts_filter,omitempty"`
	Frequency    *UpdateRuleRequestActionsItemFrequency    `json:"frequency,omitempty"`

	// Group The group name, which affects when the action runs (for example, when the threshold is met or when the alert is recovered). Each rule type has a list of valid action group names. If you don't need to group actions, set to `default`.
	Group *string `json:"group,omitempty"`

	// Id The identifier for the connector saved object.
	Id string `json:"id"`

	// Params The parameters for the action, which are sent to the connector. The `params` are handled as Mustache templates and passed a default set of context.
	Params map[string]interface{} `json:"params,omitempty"`

	// UseAlertDataForTemplate Indicates whether to use alert data as a template.
	UseAlertDataForTemplate *bool `json:"use_alert_data_for_template,omitempty"`

	// Uuid A universally unique identifier (UUID) for the action.
	Uuid *string `json:"uuid,omitempty"`
}

// UpdateRuleRequestActionsItemAlertsFilter defines model for update_rule_request_actions_item_alerts_filter.
type UpdateRuleRequestActionsItemAlertsFilter struct {
	Query *UpdateRuleRequestActionsItemAlertsFilterQuery `json:"query,omitempty"`

	// Timeframe Defines a period that limits whether the action runs.
	Timeframe *UpdateRuleRequestActionsItemAlertsFilterTimeframe `json:"timeframe,omitempty"`
}

// UpdateRuleRequestActionsItemAlertsFilterQuery defines model for update_rule_request_actions_item_alerts_filter_query.
type UpdateRuleRequestActionsItemAlertsFilterQuery struct {
	// Dsl A filter written in Elasticsearch Query Domain Specific Language (DSL).
	Dsl *string `json:"dsl,omitempty"`

	// Filters A filter written in Elasticsearch Query Domain Specific Language (DSL) as defined in the `kbn-es-query` package.
	Filters []UpdateRuleRequestActionsItemAlertsFilterQueryFiltersItem `json:"filters"`

	// Kql A filter written in Kibana Query Language (KQL).
	Kql string `json:"kql"`
}

// UpdateRuleRequestActionsItemAlertsFilterQueryFiltersItem defines model for update_rule_request_actions_item_alerts_filter_query_filters_item.
type UpdateRuleRequestActionsItemAlertsFilterQueryFiltersItem struct {
	State *UpdateRuleRequestActionsItemAlertsFilterQueryFiltersItemState `json:"$state,omitempty"`
	Meta  map[string]interface{}                                         `json:"meta"`
	Query map[string]interface{}                                         `json:"query,omitempty"`
}

// UpdateRuleRequestActionsItemAlertsFilterQueryFiltersItemState defines model for update_rule_request_actions_item_alerts_filter_query_filters_item_$state.
type UpdateRuleRequestActionsItemAlertsFilterQueryFiltersItemState struct {
	// Store A filter can be either specific to an application context or applied globally.
	Store string `json:"store"`
}

// UpdateRuleRequestActionsItemAlertsFilterTimeframe Defines a period that limits whether the action runs.
type UpdateRuleRequestActionsItemAlertsFilterTimeframe struct {
	// Days Defines the days of the week that the action can run, represented as an array of numbers. For example, `1` represents Monday. An empty array is equivalent to specifying all the days of the week.
	Days []int `json:"days"`

	// Hours Defines the range of time in a day that the action can run. If the `start` value is `00:00` and the `end` value is `24:00`, actions be generated all day.
	Hours UpdateRuleRequestActionsItemAlertsFilterTimeframeHours `json:"hours"`

	// Timezone The ISO time zone for the `hours` values. Values such as `UTC` and `UTC+1` also work but lack built-in daylight savings time support and are not recommended.
	Timezone string `json:"timezone"`
}

// UpdateRuleRequestActionsItemAlertsFilterTimeframeHours Defines the range of time in a day that the action can run. If the `start` value is `00:00` and the `end` value is `24:00`, actions be generated all day.
type UpdateRuleRequestActionsItemAlertsFilterTimeframeHours struct {
	// End The end of the time frame in 24-hour notation (`hh:mm`).
	End string `json:"end"`

	// Start The start of the time frame in 24-hour notation (`hh:mm`).
	Start string `json:"start"`
}

// UpdateRuleRequestActionsItemFrequency defines model for update_rule_request_actions_item_frequency.
type UpdateRuleRequestActionsItemFrequency struct {
	// NotifyWhen Indicates how often alerts generate actions. Valid values include: `onActionGroupChange`: Actions run when the alert status changes; `onActiveAlert`: Actions run when the alert becomes active and at each check interval while the rule conditions are met; `onThrottleInterval`: Actions run when the alert becomes active and at the interval specified in the throttle property while the rule conditions are met. NOTE: You cannot specify `notify_when` at both the rule and action level. The recommended method is to set it for each action. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	NotifyWhen string `json:"notify_when"`

	// Summary Indicates whether the action is a summary.
	Summary bool `json:"summary"`

	// Throttle The throttle interval, which defines how often an alert generates repeated actions. It is specified in seconds, minutes, hours, or days and is applicable only if `notify_when` is set to `onThrottleInterval`. NOTE: You cannot specify the throttle interval at both the rule and action level. The recommended method is to set it for each action. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	Throttle *string `json:"throttle"`
}

// UpdateRuleRequestAlertDelay Indicates that an alert occurs only when the specified number of consecutive runs met the rule conditions.
type UpdateRuleRequestAlertDelay struct {
	// Active The number of consecutive runs that must meet the rule conditions.
	Active float32 `json:"active"`
}

// UpdateRuleRequestSchedule defines model for update_rule_request_schedule.
type UpdateRuleRequestSchedule struct {
	// Interval The interval is specified in seconds, minutes, hours, or days.
	Interval string `json:"interval"`
}

// UpdateRuleResponseObject defines model for update_rule_response_object.
type UpdateRuleResponseObject struct {
	Actions       []UpdateRuleResponseObjectActionsItem `json:"actions"`
	ActiveSnoozes []string                              `json:"active_snoozes,omitempty"`

	// AlertDelay Indicates that an alert occurs only when the specified number of consecutive runs met the rule conditions.
	AlertDelay *UpdateRuleResponseObjectAlertDelay `json:"alert_delay,omitempty"`

	// ApiKeyCreatedByUser Indicates whether the API key that is associated with the rule was created by the user.
	ApiKeyCreatedByUser *bool `json:"api_key_created_by_user"`

	// ApiKeyOwner The owner of the API key that is associated with the rule and used to run background tasks.
	ApiKeyOwner *string `json:"api_key_owner"`

	// Consumer The name of the application or feature that owns the rule. For example: `alerts`, `apm`, `discover`, `infrastructure`, `logs`, `metrics`, `ml`, `monitoring`, `securitySolution`, `siem`, `stackAlerts`, or `uptime`.
	Consumer string `json:"consumer"`

	// CreatedAt The date and time that the rule was created.
	CreatedAt string `json:"created_at"`

	// CreatedBy The identifier for the user that created the rule.
	CreatedBy *string `json:"created_by"`

	// Enabled Indicates whether you want to run the rule on an interval basis after it is created.
	Enabled         bool                                    `json:"enabled"`
	ExecutionStatus UpdateRuleResponseObjectExecutionStatus `json:"execution_status"`

	// Id The identifier for the rule.
	Id string `json:"id"`

	// IsSnoozedUntil The date when the rule will no longer be snoozed.
	IsSnoozedUntil *string                          `json:"is_snoozed_until"`
	LastRun        *UpdateRuleResponseObjectLastRun `json:"last_run"`
	MappedParams   map[string]interface{}           `json:"mapped_params,omitempty"`

	// Monitoring Monitoring details of the rule.
	Monitoring *UpdateRuleResponseObjectMonitoring `json:"monitoring,omitempty"`

	// MuteAll Indicates whether all alerts are muted.
	MuteAll       bool     `json:"mute_all"`
	MutedAlertIds []string `json:"muted_alert_ids"`

	// Name  The name of the rule.
	Name string `json:"name"`

	// NextRun Date and time of the next run of the rule.
	NextRun *string `json:"next_run"`

	// NotifyWhen Indicates how often alerts generate actions. Valid values include: `onActionGroupChange`: Actions run when the alert status changes; `onActiveAlert`: Actions run when the alert becomes active and at each check interval while the rule conditions are met; `onThrottleInterval`: Actions run when the alert becomes active and at the interval specified in the throttle property while the rule conditions are met. NOTE: You cannot specify `notify_when` at both the rule and action level. The recommended method is to set it for each action. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	NotifyWhen *string `json:"notify_when"`

	// Params The parameters for the rule.
	Params map[string]interface{} `json:"params"`

	// Revision The rule revision number.
	Revision float32 `json:"revision"`

	// RuleTypeId The rule type identifier.
	RuleTypeId string `json:"rule_type_id"`

	// Running Indicates whether the rule is running.
	Running  *bool                            `json:"running"`
	Schedule UpdateRuleResponseObjectSchedule `json:"schedule"`

	// ScheduledTaskId Identifier of the scheduled task.
	ScheduledTaskId *string                                      `json:"scheduled_task_id,omitempty"`
	SnoozeSchedule  []UpdateRuleResponseObjectSnoozeScheduleItem `json:"snooze_schedule,omitempty"`
	Tags            []string                                     `json:"tags"`

	// Throttle Deprecated in 8.13.0. Use the `throttle` property in the action `frequency` object instead. The throttle interval, which defines how often an alert generates repeated actions. NOTE: You cannot specify the throttle interval at both the rule and action level. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	// Deprecated:
	Throttle *string `json:"throttle"`

	// UpdatedAt The date and time that the rule was updated most recently.
	UpdatedAt string `json:"updated_at"`

	// UpdatedBy The identifier for the user that updated this rule most recently.
	UpdatedBy *string `json:"updated_by"`

	// ViewInAppRelativeUrl Relative URL to view rule in the app.
	ViewInAppRelativeUrl *string `json:"view_in_app_relative_url"`
}

// UpdateRuleResponseObjectActionsItem defines model for update_rule_response_object_actions_item.
type UpdateRuleResponseObjectActionsItem struct {
	// AlertsFilter Defines a period that limits whether the action runs.
	AlertsFilter *UpdateRuleResponseObjectActionsItemAlertsFilter `json:"alerts_filter,omitempty"`

	// ConnectorTypeId The type of connector. This property appears in responses but cannot be set in requests.
	ConnectorTypeId string                                        `json:"connector_type_id"`
	Frequency       *UpdateRuleResponseObjectActionsItemFrequency `json:"frequency,omitempty"`

	// Group The group name, which affects when the action runs (for example, when the threshold is met or when the alert is recovered). Each rule type has a list of valid action group names. If you don't need to group actions, set to `default`.
	Group *string `json:"group,omitempty"`

	// Id The identifier for the connector saved object.
	Id string `json:"id"`

	// Params The parameters for the action, which are sent to the connector. The `params` are handled as Mustache templates and passed a default set of context.
	Params map[string]interface{} `json:"params"`

	// UseAlertDataForTemplate Indicates whether to use alert data as a template.
	UseAlertDataForTemplate *bool `json:"use_alert_data_for_template,omitempty"`

	// Uuid A universally unique identifier (UUID) for the action.
	Uuid *string `json:"uuid,omitempty"`
}

// UpdateRuleResponseObjectActionsItemAlertsFilter Defines a period that limits whether the action runs.
type UpdateRuleResponseObjectActionsItemAlertsFilter struct {
	Query     *UpdateRuleResponseObjectActionsItemAlertsFilterQuery     `json:"query,omitempty"`
	Timeframe *UpdateRuleResponseObjectActionsItemAlertsFilterTimeframe `json:"timeframe,omitempty"`
}

// UpdateRuleResponseObjectActionsItemAlertsFilterQuery defines model for update_rule_response_object_actions_item_alerts_filter_query.
type UpdateRuleResponseObjectActionsItemAlertsFilterQuery struct {
	// Dsl A filter written in Elasticsearch Query Domain Specific Language (DSL).
	Dsl *string `json:"dsl,omitempty"`

	// Filters A filter written in Elasticsearch Query Domain Specific Language (DSL) as defined in the `kbn-es-query` package.
	Filters []UpdateRuleResponseObjectActionsItemAlertsFilterQueryFiltersItem `json:"filters"`

	// Kql A filter written in Kibana Query Language (KQL).
	Kql string `json:"kql"`
}

// UpdateRuleResponseObjectActionsItemAlertsFilterQueryFiltersItem defines model for update_rule_response_object_actions_item_alerts_filter_query_filters_item.
type UpdateRuleResponseObjectActionsItemAlertsFilterQueryFiltersItem struct {
	State *UpdateRuleResponseObjectActionsItemAlertsFilterQueryFiltersItemState `json:"$state,omitempty"`
	Meta  map[string]interface{}                                                `json:"meta"`
	Query map[string]interface{}                                                `json:"query,omitempty"`
}

// UpdateRuleResponseObjectActionsItemAlertsFilterQueryFiltersItemState defines model for update_rule_response_object_actions_item_alerts_filter_query_filters_item_$state.
type UpdateRuleResponseObjectActionsItemAlertsFilterQueryFiltersItemState struct {
	// Store A filter can be either specific to an application context or applied globally.
	Store string `json:"store"`
}

// UpdateRuleResponseObjectActionsItemAlertsFilterTimeframe defines model for update_rule_response_object_actions_item_alerts_filter_timeframe.
type UpdateRuleResponseObjectActionsItemAlertsFilterTimeframe struct {
	// Days Defines the days of the week that the action can run, represented as an array of numbers. For example, `1` represents Monday. An empty array is equivalent to specifying all the days of the week.
	Days  []int                                                         `json:"days"`
	Hours UpdateRuleResponseObjectActionsItemAlertsFilterTimeframeHours `json:"hours"`

	// Timezone The ISO time zone for the `hours` values. Values such as `UTC` and `UTC+1` also work but lack built-in daylight savings time support and are not recommended.
	Timezone string `json:"timezone"`
}

// UpdateRuleResponseObjectActionsItemAlertsFilterTimeframeHours defines model for update_rule_response_object_actions_item_alerts_filter_timeframe_hours.
type UpdateRuleResponseObjectActionsItemAlertsFilterTimeframeHours struct {
	// End The end of the time frame in 24-hour notation (`hh:mm`).
	End string `json:"end"`

	// Start The start of the time frame in 24-hour notation (`hh:mm`).
	Start string `json:"start"`
}

// UpdateRuleResponseObjectActionsItemFrequency defines model for update_rule_response_object_actions_item_frequency.
type UpdateRuleResponseObjectActionsItemFrequency struct {
	// NotifyWhen Indicates how often alerts generate actions. Valid values include: `onActionGroupChange`: Actions run when the alert status changes; `onActiveAlert`: Actions run when the alert becomes active and at each check interval while the rule conditions are met; `onThrottleInterval`: Actions run when the alert becomes active and at the interval specified in the throttle property while the rule conditions are met. NOTE: You cannot specify `notify_when` at both the rule and action level. The recommended method is to set it for each action. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	NotifyWhen string `json:"notify_when"`

	// Summary Indicates whether the action is a summary.
	Summary bool `json:"summary"`

	// Throttle The throttle interval, which defines how often an alert generates repeated actions. It is specified in seconds, minutes, hours, or days and is applicable only if 'notify_when' is set to 'onThrottleInterval'. NOTE: You cannot specify the throttle interval at both the rule and action level. The recommended method is to set it for each action. If you set it at the rule level then update the rule in Kibana, it is automatically changed to use action-specific values.
	Throttle *string `json:"throttle"`
}

// UpdateRuleResponseObjectAlertDelay Indicates that an alert occurs only when the specified number of consecutive runs met the rule conditions.
type UpdateRuleResponseObjectAlertDelay struct {
	// Active The number of consecutive runs that must meet the rule conditions.
	Active float32 `json:"active"`
}

// UpdateRuleResponseObjectExecutionStatus defines model for update_rule_response_object_execution_status.
type UpdateRuleResponseObjectExecutionStatus struct {
	Error *UpdateRuleResponseObjectExecutionStatusError `json:"error,omitempty"`

	// LastDuration Duration of last execution of the rule.
	LastDuration *float32 `json:"last_duration,omitempty"`

	// LastExecutionDate The date and time when rule was executed last.
	LastExecutionDate string `json:"last_execution_date"`

	// Status Status of rule execution.
	Status  string                                          `json:"status"`
	Warning *UpdateRuleResponseObjectExecutionStatusWarning `json:"warning,omitempty"`
}

// UpdateRuleResponseObjectExecutionStatusError defines model for update_rule_response_object_execution_status_error.
type UpdateRuleResponseObjectExecutionStatusError struct {
	// Message Error message.
	Message string `json:"message"`

	// Reason Reason for error.
	Reason string `json:"reason"`
}

// UpdateRuleResponseObjectExecutionStatusWarning defines model for update_rule_response_object_execution_status_warning.
type UpdateRuleResponseObjectExecutionStatusWarning struct {
	// Message Warning message.
	Message string `json:"message"`

	// Reason Reason for warning.
	Reason string `json:"reason"`
}

// UpdateRuleResponseObjectLastRun defines model for update_rule_response_object_last_run.
type UpdateRuleResponseObjectLastRun struct {
	AlertsCount UpdateRuleResponseObjectLastRunAlertsCount `json:"alerts_count"`

	// Outcome Outcome of last run of the rule. Value could be succeeded, warning or failed.
	Outcome    string   `json:"outcome"`
	OutcomeMsg []string `json:"outcome_msg"`

	// OutcomeOrder Order of the outcome.
	OutcomeOrder *float32 `json:"outcome_order,omitempty"`

	// Warning Warning of last rule execution.
	Warning *string `json:"warning"`
}

// UpdateRuleResponseObjectLastRunAlertsCount defines model for update_rule_response_object_last_run_alerts_count.
type UpdateRuleResponseObjectLastRunAlertsCount struct {
	// Active Number of active alerts during last run.
	Active *float32 `json:"active"`

	// Ignored Number of ignored alerts during last run.
	Ignored *float32 `json:"ignored"`

	// New Number of new alerts during last run.
	New *float32 `json:"new"`

	// Recovered Number of recovered alerts during last run.
	Recovered *float32 `json:"recovered"`
}

// UpdateRuleResponseObjectMonitoring Monitoring details of the rule.
type UpdateRuleResponseObjectMonitoring struct {
	// Run Rule run details.
	Run UpdateRuleResponseObjectMonitoringRun `json:"run"`
}

// UpdateRuleResponseObjectMonitoringRun Rule run details.
type UpdateRuleResponseObjectMonitoringRun struct {
	// CalculatedMetrics Calculation of different percentiles and success ratio.
	CalculatedMetrics UpdateRuleResponseObjectMonitoringRunCalculatedMetrics `json:"calculated_metrics"`

	// History History of the rule run.
	History []UpdateRuleResponseObjectMonitoringRunHistoryItem `json:"history"`
	LastRun UpdateRuleResponseObjectMonitoringRunLastRun       `json:"last_run"`
}

// UpdateRuleResponseObjectMonitoringRunCalculatedMetrics Calculation of different percentiles and success ratio.
type UpdateRuleResponseObjectMonitoringRunCalculatedMetrics struct {
	P50          *float32 `json:"p50,omitempty"`
	P95          *float32 `json:"p95,omitempty"`
	P99          *float32 `json:"p99,omitempty"`
	SuccessRatio float32  `json:"success_ratio"`
}

// UpdateRuleResponseObjectMonitoringRunHistoryItem defines model for update_rule_response_object_monitoring_run_history_item.
type UpdateRuleResponseObjectMonitoringRunHistoryItem struct {
	// Duration Duration of the rule run.
	Duration *float32                                                 `json:"duration,omitempty"`
	Outcome  *UpdateRuleResponseObjectMonitoringRunHistoryItemOutcome `json:"outcome,omitempty"`

	// Success Indicates whether the rule run was successful.
	Success bool `json:"success"`

	// Timestamp Time of rule run.
	Timestamp float32 `json:"timestamp"`
}

// UpdateRuleResponseObjectMonitoringRunHistoryItemOutcome defines model for update_rule_response_object_monitoring_run_history_item_outcome.
type UpdateRuleResponseObjectMonitoringRunHistoryItemOutcome struct {
	AlertsCount UpdateRuleResponseObjectMonitoringRunHistoryItemOutcomeAlertsCount `json:"alerts_count"`

	// Outcome Outcome of last run of the rule. Value could be succeeded, warning or failed.
	Outcome    string   `json:"outcome"`
	OutcomeMsg []string `json:"outcome_msg"`

	// OutcomeOrder Order of the outcome.
	OutcomeOrder *float32 `json:"outcome_order,omitempty"`

	// Warning Warning of last rule execution.
	Warning *string `json:"warning"`
}

// UpdateRuleResponseObjectMonitoringRunHistoryItemOutcomeAlertsCount defines model for update_rule_response_object_monitoring_run_history_item_outcome_alerts_count.
type UpdateRuleResponseObjectMonitoringRunHistoryItemOutcomeAlertsCount struct {
	// Active Number of active alerts during last run.
	Active *float32 `json:"active"`

	// Ignored Number of ignored alerts during last run.
	Ignored *float32 `json:"ignored"`

	// New Number of new alerts during last run.
	New *float32 `json:"new"`

	// Recovered Number of recovered alerts during last run.
	Recovered *float32 `json:"recovered"`
}

// UpdateRuleResponseObjectMonitoringRunLastRun defines model for update_rule_response_object_monitoring_run_last_run.
type UpdateRuleResponseObjectMonitoringRunLastRun struct {
	Metrics UpdateRuleResponseObjectMonitoringRunLastRunMetrics `json:"metrics"`

	// Timestamp Time of the most recent rule run.
	Timestamp string `json:"timestamp"`
}

// UpdateRuleResponseObjectMonitoringRunLastRunMetrics defines model for update_rule_response_object_monitoring_run_last_run_metrics.
type UpdateRuleResponseObjectMonitoringRunLastRunMetrics struct {
	// Duration Duration of most recent rule run.
	Duration *float32 `json:"duration,omitempty"`

	// GapDurationS Duration in seconds of rule run gap.
	GapDurationS *float32 `json:"gap_duration_s"`

	// TotalAlertsCreated Total number of alerts created during last rule run.
	TotalAlertsCreated *float32 `json:"total_alerts_created"`

	// TotalAlertsDetected Total number of alerts detected during last rule run.
	TotalAlertsDetected *float32 `json:"total_alerts_detected"`

	// TotalIndexingDurationMs Total time spent indexing documents during last rule run in milliseconds.
	TotalIndexingDurationMs *float32 `json:"total_indexing_duration_ms"`

	// TotalSearchDurationMs Total time spent performing Elasticsearch searches as measured by Kibana; includes network latency and time spent serializing or deserializing the request and response.
	TotalSearchDurationMs *float32 `json:"total_search_duration_ms"`
}

// UpdateRuleResponseObjectSchedule defines model for update_rule_response_object_schedule.
type UpdateRuleResponseObjectSchedule struct {
	// Interval The interval is specified in seconds, minutes, hours, or days.
	Interval string `json:"interval"`
}

// UpdateRuleResponseObjectSnoozeScheduleItem defines model for update_rule_response_object_snooze_schedule_item.
type UpdateRuleResponseObjectSnoozeScheduleItem struct {
	// Duration Duration of the rule snooze schedule.
	Duration float32 `json:"duration"`

	// Id Identifier of the rule snooze schedule.
	Id              *string                                         `json:"id,omitempty"`
	RRule           UpdateRuleResponseObjectSnoozeScheduleItemRRule `json:"rRule"`
	SkipRecurrences []string                                        `json:"skipRecurrences,omitempty"`
}

// UpdateRuleResponseObjectSnoozeScheduleItemRRule defines model for update_rule_response_object_snooze_schedule_item_rRule.
type UpdateRuleResponseObjectSnoozeScheduleItemRRule struct {
	Byhour     []float32                                                        `json:"byhour,omitempty"`
	Byminute   []float32                                                        `json:"byminute,omitempty"`
	Bymonth    []float32                                                        `json:"bymonth,omitempty"`
	Bymonthday []float32                                                        `json:"bymonthday,omitempty"`
	Bysecond   []float32                                                        `json:"bysecond,omitempty"`
	Bysetpos   []float32                                                        `json:"bysetpos,omitempty"`
	Byweekday  []UpdateRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item `json:"byweekday,omitempty"`
	Byweekno   []float32                                                        `json:"byweekno,omitempty"`
	Byyearday  []float32                                                        `json:"byyearday,omitempty"`

	// Count Number of times the rule should recur until it stops.
	Count *float32 `json:"count,omitempty"`

	// Dtstart Rule start date in Coordinated Universal Time (UTC).
	Dtstart string `json:"dtstart"`

	// Freq Indicates frequency of the rule. Options are YEARLY, MONTHLY, WEEKLY, DAILY.
	Freq *int `json:"freq,omitempty"`

	// Interval Indicates the interval of frequency. For example, 1 and YEARLY is every 1 year, 2 and WEEKLY is every 2 weeks.
	Interval *float32 `json:"interval,omitempty"`

	// Tzid Indicates timezone abbreviation.
	Tzid string `json:"tzid"`

	// Until Recur the rule until this date.
	Until *string `json:"until,omitempty"`

	// Wkst Indicates the start of week, defaults to Monday.
	Wkst *string `json:"wkst,omitempty"`
}

// UpdateRuleResponseObjectSnoozeScheduleItemRRuleByweekday0 defines model for .
type UpdateRuleResponseObjectSnoozeScheduleItemRRuleByweekday0 = string

// UpdateRuleResponseObjectSnoozeScheduleItemRRuleByweekday1 defines model for .
type UpdateRuleResponseObjectSnoozeScheduleItemRRuleByweekday1 = float32

// UpdateRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item Indicates the days of the week to recur or else nth-day-of-month strings. For example, "+2TU" second Tuesday of month, "-1FR" last Friday of the month, which are internally converted to a `byweekday/bysetpos` combination.
type UpdateRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item struct {
	union json.RawMessage
}

// UpdateSloRequest The update SLO API request body varies depending on the type of indicator, time window and budgeting method. Partial update is handled.
type UpdateSloRequest struct {
	// BudgetingMethod The budgeting method to use when computing the rollup data.
	BudgetingMethod *BudgetingMethod `json:"budgetingMethod,omitempty"`

	// Description A description for the SLO.
	Description *string                     `json:"description,omitempty"`
	Indicator   *UpdateSloRequest_Indicator `json:"indicator,omitempty"`

	// Name A name for the SLO.
	Name *string `json:"name,omitempty"`

	// Objective Defines properties for the SLO objective
	Objective *Objective `json:"objective,omitempty"`

	// Settings Defines properties for SLO settings.
	Settings *Settings `json:"settings,omitempty"`

	// Tags List of tags
	Tags []string `json:"tags,omitempty"`

	// TimeWindow Defines properties for the SLO time window
	TimeWindow *TimeWindow `json:"timeWindow,omitempty"`
}

// UpdateSloRequest_Indicator defines model for UpdateSloRequest.Indicator.
type UpdateSloRequest_Indicator struct {
	union json.RawMessage
}

// Format defines model for format.
type Format = string

// Kuery defines model for kuery.
type Kuery = string

// PageIndex defines model for page_index.
type PageIndex = int

// PageSize defines model for page_size.
type PageSize = int

// SloId defines model for slo_id.
type SloId = string

// SpaceId defines model for space_id.
type SpaceId = string

// ViewId defines model for view_id.
type ViewId = string

// DeleteConnectorDefaultParams defines parameters for DeleteConnectorDefault.
type DeleteConnectorDefaultParams struct {
	// KbnXsrf A required header to protect against CSRF attacks
	KbnXsrf string `json:"kbn-xsrf"`
}

// CreateConnectorDefaultParams defines parameters for CreateConnectorDefault.
type CreateConnectorDefaultParams struct {
	// KbnXsrf A required header to protect against CSRF attacks
	KbnXsrf string `json:"kbn-xsrf"`
}

// UpdateConnectorDefaultParams defines parameters for UpdateConnectorDefault.
type UpdateConnectorDefaultParams struct {
	// KbnXsrf A required header to protect against CSRF attacks
	KbnXsrf string `json:"kbn-xsrf"`
}

// DeleteRuleDefaultParams defines parameters for DeleteRuleDefault.
type DeleteRuleDefaultParams struct {
	// KbnXsrf A required header to protect against CSRF attacks
	KbnXsrf string `json:"kbn-xsrf"`
}

// CreateRuleDefaultParams defines parameters for CreateRuleDefault.
type CreateRuleDefaultParams struct {
	// KbnXsrf A required header to protect against CSRF attacks
	KbnXsrf string `json:"kbn-xsrf"`
}

// UpdateRuleDefaultParams defines parameters for UpdateRuleDefault.
type UpdateRuleDefaultParams struct {
	// KbnXsrf A required header to protect against CSRF attacks
	KbnXsrf string `json:"kbn-xsrf"`
}

// FindRuleDefaultParams defines parameters for FindRuleDefault.
type FindRuleDefaultParams struct {
	// PerPage The number of rules to return per page.
	PerPage *float32 `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page The page number to return.
	Page *float32 `form:"page,omitempty" json:"page,omitempty"`

	// Search An Elasticsearch simple_query_string query that filters the objects in the response.
	Search *string `form:"search,omitempty" json:"search,omitempty"`

	// DefaultSearchOperator The default operator to use for the simple_query_string.
	DefaultSearchOperator *string `form:"default_search_operator,omitempty" json:"default_search_operator,omitempty"`

	// SearchFields The fields to perform the simple_query_string parsed query against.
	SearchFields *struct {
		union json.RawMessage
	} `form:"search_fields,omitempty" json:"search_fields,omitempty"`

	// SortField Determines which field is used to sort the results. The field must exist in the `attributes` key of the response.
	SortField *string `form:"sort_field,omitempty" json:"sort_field,omitempty"`

	// SortOrder Determines the sort order.
	SortOrder *string `form:"sort_order,omitempty" json:"sort_order,omitempty"`

	// HasReference Filters the rules that have a relation with the reference objects with a specific type and identifier.
	HasReference *struct {
		Id   string `json:"id"`
		Type string `json:"type"`
	} `form:"has_reference,omitempty" json:"has_reference,omitempty"`
	Fields []string `form:"fields" json:"fields"`

	// Filter A KQL string that you filter with an attribute from your saved object. It should look like `savedObjectType.attributes.title: "myTitle"`. However, if you used a direct attribute of a saved object, such as `updatedAt`, you must define your filter, for example, `savedObjectType.updatedAt > 2018-12-22`.
	Filter          *string  `form:"filter,omitempty" json:"filter,omitempty"`
	FilterConsumers []string `form:"filter_consumers" json:"filter_consumers"`
}

// FindRuleDefaultParamsSearchFields0 defines parameters for FindRuleDefault.
type FindRuleDefaultParamsSearchFields0 = []string

// FindRuleDefaultParamsSearchFields1 defines parameters for FindRuleDefault.
type FindRuleDefaultParamsSearchFields1 = string

// AgentPolicyListParams defines parameters for AgentPolicyList.
type AgentPolicyListParams struct {
	// PerPage The number of items to return
	PerPage *PageSize  `form:"perPage,omitempty" json:"perPage,omitempty"`
	Page    *PageIndex `form:"page,omitempty" json:"page,omitempty"`
	Kuery   *Kuery     `form:"kuery,omitempty" json:"kuery,omitempty"`

	// Format Simplified or legacy format for package inputs
	Format *Format `form:"format,omitempty" json:"format,omitempty"`

	// Full When set to true, retrieve the related package policies for each agent policy.
	Full *bool `form:"full,omitempty" json:"full,omitempty"`

	// NoAgentCount When set to true, do not count how many agents are in the agent policy, this can improve performance if you are searching over a large number of agent policies. The "agents" property will always be 0 if set to true.
	NoAgentCount *bool `form:"noAgentCount,omitempty" json:"noAgentCount,omitempty"`
}

// AgentPolicyInfoParams defines parameters for AgentPolicyInfo.
type AgentPolicyInfoParams struct {
	// Format Simplified or legacy format for package inputs
	Format *Format `form:"format,omitempty" json:"format,omitempty"`
}

// UpdateAgentPolicyParams defines parameters for UpdateAgentPolicy.
type UpdateAgentPolicyParams struct {
	// Format Simplified or legacy format for package inputs
	Format *Format `form:"format,omitempty" json:"format,omitempty"`
}

// GetEnrollmentApiKeysParams defines parameters for GetEnrollmentApiKeys.
type GetEnrollmentApiKeysParams struct {
	// PerPage The number of items to return
	PerPage *PageSize  `form:"perPage,omitempty" json:"perPage,omitempty"`
	Page    *PageIndex `form:"page,omitempty" json:"page,omitempty"`
	Kuery   *Kuery     `form:"kuery,omitempty" json:"kuery,omitempty"`
}

// ListAllPackagesParams defines parameters for ListAllPackages.
type ListAllPackagesParams struct {
	// ExcludeInstallStatus Whether to exclude the install status of each package. Enabling this option will opt in to caching for the response via `cache-control` headers. If you don't need up-to-date installation info for a package, and are querying for a list of available packages, providing this flag can improve performance substantially.
	ExcludeInstallStatus *bool `form:"excludeInstallStatus,omitempty" json:"excludeInstallStatus,omitempty"`

	// Prerelease Whether to return prerelease versions of packages (e.g. beta, rc, preview)
	Prerelease   *bool   `form:"prerelease,omitempty" json:"prerelease,omitempty"`
	Experimental *bool   `form:"experimental,omitempty" json:"experimental,omitempty"`
	Category     *string `form:"category,omitempty" json:"category,omitempty"`
}

// InstallPackageByUploadParams defines parameters for InstallPackageByUpload.
type InstallPackageByUploadParams struct {
	// IgnoreMappingUpdateErrors avoid erroring out on unexpected mapping update errors
	IgnoreMappingUpdateErrors *bool `form:"ignoreMappingUpdateErrors,omitempty" json:"ignoreMappingUpdateErrors,omitempty"`

	// SkipDataStreamRollover Skip data stream rollover during index template mapping or settings update
	SkipDataStreamRollover *bool `form:"skipDataStreamRollover,omitempty" json:"skipDataStreamRollover,omitempty"`
}

// DeletePackageParams defines parameters for DeletePackage.
type DeletePackageParams struct {
	// Force delete package even if policies used by agents
	Force *bool `form:"force,omitempty" json:"force,omitempty"`

	// IgnoreUnverified Ignore if the package is fails signature verification
	IgnoreUnverified *bool `form:"ignoreUnverified,omitempty" json:"ignoreUnverified,omitempty"`

	// Full Return all fields from the package manifest, not just those supported by the Elastic Package Registry
	Full *bool `form:"full,omitempty" json:"full,omitempty"`

	// Prerelease Whether to return prerelease versions of packages (e.g. beta, rc, preview)
	Prerelease *bool `form:"prerelease,omitempty" json:"prerelease,omitempty"`
}

// GetPackageParams defines parameters for GetPackage.
type GetPackageParams struct {
	// IgnoreUnverified Ignore if the package is fails signature verification
	IgnoreUnverified *bool `form:"ignoreUnverified,omitempty" json:"ignoreUnverified,omitempty"`

	// Full Return all fields from the package manifest, not just those supported by the Elastic Package Registry
	Full *bool `form:"full,omitempty" json:"full,omitempty"`

	// Prerelease Whether to return prerelease versions of packages (e.g. beta, rc, preview)
	Prerelease *bool `form:"prerelease,omitempty" json:"prerelease,omitempty"`
}

// InstallPackageParams defines parameters for InstallPackage.
type InstallPackageParams struct {
	// IgnoreMappingUpdateErrors avoid erroring out on unexpected mapping update errors
	IgnoreMappingUpdateErrors *bool `form:"ignoreMappingUpdateErrors,omitempty" json:"ignoreMappingUpdateErrors,omitempty"`

	// SkipDataStreamRollover Skip data stream rollover during index template mapping or settings update
	SkipDataStreamRollover *bool `form:"skipDataStreamRollover,omitempty" json:"skipDataStreamRollover,omitempty"`

	// IgnoreUnverified Ignore if the package is fails signature verification
	IgnoreUnverified *bool `form:"ignoreUnverified,omitempty" json:"ignoreUnverified,omitempty"`

	// Full Return all fields from the package manifest, not just those supported by the Elastic Package Registry
	Full *bool `form:"full,omitempty" json:"full,omitempty"`

	// Prerelease Whether to return prerelease versions of packages (e.g. beta, rc, preview)
	Prerelease *bool `form:"prerelease,omitempty" json:"prerelease,omitempty"`
}

// UpdatePackageParams defines parameters for UpdatePackage.
type UpdatePackageParams struct {
	// IgnoreUnverified Ignore if the package is fails signature verification
	IgnoreUnverified *bool `form:"ignoreUnverified,omitempty" json:"ignoreUnverified,omitempty"`

	// Full Return all fields from the package manifest, not just those supported by the Elastic Package Registry
	Full *bool `form:"full,omitempty" json:"full,omitempty"`

	// Prerelease Whether to return prerelease versions of packages (e.g. beta, rc, preview)
	Prerelease *bool `form:"prerelease,omitempty" json:"prerelease,omitempty"`
}

// GetPackagePoliciesParams defines parameters for GetPackagePolicies.
type GetPackagePoliciesParams struct {
	// PerPage The number of items to return
	PerPage *PageSize  `form:"perPage,omitempty" json:"perPage,omitempty"`
	Page    *PageIndex `form:"page,omitempty" json:"page,omitempty"`
	Kuery   *Kuery     `form:"kuery,omitempty" json:"kuery,omitempty"`

	// Format Simplified or legacy format for package inputs
	Format *Format `form:"format,omitempty" json:"format,omitempty"`
}

// CreatePackagePolicyParams defines parameters for CreatePackagePolicy.
type CreatePackagePolicyParams struct {
	// Format Simplified or legacy format for package inputs
	Format *Format `form:"format,omitempty" json:"format,omitempty"`
}

// DeletePackagePolicyParams defines parameters for DeletePackagePolicy.
type DeletePackagePolicyParams struct {
	Force *bool `form:"force,omitempty" json:"force,omitempty"`
}

// GetPackagePolicyParams defines parameters for GetPackagePolicy.
type GetPackagePolicyParams struct {
	// Format Simplified or legacy format for package inputs
	Format *Format `form:"format,omitempty" json:"format,omitempty"`
}

// UpdatePackagePolicyParams defines parameters for UpdatePackagePolicy.
type UpdatePackagePolicyParams struct {
	// Format Simplified or legacy format for package inputs
	Format *Format `form:"format,omitempty" json:"format,omitempty"`
}

// ImportSavedObjectsDefaultMultipartBody defines parameters for ImportSavedObjectsDefault.
type ImportSavedObjectsDefaultMultipartBody struct {
	// File A file exported using the export API. NOTE: The `savedObjects.maxImportExportSize` configuration setting limits the number of saved objects which may be included in this file. Similarly, the `savedObjects.maxImportPayloadBytes` setting limits the overall size of the file that can be imported.
	File *interface{} `json:"file,omitempty"`
}

// ImportSavedObjectsDefaultParams defines parameters for ImportSavedObjectsDefault.
type ImportSavedObjectsDefaultParams struct {
	// CreateNewCopies Creates copies of saved objects, regenerates each object ID, and resets the origin. When used, potential conflict errors are avoided. NOTE: This option cannot be used with the `overwrite` and `compatibilityMode` options.
	CreateNewCopies *bool `form:"createNewCopies,omitempty" json:"createNewCopies,omitempty"`

	// Overwrite Overwrites saved objects when they already exist. When used, potential conflict errors are automatically resolved by overwriting the destination object. NOTE: This option cannot be used with the `createNewCopies` option.
	Overwrite *bool `form:"overwrite,omitempty" json:"overwrite,omitempty"`

	// CompatibilityMode Applies various adjustments to the saved objects that are being imported to maintain compatibility between different Kibana versions. Use this option only if you encounter issues with imported saved objects. NOTE: This option cannot be used with the `createNewCopies` option.
	CompatibilityMode *bool `form:"compatibilityMode,omitempty" json:"compatibilityMode,omitempty"`
}

// FindSlosOpParams defines parameters for FindSlosOp.
type FindSlosOpParams struct {
	// KqlQuery A valid kql query to filter the SLO with
	KqlQuery *string `form:"kqlQuery,omitempty" json:"kqlQuery,omitempty"`

	// Page The page to use for pagination, must be greater or equal than 1
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of SLOs returned by page
	PerPage *int `form:"perPage,omitempty" json:"perPage,omitempty"`

	// SortBy Sort by field
	SortBy *string `form:"sortBy,omitempty" json:"sortBy,omitempty"`

	// SortDirection Sort order
	SortDirection *string `form:"sortDirection,omitempty" json:"sortDirection,omitempty"`

	// HideStale Hide stale SLOs from the list as defined by stale SLO threshold in SLO settings
	HideStale *bool `form:"hideStale,omitempty" json:"hideStale,omitempty"`
}

// GetSloOpParams defines parameters for GetSloOp.
type GetSloOpParams struct {
	// InstanceId the specific instanceId used by the summary calculation
	InstanceId *string `form:"instanceId,omitempty" json:"instanceId,omitempty"`
}

// CreateConnectorDefaultJSONRequestBody defines body for CreateConnectorDefault for application/json ContentType.
type CreateConnectorDefaultJSONRequestBody = CreateConnectorRequest

// UpdateConnectorDefaultJSONRequestBody defines body for UpdateConnectorDefault for application/json ContentType.
type UpdateConnectorDefaultJSONRequestBody = UpdateConnectorRequest

// CreateRuleDefaultJSONRequestBody defines body for CreateRuleDefault for application/json ContentType.
type CreateRuleDefaultJSONRequestBody = CreateRuleRequest

// UpdateRuleDefaultJSONRequestBody defines body for UpdateRuleDefault for application/json ContentType.
type UpdateRuleDefaultJSONRequestBody = UpdateRuleRequest

// CreateDataViewDefaultJSONRequestBody defines body for CreateDataViewDefault for application/json ContentType.
type CreateDataViewDefaultJSONRequestBody = CreateDataViewRequestObject

// UpdateDataViewDefaultJSONRequestBody defines body for UpdateDataViewDefault for application/json ContentType.
type UpdateDataViewDefaultJSONRequestBody = UpdateDataViewRequestObject

// CreateAgentPolicyJSONRequestBody defines body for CreateAgentPolicy for application/json ContentType.
type CreateAgentPolicyJSONRequestBody = AgentPolicyCreateRequest

// DeleteAgentPolicyJSONRequestBody defines body for DeleteAgentPolicy for application/json ContentType.
type DeleteAgentPolicyJSONRequestBody = DeleteAgentPolicyRequest

// UpdateAgentPolicyJSONRequestBody defines body for UpdateAgentPolicy for application/json ContentType.
type UpdateAgentPolicyJSONRequestBody = AgentPolicyUpdateRequest

// DeletePackageJSONRequestBody defines body for DeletePackage for application/json ContentType.
type DeletePackageJSONRequestBody = DeletePackageRequest

// InstallPackageJSONRequestBody defines body for InstallPackage for application/json ContentType.
type InstallPackageJSONRequestBody = InstallPackageRequest

// UpdatePackageJSONRequestBody defines body for UpdatePackage for application/json ContentType.
type UpdatePackageJSONRequestBody = UpdatePackageRequest

// PostFleetServerHostsJSONRequestBody defines body for PostFleetServerHosts for application/json ContentType.
type PostFleetServerHostsJSONRequestBody = PostFleetServerHostsRequest

// UpdateFleetServerHostsJSONRequestBody defines body for UpdateFleetServerHosts for application/json ContentType.
type UpdateFleetServerHostsJSONRequestBody = UpdateFleetServerHostsRequest

// PostOutputsJSONRequestBody defines body for PostOutputs for application/json ContentType.
type PostOutputsJSONRequestBody = OutputCreateRequest

// UpdateOutputJSONRequestBody defines body for UpdateOutput for application/json ContentType.
type UpdateOutputJSONRequestBody = OutputUpdateRequest

// CreatePackagePolicyJSONRequestBody defines body for CreatePackagePolicy for application/json ContentType.
type CreatePackagePolicyJSONRequestBody = PackagePolicyRequest

// UpdatePackagePolicyJSONRequestBody defines body for UpdatePackagePolicy for application/json ContentType.
type UpdatePackagePolicyJSONRequestBody = PackagePolicyRequest

// ImportSavedObjectsDefaultMultipartRequestBody defines body for ImportSavedObjectsDefault for multipart/form-data ContentType.
type ImportSavedObjectsDefaultMultipartRequestBody ImportSavedObjectsDefaultMultipartBody

// CreateSloOpJSONRequestBody defines body for CreateSloOp for application/json ContentType.
type CreateSloOpJSONRequestBody = CreateSloRequest

// UpdateSloOpJSONRequestBody defines body for UpdateSloOp for application/json ContentType.
type UpdateSloOpJSONRequestBody = UpdateSloRequest

// AsAgentPolicyGlobalDataTags0 returns the union data inside the AgentPolicy_GlobalDataTags_AdditionalProperties as a AgentPolicyGlobalDataTags0
func (t AgentPolicy_GlobalDataTags_AdditionalProperties) AsAgentPolicyGlobalDataTags0() (AgentPolicyGlobalDataTags0, error) {
	var body AgentPolicyGlobalDataTags0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAgentPolicyGlobalDataTags0 overwrites any union data inside the AgentPolicy_GlobalDataTags_AdditionalProperties as the provided AgentPolicyGlobalDataTags0
func (t *AgentPolicy_GlobalDataTags_AdditionalProperties) FromAgentPolicyGlobalDataTags0(v AgentPolicyGlobalDataTags0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAgentPolicyGlobalDataTags0 performs a merge with any union data inside the AgentPolicy_GlobalDataTags_AdditionalProperties, using the provided AgentPolicyGlobalDataTags0
func (t *AgentPolicy_GlobalDataTags_AdditionalProperties) MergeAgentPolicyGlobalDataTags0(v AgentPolicyGlobalDataTags0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAgentPolicyGlobalDataTags1 returns the union data inside the AgentPolicy_GlobalDataTags_AdditionalProperties as a AgentPolicyGlobalDataTags1
func (t AgentPolicy_GlobalDataTags_AdditionalProperties) AsAgentPolicyGlobalDataTags1() (AgentPolicyGlobalDataTags1, error) {
	var body AgentPolicyGlobalDataTags1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAgentPolicyGlobalDataTags1 overwrites any union data inside the AgentPolicy_GlobalDataTags_AdditionalProperties as the provided AgentPolicyGlobalDataTags1
func (t *AgentPolicy_GlobalDataTags_AdditionalProperties) FromAgentPolicyGlobalDataTags1(v AgentPolicyGlobalDataTags1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAgentPolicyGlobalDataTags1 performs a merge with any union data inside the AgentPolicy_GlobalDataTags_AdditionalProperties, using the provided AgentPolicyGlobalDataTags1
func (t *AgentPolicy_GlobalDataTags_AdditionalProperties) MergeAgentPolicyGlobalDataTags1(v AgentPolicyGlobalDataTags1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t AgentPolicy_GlobalDataTags_AdditionalProperties) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AgentPolicy_GlobalDataTags_AdditionalProperties) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAgentPolicyCreateRequestGlobalDataTags0 returns the union data inside the AgentPolicyCreateRequest_GlobalDataTags_AdditionalProperties as a AgentPolicyCreateRequestGlobalDataTags0
func (t AgentPolicyCreateRequest_GlobalDataTags_AdditionalProperties) AsAgentPolicyCreateRequestGlobalDataTags0() (AgentPolicyCreateRequestGlobalDataTags0, error) {
	var body AgentPolicyCreateRequestGlobalDataTags0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAgentPolicyCreateRequestGlobalDataTags0 overwrites any union data inside the AgentPolicyCreateRequest_GlobalDataTags_AdditionalProperties as the provided AgentPolicyCreateRequestGlobalDataTags0
func (t *AgentPolicyCreateRequest_GlobalDataTags_AdditionalProperties) FromAgentPolicyCreateRequestGlobalDataTags0(v AgentPolicyCreateRequestGlobalDataTags0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAgentPolicyCreateRequestGlobalDataTags0 performs a merge with any union data inside the AgentPolicyCreateRequest_GlobalDataTags_AdditionalProperties, using the provided AgentPolicyCreateRequestGlobalDataTags0
func (t *AgentPolicyCreateRequest_GlobalDataTags_AdditionalProperties) MergeAgentPolicyCreateRequestGlobalDataTags0(v AgentPolicyCreateRequestGlobalDataTags0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAgentPolicyCreateRequestGlobalDataTags1 returns the union data inside the AgentPolicyCreateRequest_GlobalDataTags_AdditionalProperties as a AgentPolicyCreateRequestGlobalDataTags1
func (t AgentPolicyCreateRequest_GlobalDataTags_AdditionalProperties) AsAgentPolicyCreateRequestGlobalDataTags1() (AgentPolicyCreateRequestGlobalDataTags1, error) {
	var body AgentPolicyCreateRequestGlobalDataTags1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAgentPolicyCreateRequestGlobalDataTags1 overwrites any union data inside the AgentPolicyCreateRequest_GlobalDataTags_AdditionalProperties as the provided AgentPolicyCreateRequestGlobalDataTags1
func (t *AgentPolicyCreateRequest_GlobalDataTags_AdditionalProperties) FromAgentPolicyCreateRequestGlobalDataTags1(v AgentPolicyCreateRequestGlobalDataTags1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAgentPolicyCreateRequestGlobalDataTags1 performs a merge with any union data inside the AgentPolicyCreateRequest_GlobalDataTags_AdditionalProperties, using the provided AgentPolicyCreateRequestGlobalDataTags1
func (t *AgentPolicyCreateRequest_GlobalDataTags_AdditionalProperties) MergeAgentPolicyCreateRequestGlobalDataTags1(v AgentPolicyCreateRequestGlobalDataTags1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t AgentPolicyCreateRequest_GlobalDataTags_AdditionalProperties) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AgentPolicyCreateRequest_GlobalDataTags_AdditionalProperties) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCreateRuleResponseObjectSnoozeScheduleItemRRuleByweekday0 returns the union data inside the CreateRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item as a CreateRuleResponseObjectSnoozeScheduleItemRRuleByweekday0
func (t CreateRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item) AsCreateRuleResponseObjectSnoozeScheduleItemRRuleByweekday0() (CreateRuleResponseObjectSnoozeScheduleItemRRuleByweekday0, error) {
	var body CreateRuleResponseObjectSnoozeScheduleItemRRuleByweekday0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateRuleResponseObjectSnoozeScheduleItemRRuleByweekday0 overwrites any union data inside the CreateRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item as the provided CreateRuleResponseObjectSnoozeScheduleItemRRuleByweekday0
func (t *CreateRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item) FromCreateRuleResponseObjectSnoozeScheduleItemRRuleByweekday0(v CreateRuleResponseObjectSnoozeScheduleItemRRuleByweekday0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateRuleResponseObjectSnoozeScheduleItemRRuleByweekday0 performs a merge with any union data inside the CreateRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item, using the provided CreateRuleResponseObjectSnoozeScheduleItemRRuleByweekday0
func (t *CreateRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item) MergeCreateRuleResponseObjectSnoozeScheduleItemRRuleByweekday0(v CreateRuleResponseObjectSnoozeScheduleItemRRuleByweekday0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateRuleResponseObjectSnoozeScheduleItemRRuleByweekday1 returns the union data inside the CreateRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item as a CreateRuleResponseObjectSnoozeScheduleItemRRuleByweekday1
func (t CreateRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item) AsCreateRuleResponseObjectSnoozeScheduleItemRRuleByweekday1() (CreateRuleResponseObjectSnoozeScheduleItemRRuleByweekday1, error) {
	var body CreateRuleResponseObjectSnoozeScheduleItemRRuleByweekday1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateRuleResponseObjectSnoozeScheduleItemRRuleByweekday1 overwrites any union data inside the CreateRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item as the provided CreateRuleResponseObjectSnoozeScheduleItemRRuleByweekday1
func (t *CreateRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item) FromCreateRuleResponseObjectSnoozeScheduleItemRRuleByweekday1(v CreateRuleResponseObjectSnoozeScheduleItemRRuleByweekday1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateRuleResponseObjectSnoozeScheduleItemRRuleByweekday1 performs a merge with any union data inside the CreateRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item, using the provided CreateRuleResponseObjectSnoozeScheduleItemRRuleByweekday1
func (t *CreateRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item) MergeCreateRuleResponseObjectSnoozeScheduleItemRRuleByweekday1(v CreateRuleResponseObjectSnoozeScheduleItemRRuleByweekday1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsIndicatorPropertiesCustomKql returns the union data inside the CreateSloRequest_Indicator as a IndicatorPropertiesCustomKql
func (t CreateSloRequest_Indicator) AsIndicatorPropertiesCustomKql() (IndicatorPropertiesCustomKql, error) {
	var body IndicatorPropertiesCustomKql
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndicatorPropertiesCustomKql overwrites any union data inside the CreateSloRequest_Indicator as the provided IndicatorPropertiesCustomKql
func (t *CreateSloRequest_Indicator) FromIndicatorPropertiesCustomKql(v IndicatorPropertiesCustomKql) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndicatorPropertiesCustomKql performs a merge with any union data inside the CreateSloRequest_Indicator, using the provided IndicatorPropertiesCustomKql
func (t *CreateSloRequest_Indicator) MergeIndicatorPropertiesCustomKql(v IndicatorPropertiesCustomKql) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIndicatorPropertiesApmAvailability returns the union data inside the CreateSloRequest_Indicator as a IndicatorPropertiesApmAvailability
func (t CreateSloRequest_Indicator) AsIndicatorPropertiesApmAvailability() (IndicatorPropertiesApmAvailability, error) {
	var body IndicatorPropertiesApmAvailability
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndicatorPropertiesApmAvailability overwrites any union data inside the CreateSloRequest_Indicator as the provided IndicatorPropertiesApmAvailability
func (t *CreateSloRequest_Indicator) FromIndicatorPropertiesApmAvailability(v IndicatorPropertiesApmAvailability) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndicatorPropertiesApmAvailability performs a merge with any union data inside the CreateSloRequest_Indicator, using the provided IndicatorPropertiesApmAvailability
func (t *CreateSloRequest_Indicator) MergeIndicatorPropertiesApmAvailability(v IndicatorPropertiesApmAvailability) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIndicatorPropertiesApmLatency returns the union data inside the CreateSloRequest_Indicator as a IndicatorPropertiesApmLatency
func (t CreateSloRequest_Indicator) AsIndicatorPropertiesApmLatency() (IndicatorPropertiesApmLatency, error) {
	var body IndicatorPropertiesApmLatency
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndicatorPropertiesApmLatency overwrites any union data inside the CreateSloRequest_Indicator as the provided IndicatorPropertiesApmLatency
func (t *CreateSloRequest_Indicator) FromIndicatorPropertiesApmLatency(v IndicatorPropertiesApmLatency) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndicatorPropertiesApmLatency performs a merge with any union data inside the CreateSloRequest_Indicator, using the provided IndicatorPropertiesApmLatency
func (t *CreateSloRequest_Indicator) MergeIndicatorPropertiesApmLatency(v IndicatorPropertiesApmLatency) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIndicatorPropertiesCustomMetric returns the union data inside the CreateSloRequest_Indicator as a IndicatorPropertiesCustomMetric
func (t CreateSloRequest_Indicator) AsIndicatorPropertiesCustomMetric() (IndicatorPropertiesCustomMetric, error) {
	var body IndicatorPropertiesCustomMetric
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndicatorPropertiesCustomMetric overwrites any union data inside the CreateSloRequest_Indicator as the provided IndicatorPropertiesCustomMetric
func (t *CreateSloRequest_Indicator) FromIndicatorPropertiesCustomMetric(v IndicatorPropertiesCustomMetric) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndicatorPropertiesCustomMetric performs a merge with any union data inside the CreateSloRequest_Indicator, using the provided IndicatorPropertiesCustomMetric
func (t *CreateSloRequest_Indicator) MergeIndicatorPropertiesCustomMetric(v IndicatorPropertiesCustomMetric) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIndicatorPropertiesHistogram returns the union data inside the CreateSloRequest_Indicator as a IndicatorPropertiesHistogram
func (t CreateSloRequest_Indicator) AsIndicatorPropertiesHistogram() (IndicatorPropertiesHistogram, error) {
	var body IndicatorPropertiesHistogram
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndicatorPropertiesHistogram overwrites any union data inside the CreateSloRequest_Indicator as the provided IndicatorPropertiesHistogram
func (t *CreateSloRequest_Indicator) FromIndicatorPropertiesHistogram(v IndicatorPropertiesHistogram) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndicatorPropertiesHistogram performs a merge with any union data inside the CreateSloRequest_Indicator, using the provided IndicatorPropertiesHistogram
func (t *CreateSloRequest_Indicator) MergeIndicatorPropertiesHistogram(v IndicatorPropertiesHistogram) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIndicatorPropertiesTimesliceMetric returns the union data inside the CreateSloRequest_Indicator as a IndicatorPropertiesTimesliceMetric
func (t CreateSloRequest_Indicator) AsIndicatorPropertiesTimesliceMetric() (IndicatorPropertiesTimesliceMetric, error) {
	var body IndicatorPropertiesTimesliceMetric
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndicatorPropertiesTimesliceMetric overwrites any union data inside the CreateSloRequest_Indicator as the provided IndicatorPropertiesTimesliceMetric
func (t *CreateSloRequest_Indicator) FromIndicatorPropertiesTimesliceMetric(v IndicatorPropertiesTimesliceMetric) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndicatorPropertiesTimesliceMetric performs a merge with any union data inside the CreateSloRequest_Indicator, using the provided IndicatorPropertiesTimesliceMetric
func (t *CreateSloRequest_Indicator) MergeIndicatorPropertiesTimesliceMetric(v IndicatorPropertiesTimesliceMetric) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateSloRequest_Indicator) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateSloRequest_Indicator) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsKibanaSavedObjectType returns the union data inside the DeletePackageResponseObjectItemItem_Type as a KibanaSavedObjectType
func (t DeletePackageResponseObjectItemItem_Type) AsKibanaSavedObjectType() (KibanaSavedObjectType, error) {
	var body KibanaSavedObjectType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKibanaSavedObjectType overwrites any union data inside the DeletePackageResponseObjectItemItem_Type as the provided KibanaSavedObjectType
func (t *DeletePackageResponseObjectItemItem_Type) FromKibanaSavedObjectType(v KibanaSavedObjectType) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKibanaSavedObjectType performs a merge with any union data inside the DeletePackageResponseObjectItemItem_Type, using the provided KibanaSavedObjectType
func (t *DeletePackageResponseObjectItemItem_Type) MergeKibanaSavedObjectType(v KibanaSavedObjectType) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsElasticsearchAssetType returns the union data inside the DeletePackageResponseObjectItemItem_Type as a ElasticsearchAssetType
func (t DeletePackageResponseObjectItemItem_Type) AsElasticsearchAssetType() (ElasticsearchAssetType, error) {
	var body ElasticsearchAssetType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromElasticsearchAssetType overwrites any union data inside the DeletePackageResponseObjectItemItem_Type as the provided ElasticsearchAssetType
func (t *DeletePackageResponseObjectItemItem_Type) FromElasticsearchAssetType(v ElasticsearchAssetType) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeElasticsearchAssetType performs a merge with any union data inside the DeletePackageResponseObjectItemItem_Type, using the provided ElasticsearchAssetType
func (t *DeletePackageResponseObjectItemItem_Type) MergeElasticsearchAssetType(v ElasticsearchAssetType) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t DeletePackageResponseObjectItemItem_Type) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DeletePackageResponseObjectItemItem_Type) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsFindRuleResponseObjectSnoozeScheduleItemRRuleByweekday0 returns the union data inside the FindRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item as a FindRuleResponseObjectSnoozeScheduleItemRRuleByweekday0
func (t FindRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item) AsFindRuleResponseObjectSnoozeScheduleItemRRuleByweekday0() (FindRuleResponseObjectSnoozeScheduleItemRRuleByweekday0, error) {
	var body FindRuleResponseObjectSnoozeScheduleItemRRuleByweekday0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFindRuleResponseObjectSnoozeScheduleItemRRuleByweekday0 overwrites any union data inside the FindRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item as the provided FindRuleResponseObjectSnoozeScheduleItemRRuleByweekday0
func (t *FindRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item) FromFindRuleResponseObjectSnoozeScheduleItemRRuleByweekday0(v FindRuleResponseObjectSnoozeScheduleItemRRuleByweekday0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFindRuleResponseObjectSnoozeScheduleItemRRuleByweekday0 performs a merge with any union data inside the FindRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item, using the provided FindRuleResponseObjectSnoozeScheduleItemRRuleByweekday0
func (t *FindRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item) MergeFindRuleResponseObjectSnoozeScheduleItemRRuleByweekday0(v FindRuleResponseObjectSnoozeScheduleItemRRuleByweekday0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFindRuleResponseObjectSnoozeScheduleItemRRuleByweekday1 returns the union data inside the FindRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item as a FindRuleResponseObjectSnoozeScheduleItemRRuleByweekday1
func (t FindRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item) AsFindRuleResponseObjectSnoozeScheduleItemRRuleByweekday1() (FindRuleResponseObjectSnoozeScheduleItemRRuleByweekday1, error) {
	var body FindRuleResponseObjectSnoozeScheduleItemRRuleByweekday1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFindRuleResponseObjectSnoozeScheduleItemRRuleByweekday1 overwrites any union data inside the FindRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item as the provided FindRuleResponseObjectSnoozeScheduleItemRRuleByweekday1
func (t *FindRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item) FromFindRuleResponseObjectSnoozeScheduleItemRRuleByweekday1(v FindRuleResponseObjectSnoozeScheduleItemRRuleByweekday1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFindRuleResponseObjectSnoozeScheduleItemRRuleByweekday1 performs a merge with any union data inside the FindRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item, using the provided FindRuleResponseObjectSnoozeScheduleItemRRuleByweekday1
func (t *FindRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item) MergeFindRuleResponseObjectSnoozeScheduleItemRRuleByweekday1(v FindRuleResponseObjectSnoozeScheduleItemRRuleByweekday1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t FindRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *FindRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGetRuleResponseObjectSnoozeScheduleItemRRuleByweekday0 returns the union data inside the GetRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item as a GetRuleResponseObjectSnoozeScheduleItemRRuleByweekday0
func (t GetRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item) AsGetRuleResponseObjectSnoozeScheduleItemRRuleByweekday0() (GetRuleResponseObjectSnoozeScheduleItemRRuleByweekday0, error) {
	var body GetRuleResponseObjectSnoozeScheduleItemRRuleByweekday0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetRuleResponseObjectSnoozeScheduleItemRRuleByweekday0 overwrites any union data inside the GetRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item as the provided GetRuleResponseObjectSnoozeScheduleItemRRuleByweekday0
func (t *GetRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item) FromGetRuleResponseObjectSnoozeScheduleItemRRuleByweekday0(v GetRuleResponseObjectSnoozeScheduleItemRRuleByweekday0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetRuleResponseObjectSnoozeScheduleItemRRuleByweekday0 performs a merge with any union data inside the GetRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item, using the provided GetRuleResponseObjectSnoozeScheduleItemRRuleByweekday0
func (t *GetRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item) MergeGetRuleResponseObjectSnoozeScheduleItemRRuleByweekday0(v GetRuleResponseObjectSnoozeScheduleItemRRuleByweekday0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGetRuleResponseObjectSnoozeScheduleItemRRuleByweekday1 returns the union data inside the GetRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item as a GetRuleResponseObjectSnoozeScheduleItemRRuleByweekday1
func (t GetRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item) AsGetRuleResponseObjectSnoozeScheduleItemRRuleByweekday1() (GetRuleResponseObjectSnoozeScheduleItemRRuleByweekday1, error) {
	var body GetRuleResponseObjectSnoozeScheduleItemRRuleByweekday1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetRuleResponseObjectSnoozeScheduleItemRRuleByweekday1 overwrites any union data inside the GetRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item as the provided GetRuleResponseObjectSnoozeScheduleItemRRuleByweekday1
func (t *GetRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item) FromGetRuleResponseObjectSnoozeScheduleItemRRuleByweekday1(v GetRuleResponseObjectSnoozeScheduleItemRRuleByweekday1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetRuleResponseObjectSnoozeScheduleItemRRuleByweekday1 performs a merge with any union data inside the GetRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item, using the provided GetRuleResponseObjectSnoozeScheduleItemRRuleByweekday1
func (t *GetRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item) MergeGetRuleResponseObjectSnoozeScheduleItemRRuleByweekday1(v GetRuleResponseObjectSnoozeScheduleItemRRuleByweekday1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTimesliceMetricBasicMetricWithField returns the union data inside the IndicatorPropertiesTimesliceMetricParamsMetric_Metrics_Item as a TimesliceMetricBasicMetricWithField
func (t IndicatorPropertiesTimesliceMetricParamsMetric_Metrics_Item) AsTimesliceMetricBasicMetricWithField() (TimesliceMetricBasicMetricWithField, error) {
	var body TimesliceMetricBasicMetricWithField
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTimesliceMetricBasicMetricWithField overwrites any union data inside the IndicatorPropertiesTimesliceMetricParamsMetric_Metrics_Item as the provided TimesliceMetricBasicMetricWithField
func (t *IndicatorPropertiesTimesliceMetricParamsMetric_Metrics_Item) FromTimesliceMetricBasicMetricWithField(v TimesliceMetricBasicMetricWithField) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTimesliceMetricBasicMetricWithField performs a merge with any union data inside the IndicatorPropertiesTimesliceMetricParamsMetric_Metrics_Item, using the provided TimesliceMetricBasicMetricWithField
func (t *IndicatorPropertiesTimesliceMetricParamsMetric_Metrics_Item) MergeTimesliceMetricBasicMetricWithField(v TimesliceMetricBasicMetricWithField) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTimesliceMetricPercentileMetric returns the union data inside the IndicatorPropertiesTimesliceMetricParamsMetric_Metrics_Item as a TimesliceMetricPercentileMetric
func (t IndicatorPropertiesTimesliceMetricParamsMetric_Metrics_Item) AsTimesliceMetricPercentileMetric() (TimesliceMetricPercentileMetric, error) {
	var body TimesliceMetricPercentileMetric
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTimesliceMetricPercentileMetric overwrites any union data inside the IndicatorPropertiesTimesliceMetricParamsMetric_Metrics_Item as the provided TimesliceMetricPercentileMetric
func (t *IndicatorPropertiesTimesliceMetricParamsMetric_Metrics_Item) FromTimesliceMetricPercentileMetric(v TimesliceMetricPercentileMetric) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTimesliceMetricPercentileMetric performs a merge with any union data inside the IndicatorPropertiesTimesliceMetricParamsMetric_Metrics_Item, using the provided TimesliceMetricPercentileMetric
func (t *IndicatorPropertiesTimesliceMetricParamsMetric_Metrics_Item) MergeTimesliceMetricPercentileMetric(v TimesliceMetricPercentileMetric) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTimesliceMetricDocCountMetric returns the union data inside the IndicatorPropertiesTimesliceMetricParamsMetric_Metrics_Item as a TimesliceMetricDocCountMetric
func (t IndicatorPropertiesTimesliceMetricParamsMetric_Metrics_Item) AsTimesliceMetricDocCountMetric() (TimesliceMetricDocCountMetric, error) {
	var body TimesliceMetricDocCountMetric
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTimesliceMetricDocCountMetric overwrites any union data inside the IndicatorPropertiesTimesliceMetricParamsMetric_Metrics_Item as the provided TimesliceMetricDocCountMetric
func (t *IndicatorPropertiesTimesliceMetricParamsMetric_Metrics_Item) FromTimesliceMetricDocCountMetric(v TimesliceMetricDocCountMetric) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTimesliceMetricDocCountMetric performs a merge with any union data inside the IndicatorPropertiesTimesliceMetricParamsMetric_Metrics_Item, using the provided TimesliceMetricDocCountMetric
func (t *IndicatorPropertiesTimesliceMetricParamsMetric_Metrics_Item) MergeTimesliceMetricDocCountMetric(v TimesliceMetricDocCountMetric) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t IndicatorPropertiesTimesliceMetricParamsMetric_Metrics_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *IndicatorPropertiesTimesliceMetricParamsMetric_Metrics_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsKibanaSavedObjectType returns the union data inside the InstallPackageByUploadResponseObjectItemItem_Type as a KibanaSavedObjectType
func (t InstallPackageByUploadResponseObjectItemItem_Type) AsKibanaSavedObjectType() (KibanaSavedObjectType, error) {
	var body KibanaSavedObjectType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKibanaSavedObjectType overwrites any union data inside the InstallPackageByUploadResponseObjectItemItem_Type as the provided KibanaSavedObjectType
func (t *InstallPackageByUploadResponseObjectItemItem_Type) FromKibanaSavedObjectType(v KibanaSavedObjectType) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKibanaSavedObjectType performs a merge with any union data inside the InstallPackageByUploadResponseObjectItemItem_Type, using the provided KibanaSavedObjectType
func (t *InstallPackageByUploadResponseObjectItemItem_Type) MergeKibanaSavedObjectType(v KibanaSavedObjectType) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsElasticsearchAssetType returns the union data inside the InstallPackageByUploadResponseObjectItemItem_Type as a ElasticsearchAssetType
func (t InstallPackageByUploadResponseObjectItemItem_Type) AsElasticsearchAssetType() (ElasticsearchAssetType, error) {
	var body ElasticsearchAssetType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromElasticsearchAssetType overwrites any union data inside the InstallPackageByUploadResponseObjectItemItem_Type as the provided ElasticsearchAssetType
func (t *InstallPackageByUploadResponseObjectItemItem_Type) FromElasticsearchAssetType(v ElasticsearchAssetType) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeElasticsearchAssetType performs a merge with any union data inside the InstallPackageByUploadResponseObjectItemItem_Type, using the provided ElasticsearchAssetType
func (t *InstallPackageByUploadResponseObjectItemItem_Type) MergeElasticsearchAssetType(v ElasticsearchAssetType) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t InstallPackageByUploadResponseObjectItemItem_Type) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *InstallPackageByUploadResponseObjectItemItem_Type) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsKibanaSavedObjectType returns the union data inside the InstallPackageResponseObjectItemItem_Type as a KibanaSavedObjectType
func (t InstallPackageResponseObjectItemItem_Type) AsKibanaSavedObjectType() (KibanaSavedObjectType, error) {
	var body KibanaSavedObjectType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKibanaSavedObjectType overwrites any union data inside the InstallPackageResponseObjectItemItem_Type as the provided KibanaSavedObjectType
func (t *InstallPackageResponseObjectItemItem_Type) FromKibanaSavedObjectType(v KibanaSavedObjectType) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKibanaSavedObjectType performs a merge with any union data inside the InstallPackageResponseObjectItemItem_Type, using the provided KibanaSavedObjectType
func (t *InstallPackageResponseObjectItemItem_Type) MergeKibanaSavedObjectType(v KibanaSavedObjectType) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsElasticsearchAssetType returns the union data inside the InstallPackageResponseObjectItemItem_Type as a ElasticsearchAssetType
func (t InstallPackageResponseObjectItemItem_Type) AsElasticsearchAssetType() (ElasticsearchAssetType, error) {
	var body ElasticsearchAssetType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromElasticsearchAssetType overwrites any union data inside the InstallPackageResponseObjectItemItem_Type as the provided ElasticsearchAssetType
func (t *InstallPackageResponseObjectItemItem_Type) FromElasticsearchAssetType(v ElasticsearchAssetType) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeElasticsearchAssetType performs a merge with any union data inside the InstallPackageResponseObjectItemItem_Type, using the provided ElasticsearchAssetType
func (t *InstallPackageResponseObjectItemItem_Type) MergeElasticsearchAssetType(v ElasticsearchAssetType) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t InstallPackageResponseObjectItemItem_Type) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *InstallPackageResponseObjectItemItem_Type) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsKqlWithFilters0 returns the union data inside the KqlWithFilters as a KqlWithFilters0
func (t KqlWithFilters) AsKqlWithFilters0() (KqlWithFilters0, error) {
	var body KqlWithFilters0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKqlWithFilters0 overwrites any union data inside the KqlWithFilters as the provided KqlWithFilters0
func (t *KqlWithFilters) FromKqlWithFilters0(v KqlWithFilters0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKqlWithFilters0 performs a merge with any union data inside the KqlWithFilters, using the provided KqlWithFilters0
func (t *KqlWithFilters) MergeKqlWithFilters0(v KqlWithFilters0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsKqlWithFiltersOneOf1 returns the union data inside the KqlWithFilters as a KqlWithFiltersOneOf1
func (t KqlWithFilters) AsKqlWithFiltersOneOf1() (KqlWithFiltersOneOf1, error) {
	var body KqlWithFiltersOneOf1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKqlWithFiltersOneOf1 overwrites any union data inside the KqlWithFilters as the provided KqlWithFiltersOneOf1
func (t *KqlWithFilters) FromKqlWithFiltersOneOf1(v KqlWithFiltersOneOf1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKqlWithFiltersOneOf1 performs a merge with any union data inside the KqlWithFilters, using the provided KqlWithFiltersOneOf1
func (t *KqlWithFilters) MergeKqlWithFiltersOneOf1(v KqlWithFiltersOneOf1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t KqlWithFilters) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *KqlWithFilters) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsKqlWithFiltersGood0 returns the union data inside the KqlWithFiltersGood as a KqlWithFiltersGood0
func (t KqlWithFiltersGood) AsKqlWithFiltersGood0() (KqlWithFiltersGood0, error) {
	var body KqlWithFiltersGood0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKqlWithFiltersGood0 overwrites any union data inside the KqlWithFiltersGood as the provided KqlWithFiltersGood0
func (t *KqlWithFiltersGood) FromKqlWithFiltersGood0(v KqlWithFiltersGood0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKqlWithFiltersGood0 performs a merge with any union data inside the KqlWithFiltersGood, using the provided KqlWithFiltersGood0
func (t *KqlWithFiltersGood) MergeKqlWithFiltersGood0(v KqlWithFiltersGood0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsKqlWithFiltersGoodOneOf1 returns the union data inside the KqlWithFiltersGood as a KqlWithFiltersGoodOneOf1
func (t KqlWithFiltersGood) AsKqlWithFiltersGoodOneOf1() (KqlWithFiltersGoodOneOf1, error) {
	var body KqlWithFiltersGoodOneOf1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKqlWithFiltersGoodOneOf1 overwrites any union data inside the KqlWithFiltersGood as the provided KqlWithFiltersGoodOneOf1
func (t *KqlWithFiltersGood) FromKqlWithFiltersGoodOneOf1(v KqlWithFiltersGoodOneOf1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKqlWithFiltersGoodOneOf1 performs a merge with any union data inside the KqlWithFiltersGood, using the provided KqlWithFiltersGoodOneOf1
func (t *KqlWithFiltersGood) MergeKqlWithFiltersGoodOneOf1(v KqlWithFiltersGoodOneOf1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t KqlWithFiltersGood) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *KqlWithFiltersGood) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsKqlWithFiltersTotal0 returns the union data inside the KqlWithFiltersTotal as a KqlWithFiltersTotal0
func (t KqlWithFiltersTotal) AsKqlWithFiltersTotal0() (KqlWithFiltersTotal0, error) {
	var body KqlWithFiltersTotal0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKqlWithFiltersTotal0 overwrites any union data inside the KqlWithFiltersTotal as the provided KqlWithFiltersTotal0
func (t *KqlWithFiltersTotal) FromKqlWithFiltersTotal0(v KqlWithFiltersTotal0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKqlWithFiltersTotal0 performs a merge with any union data inside the KqlWithFiltersTotal, using the provided KqlWithFiltersTotal0
func (t *KqlWithFiltersTotal) MergeKqlWithFiltersTotal0(v KqlWithFiltersTotal0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsKqlWithFiltersTotalOneOf1 returns the union data inside the KqlWithFiltersTotal as a KqlWithFiltersTotalOneOf1
func (t KqlWithFiltersTotal) AsKqlWithFiltersTotalOneOf1() (KqlWithFiltersTotalOneOf1, error) {
	var body KqlWithFiltersTotalOneOf1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKqlWithFiltersTotalOneOf1 overwrites any union data inside the KqlWithFiltersTotal as the provided KqlWithFiltersTotalOneOf1
func (t *KqlWithFiltersTotal) FromKqlWithFiltersTotalOneOf1(v KqlWithFiltersTotalOneOf1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKqlWithFiltersTotalOneOf1 performs a merge with any union data inside the KqlWithFiltersTotal, using the provided KqlWithFiltersTotalOneOf1
func (t *KqlWithFiltersTotal) MergeKqlWithFiltersTotalOneOf1(v KqlWithFiltersTotalOneOf1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t KqlWithFiltersTotal) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *KqlWithFiltersTotal) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOutputCreateRequestElasticsearch returns the union data inside the OutputCreateRequest as a OutputCreateRequestElasticsearch
func (t OutputCreateRequest) AsOutputCreateRequestElasticsearch() (OutputCreateRequestElasticsearch, error) {
	var body OutputCreateRequestElasticsearch
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOutputCreateRequestElasticsearch overwrites any union data inside the OutputCreateRequest as the provided OutputCreateRequestElasticsearch
func (t *OutputCreateRequest) FromOutputCreateRequestElasticsearch(v OutputCreateRequestElasticsearch) error {
	v.Type = "elasticsearch"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOutputCreateRequestElasticsearch performs a merge with any union data inside the OutputCreateRequest, using the provided OutputCreateRequestElasticsearch
func (t *OutputCreateRequest) MergeOutputCreateRequestElasticsearch(v OutputCreateRequestElasticsearch) error {
	v.Type = "elasticsearch"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOutputCreateRequestKafka returns the union data inside the OutputCreateRequest as a OutputCreateRequestKafka
func (t OutputCreateRequest) AsOutputCreateRequestKafka() (OutputCreateRequestKafka, error) {
	var body OutputCreateRequestKafka
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOutputCreateRequestKafka overwrites any union data inside the OutputCreateRequest as the provided OutputCreateRequestKafka
func (t *OutputCreateRequest) FromOutputCreateRequestKafka(v OutputCreateRequestKafka) error {
	v.Type = "kafka"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOutputCreateRequestKafka performs a merge with any union data inside the OutputCreateRequest, using the provided OutputCreateRequestKafka
func (t *OutputCreateRequest) MergeOutputCreateRequestKafka(v OutputCreateRequestKafka) error {
	v.Type = "kafka"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOutputCreateRequestLogstash returns the union data inside the OutputCreateRequest as a OutputCreateRequestLogstash
func (t OutputCreateRequest) AsOutputCreateRequestLogstash() (OutputCreateRequestLogstash, error) {
	var body OutputCreateRequestLogstash
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOutputCreateRequestLogstash overwrites any union data inside the OutputCreateRequest as the provided OutputCreateRequestLogstash
func (t *OutputCreateRequest) FromOutputCreateRequestLogstash(v OutputCreateRequestLogstash) error {
	v.Type = "logstash"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOutputCreateRequestLogstash performs a merge with any union data inside the OutputCreateRequest, using the provided OutputCreateRequestLogstash
func (t *OutputCreateRequest) MergeOutputCreateRequestLogstash(v OutputCreateRequestLogstash) error {
	v.Type = "logstash"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOutputCreateRequestRemoteElasticsearch returns the union data inside the OutputCreateRequest as a OutputCreateRequestRemoteElasticsearch
func (t OutputCreateRequest) AsOutputCreateRequestRemoteElasticsearch() (OutputCreateRequestRemoteElasticsearch, error) {
	var body OutputCreateRequestRemoteElasticsearch
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOutputCreateRequestRemoteElasticsearch overwrites any union data inside the OutputCreateRequest as the provided OutputCreateRequestRemoteElasticsearch
func (t *OutputCreateRequest) FromOutputCreateRequestRemoteElasticsearch(v OutputCreateRequestRemoteElasticsearch) error {
	v.Type = "remote_elasticsearch"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOutputCreateRequestRemoteElasticsearch performs a merge with any union data inside the OutputCreateRequest, using the provided OutputCreateRequestRemoteElasticsearch
func (t *OutputCreateRequest) MergeOutputCreateRequestRemoteElasticsearch(v OutputCreateRequestRemoteElasticsearch) error {
	v.Type = "remote_elasticsearch"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t OutputCreateRequest) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t OutputCreateRequest) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "elasticsearch":
		return t.AsOutputCreateRequestElasticsearch()
	case "kafka":
		return t.AsOutputCreateRequestKafka()
	case "logstash":
		return t.AsOutputCreateRequestLogstash()
	case "remote_elasticsearch":
		return t.AsOutputCreateRequestRemoteElasticsearch()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t OutputCreateRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OutputCreateRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOutputUpdateRequestElasticsearch returns the union data inside the OutputUpdateRequest as a OutputUpdateRequestElasticsearch
func (t OutputUpdateRequest) AsOutputUpdateRequestElasticsearch() (OutputUpdateRequestElasticsearch, error) {
	var body OutputUpdateRequestElasticsearch
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOutputUpdateRequestElasticsearch overwrites any union data inside the OutputUpdateRequest as the provided OutputUpdateRequestElasticsearch
func (t *OutputUpdateRequest) FromOutputUpdateRequestElasticsearch(v OutputUpdateRequestElasticsearch) error {
	v.Type = "elasticsearch"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOutputUpdateRequestElasticsearch performs a merge with any union data inside the OutputUpdateRequest, using the provided OutputUpdateRequestElasticsearch
func (t *OutputUpdateRequest) MergeOutputUpdateRequestElasticsearch(v OutputUpdateRequestElasticsearch) error {
	v.Type = "elasticsearch"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOutputUpdateRequestKafka returns the union data inside the OutputUpdateRequest as a OutputUpdateRequestKafka
func (t OutputUpdateRequest) AsOutputUpdateRequestKafka() (OutputUpdateRequestKafka, error) {
	var body OutputUpdateRequestKafka
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOutputUpdateRequestKafka overwrites any union data inside the OutputUpdateRequest as the provided OutputUpdateRequestKafka
func (t *OutputUpdateRequest) FromOutputUpdateRequestKafka(v OutputUpdateRequestKafka) error {
	v.Type = "kafka"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOutputUpdateRequestKafka performs a merge with any union data inside the OutputUpdateRequest, using the provided OutputUpdateRequestKafka
func (t *OutputUpdateRequest) MergeOutputUpdateRequestKafka(v OutputUpdateRequestKafka) error {
	v.Type = "kafka"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOutputUpdateRequestLogstash returns the union data inside the OutputUpdateRequest as a OutputUpdateRequestLogstash
func (t OutputUpdateRequest) AsOutputUpdateRequestLogstash() (OutputUpdateRequestLogstash, error) {
	var body OutputUpdateRequestLogstash
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOutputUpdateRequestLogstash overwrites any union data inside the OutputUpdateRequest as the provided OutputUpdateRequestLogstash
func (t *OutputUpdateRequest) FromOutputUpdateRequestLogstash(v OutputUpdateRequestLogstash) error {
	v.Type = "logstash"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOutputUpdateRequestLogstash performs a merge with any union data inside the OutputUpdateRequest, using the provided OutputUpdateRequestLogstash
func (t *OutputUpdateRequest) MergeOutputUpdateRequestLogstash(v OutputUpdateRequestLogstash) error {
	v.Type = "logstash"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t OutputUpdateRequest) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t OutputUpdateRequest) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "elasticsearch":
		return t.AsOutputUpdateRequestElasticsearch()
	case "kafka":
		return t.AsOutputUpdateRequestKafka()
	case "logstash":
		return t.AsOutputUpdateRequestLogstash()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t OutputUpdateRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OutputUpdateRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPackagePolicyAllOf0Inputs0 returns the union data inside the PackagePolicyAllOf0_Inputs as a PackagePolicyAllOf0Inputs0
func (t PackagePolicyAllOf0_Inputs) AsPackagePolicyAllOf0Inputs0() (PackagePolicyAllOf0Inputs0, error) {
	var body PackagePolicyAllOf0Inputs0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPackagePolicyAllOf0Inputs0 overwrites any union data inside the PackagePolicyAllOf0_Inputs as the provided PackagePolicyAllOf0Inputs0
func (t *PackagePolicyAllOf0_Inputs) FromPackagePolicyAllOf0Inputs0(v PackagePolicyAllOf0Inputs0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePackagePolicyAllOf0Inputs0 performs a merge with any union data inside the PackagePolicyAllOf0_Inputs, using the provided PackagePolicyAllOf0Inputs0
func (t *PackagePolicyAllOf0_Inputs) MergePackagePolicyAllOf0Inputs0(v PackagePolicyAllOf0Inputs0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPackagePolicyAllOf0Inputs1 returns the union data inside the PackagePolicyAllOf0_Inputs as a PackagePolicyAllOf0Inputs1
func (t PackagePolicyAllOf0_Inputs) AsPackagePolicyAllOf0Inputs1() (PackagePolicyAllOf0Inputs1, error) {
	var body PackagePolicyAllOf0Inputs1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPackagePolicyAllOf0Inputs1 overwrites any union data inside the PackagePolicyAllOf0_Inputs as the provided PackagePolicyAllOf0Inputs1
func (t *PackagePolicyAllOf0_Inputs) FromPackagePolicyAllOf0Inputs1(v PackagePolicyAllOf0Inputs1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePackagePolicyAllOf0Inputs1 performs a merge with any union data inside the PackagePolicyAllOf0_Inputs, using the provided PackagePolicyAllOf0Inputs1
func (t *PackagePolicyAllOf0_Inputs) MergePackagePolicyAllOf0Inputs1(v PackagePolicyAllOf0Inputs1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PackagePolicyAllOf0_Inputs) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PackagePolicyAllOf0_Inputs) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsIndicatorPropertiesCustomKql returns the union data inside the SloDefinitionResponse_Indicator as a IndicatorPropertiesCustomKql
func (t SloDefinitionResponse_Indicator) AsIndicatorPropertiesCustomKql() (IndicatorPropertiesCustomKql, error) {
	var body IndicatorPropertiesCustomKql
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndicatorPropertiesCustomKql overwrites any union data inside the SloDefinitionResponse_Indicator as the provided IndicatorPropertiesCustomKql
func (t *SloDefinitionResponse_Indicator) FromIndicatorPropertiesCustomKql(v IndicatorPropertiesCustomKql) error {
	v.Type = "sli.kql.custom"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndicatorPropertiesCustomKql performs a merge with any union data inside the SloDefinitionResponse_Indicator, using the provided IndicatorPropertiesCustomKql
func (t *SloDefinitionResponse_Indicator) MergeIndicatorPropertiesCustomKql(v IndicatorPropertiesCustomKql) error {
	v.Type = "sli.kql.custom"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIndicatorPropertiesApmAvailability returns the union data inside the SloDefinitionResponse_Indicator as a IndicatorPropertiesApmAvailability
func (t SloDefinitionResponse_Indicator) AsIndicatorPropertiesApmAvailability() (IndicatorPropertiesApmAvailability, error) {
	var body IndicatorPropertiesApmAvailability
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndicatorPropertiesApmAvailability overwrites any union data inside the SloDefinitionResponse_Indicator as the provided IndicatorPropertiesApmAvailability
func (t *SloDefinitionResponse_Indicator) FromIndicatorPropertiesApmAvailability(v IndicatorPropertiesApmAvailability) error {
	v.Type = "sli.apm.transactionErrorRate"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndicatorPropertiesApmAvailability performs a merge with any union data inside the SloDefinitionResponse_Indicator, using the provided IndicatorPropertiesApmAvailability
func (t *SloDefinitionResponse_Indicator) MergeIndicatorPropertiesApmAvailability(v IndicatorPropertiesApmAvailability) error {
	v.Type = "sli.apm.transactionErrorRate"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIndicatorPropertiesApmLatency returns the union data inside the SloDefinitionResponse_Indicator as a IndicatorPropertiesApmLatency
func (t SloDefinitionResponse_Indicator) AsIndicatorPropertiesApmLatency() (IndicatorPropertiesApmLatency, error) {
	var body IndicatorPropertiesApmLatency
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndicatorPropertiesApmLatency overwrites any union data inside the SloDefinitionResponse_Indicator as the provided IndicatorPropertiesApmLatency
func (t *SloDefinitionResponse_Indicator) FromIndicatorPropertiesApmLatency(v IndicatorPropertiesApmLatency) error {
	v.Type = "sli.apm.transactionDuration"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndicatorPropertiesApmLatency performs a merge with any union data inside the SloDefinitionResponse_Indicator, using the provided IndicatorPropertiesApmLatency
func (t *SloDefinitionResponse_Indicator) MergeIndicatorPropertiesApmLatency(v IndicatorPropertiesApmLatency) error {
	v.Type = "sli.apm.transactionDuration"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIndicatorPropertiesCustomMetric returns the union data inside the SloDefinitionResponse_Indicator as a IndicatorPropertiesCustomMetric
func (t SloDefinitionResponse_Indicator) AsIndicatorPropertiesCustomMetric() (IndicatorPropertiesCustomMetric, error) {
	var body IndicatorPropertiesCustomMetric
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndicatorPropertiesCustomMetric overwrites any union data inside the SloDefinitionResponse_Indicator as the provided IndicatorPropertiesCustomMetric
func (t *SloDefinitionResponse_Indicator) FromIndicatorPropertiesCustomMetric(v IndicatorPropertiesCustomMetric) error {
	v.Type = "sli.metric.custom"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndicatorPropertiesCustomMetric performs a merge with any union data inside the SloDefinitionResponse_Indicator, using the provided IndicatorPropertiesCustomMetric
func (t *SloDefinitionResponse_Indicator) MergeIndicatorPropertiesCustomMetric(v IndicatorPropertiesCustomMetric) error {
	v.Type = "sli.metric.custom"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIndicatorPropertiesHistogram returns the union data inside the SloDefinitionResponse_Indicator as a IndicatorPropertiesHistogram
func (t SloDefinitionResponse_Indicator) AsIndicatorPropertiesHistogram() (IndicatorPropertiesHistogram, error) {
	var body IndicatorPropertiesHistogram
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndicatorPropertiesHistogram overwrites any union data inside the SloDefinitionResponse_Indicator as the provided IndicatorPropertiesHistogram
func (t *SloDefinitionResponse_Indicator) FromIndicatorPropertiesHistogram(v IndicatorPropertiesHistogram) error {
	v.Type = "sli.histogram.custom"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndicatorPropertiesHistogram performs a merge with any union data inside the SloDefinitionResponse_Indicator, using the provided IndicatorPropertiesHistogram
func (t *SloDefinitionResponse_Indicator) MergeIndicatorPropertiesHistogram(v IndicatorPropertiesHistogram) error {
	v.Type = "sli.histogram.custom"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIndicatorPropertiesTimesliceMetric returns the union data inside the SloDefinitionResponse_Indicator as a IndicatorPropertiesTimesliceMetric
func (t SloDefinitionResponse_Indicator) AsIndicatorPropertiesTimesliceMetric() (IndicatorPropertiesTimesliceMetric, error) {
	var body IndicatorPropertiesTimesliceMetric
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndicatorPropertiesTimesliceMetric overwrites any union data inside the SloDefinitionResponse_Indicator as the provided IndicatorPropertiesTimesliceMetric
func (t *SloDefinitionResponse_Indicator) FromIndicatorPropertiesTimesliceMetric(v IndicatorPropertiesTimesliceMetric) error {
	v.Type = "sli.metric.timeslice"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndicatorPropertiesTimesliceMetric performs a merge with any union data inside the SloDefinitionResponse_Indicator, using the provided IndicatorPropertiesTimesliceMetric
func (t *SloDefinitionResponse_Indicator) MergeIndicatorPropertiesTimesliceMetric(v IndicatorPropertiesTimesliceMetric) error {
	v.Type = "sli.metric.timeslice"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SloDefinitionResponse_Indicator) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t SloDefinitionResponse_Indicator) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "sli.apm.transactionDuration":
		return t.AsIndicatorPropertiesApmLatency()
	case "sli.apm.transactionErrorRate":
		return t.AsIndicatorPropertiesApmAvailability()
	case "sli.histogram.custom":
		return t.AsIndicatorPropertiesHistogram()
	case "sli.kql.custom":
		return t.AsIndicatorPropertiesCustomKql()
	case "sli.metric.custom":
		return t.AsIndicatorPropertiesCustomMetric()
	case "sli.metric.timeslice":
		return t.AsIndicatorPropertiesTimesliceMetric()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t SloDefinitionResponse_Indicator) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SloDefinitionResponse_Indicator) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsIndicatorPropertiesCustomKql returns the union data inside the SloWithSummaryResponse_Indicator as a IndicatorPropertiesCustomKql
func (t SloWithSummaryResponse_Indicator) AsIndicatorPropertiesCustomKql() (IndicatorPropertiesCustomKql, error) {
	var body IndicatorPropertiesCustomKql
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndicatorPropertiesCustomKql overwrites any union data inside the SloWithSummaryResponse_Indicator as the provided IndicatorPropertiesCustomKql
func (t *SloWithSummaryResponse_Indicator) FromIndicatorPropertiesCustomKql(v IndicatorPropertiesCustomKql) error {
	v.Type = "sli.kql.custom"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndicatorPropertiesCustomKql performs a merge with any union data inside the SloWithSummaryResponse_Indicator, using the provided IndicatorPropertiesCustomKql
func (t *SloWithSummaryResponse_Indicator) MergeIndicatorPropertiesCustomKql(v IndicatorPropertiesCustomKql) error {
	v.Type = "sli.kql.custom"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIndicatorPropertiesApmAvailability returns the union data inside the SloWithSummaryResponse_Indicator as a IndicatorPropertiesApmAvailability
func (t SloWithSummaryResponse_Indicator) AsIndicatorPropertiesApmAvailability() (IndicatorPropertiesApmAvailability, error) {
	var body IndicatorPropertiesApmAvailability
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndicatorPropertiesApmAvailability overwrites any union data inside the SloWithSummaryResponse_Indicator as the provided IndicatorPropertiesApmAvailability
func (t *SloWithSummaryResponse_Indicator) FromIndicatorPropertiesApmAvailability(v IndicatorPropertiesApmAvailability) error {
	v.Type = "sli.apm.transactionErrorRate"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndicatorPropertiesApmAvailability performs a merge with any union data inside the SloWithSummaryResponse_Indicator, using the provided IndicatorPropertiesApmAvailability
func (t *SloWithSummaryResponse_Indicator) MergeIndicatorPropertiesApmAvailability(v IndicatorPropertiesApmAvailability) error {
	v.Type = "sli.apm.transactionErrorRate"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIndicatorPropertiesApmLatency returns the union data inside the SloWithSummaryResponse_Indicator as a IndicatorPropertiesApmLatency
func (t SloWithSummaryResponse_Indicator) AsIndicatorPropertiesApmLatency() (IndicatorPropertiesApmLatency, error) {
	var body IndicatorPropertiesApmLatency
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndicatorPropertiesApmLatency overwrites any union data inside the SloWithSummaryResponse_Indicator as the provided IndicatorPropertiesApmLatency
func (t *SloWithSummaryResponse_Indicator) FromIndicatorPropertiesApmLatency(v IndicatorPropertiesApmLatency) error {
	v.Type = "sli.apm.transactionDuration"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndicatorPropertiesApmLatency performs a merge with any union data inside the SloWithSummaryResponse_Indicator, using the provided IndicatorPropertiesApmLatency
func (t *SloWithSummaryResponse_Indicator) MergeIndicatorPropertiesApmLatency(v IndicatorPropertiesApmLatency) error {
	v.Type = "sli.apm.transactionDuration"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIndicatorPropertiesCustomMetric returns the union data inside the SloWithSummaryResponse_Indicator as a IndicatorPropertiesCustomMetric
func (t SloWithSummaryResponse_Indicator) AsIndicatorPropertiesCustomMetric() (IndicatorPropertiesCustomMetric, error) {
	var body IndicatorPropertiesCustomMetric
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndicatorPropertiesCustomMetric overwrites any union data inside the SloWithSummaryResponse_Indicator as the provided IndicatorPropertiesCustomMetric
func (t *SloWithSummaryResponse_Indicator) FromIndicatorPropertiesCustomMetric(v IndicatorPropertiesCustomMetric) error {
	v.Type = "sli.metric.custom"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndicatorPropertiesCustomMetric performs a merge with any union data inside the SloWithSummaryResponse_Indicator, using the provided IndicatorPropertiesCustomMetric
func (t *SloWithSummaryResponse_Indicator) MergeIndicatorPropertiesCustomMetric(v IndicatorPropertiesCustomMetric) error {
	v.Type = "sli.metric.custom"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIndicatorPropertiesHistogram returns the union data inside the SloWithSummaryResponse_Indicator as a IndicatorPropertiesHistogram
func (t SloWithSummaryResponse_Indicator) AsIndicatorPropertiesHistogram() (IndicatorPropertiesHistogram, error) {
	var body IndicatorPropertiesHistogram
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndicatorPropertiesHistogram overwrites any union data inside the SloWithSummaryResponse_Indicator as the provided IndicatorPropertiesHistogram
func (t *SloWithSummaryResponse_Indicator) FromIndicatorPropertiesHistogram(v IndicatorPropertiesHistogram) error {
	v.Type = "sli.histogram.custom"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndicatorPropertiesHistogram performs a merge with any union data inside the SloWithSummaryResponse_Indicator, using the provided IndicatorPropertiesHistogram
func (t *SloWithSummaryResponse_Indicator) MergeIndicatorPropertiesHistogram(v IndicatorPropertiesHistogram) error {
	v.Type = "sli.histogram.custom"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIndicatorPropertiesTimesliceMetric returns the union data inside the SloWithSummaryResponse_Indicator as a IndicatorPropertiesTimesliceMetric
func (t SloWithSummaryResponse_Indicator) AsIndicatorPropertiesTimesliceMetric() (IndicatorPropertiesTimesliceMetric, error) {
	var body IndicatorPropertiesTimesliceMetric
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndicatorPropertiesTimesliceMetric overwrites any union data inside the SloWithSummaryResponse_Indicator as the provided IndicatorPropertiesTimesliceMetric
func (t *SloWithSummaryResponse_Indicator) FromIndicatorPropertiesTimesliceMetric(v IndicatorPropertiesTimesliceMetric) error {
	v.Type = "sli.metric.timeslice"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndicatorPropertiesTimesliceMetric performs a merge with any union data inside the SloWithSummaryResponse_Indicator, using the provided IndicatorPropertiesTimesliceMetric
func (t *SloWithSummaryResponse_Indicator) MergeIndicatorPropertiesTimesliceMetric(v IndicatorPropertiesTimesliceMetric) error {
	v.Type = "sli.metric.timeslice"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SloWithSummaryResponse_Indicator) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t SloWithSummaryResponse_Indicator) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "sli.apm.transactionDuration":
		return t.AsIndicatorPropertiesApmLatency()
	case "sli.apm.transactionErrorRate":
		return t.AsIndicatorPropertiesApmAvailability()
	case "sli.histogram.custom":
		return t.AsIndicatorPropertiesHistogram()
	case "sli.kql.custom":
		return t.AsIndicatorPropertiesCustomKql()
	case "sli.metric.custom":
		return t.AsIndicatorPropertiesCustomMetric()
	case "sli.metric.timeslice":
		return t.AsIndicatorPropertiesTimesliceMetric()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t SloWithSummaryResponse_Indicator) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SloWithSummaryResponse_Indicator) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsKibanaSavedObjectType returns the union data inside the UpdatePackageResponseObjectItemItem_Type as a KibanaSavedObjectType
func (t UpdatePackageResponseObjectItemItem_Type) AsKibanaSavedObjectType() (KibanaSavedObjectType, error) {
	var body KibanaSavedObjectType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKibanaSavedObjectType overwrites any union data inside the UpdatePackageResponseObjectItemItem_Type as the provided KibanaSavedObjectType
func (t *UpdatePackageResponseObjectItemItem_Type) FromKibanaSavedObjectType(v KibanaSavedObjectType) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKibanaSavedObjectType performs a merge with any union data inside the UpdatePackageResponseObjectItemItem_Type, using the provided KibanaSavedObjectType
func (t *UpdatePackageResponseObjectItemItem_Type) MergeKibanaSavedObjectType(v KibanaSavedObjectType) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsElasticsearchAssetType returns the union data inside the UpdatePackageResponseObjectItemItem_Type as a ElasticsearchAssetType
func (t UpdatePackageResponseObjectItemItem_Type) AsElasticsearchAssetType() (ElasticsearchAssetType, error) {
	var body ElasticsearchAssetType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromElasticsearchAssetType overwrites any union data inside the UpdatePackageResponseObjectItemItem_Type as the provided ElasticsearchAssetType
func (t *UpdatePackageResponseObjectItemItem_Type) FromElasticsearchAssetType(v ElasticsearchAssetType) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeElasticsearchAssetType performs a merge with any union data inside the UpdatePackageResponseObjectItemItem_Type, using the provided ElasticsearchAssetType
func (t *UpdatePackageResponseObjectItemItem_Type) MergeElasticsearchAssetType(v ElasticsearchAssetType) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UpdatePackageResponseObjectItemItem_Type) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UpdatePackageResponseObjectItemItem_Type) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUpdateRuleResponseObjectSnoozeScheduleItemRRuleByweekday0 returns the union data inside the UpdateRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item as a UpdateRuleResponseObjectSnoozeScheduleItemRRuleByweekday0
func (t UpdateRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item) AsUpdateRuleResponseObjectSnoozeScheduleItemRRuleByweekday0() (UpdateRuleResponseObjectSnoozeScheduleItemRRuleByweekday0, error) {
	var body UpdateRuleResponseObjectSnoozeScheduleItemRRuleByweekday0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateRuleResponseObjectSnoozeScheduleItemRRuleByweekday0 overwrites any union data inside the UpdateRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item as the provided UpdateRuleResponseObjectSnoozeScheduleItemRRuleByweekday0
func (t *UpdateRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item) FromUpdateRuleResponseObjectSnoozeScheduleItemRRuleByweekday0(v UpdateRuleResponseObjectSnoozeScheduleItemRRuleByweekday0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateRuleResponseObjectSnoozeScheduleItemRRuleByweekday0 performs a merge with any union data inside the UpdateRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item, using the provided UpdateRuleResponseObjectSnoozeScheduleItemRRuleByweekday0
func (t *UpdateRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item) MergeUpdateRuleResponseObjectSnoozeScheduleItemRRuleByweekday0(v UpdateRuleResponseObjectSnoozeScheduleItemRRuleByweekday0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateRuleResponseObjectSnoozeScheduleItemRRuleByweekday1 returns the union data inside the UpdateRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item as a UpdateRuleResponseObjectSnoozeScheduleItemRRuleByweekday1
func (t UpdateRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item) AsUpdateRuleResponseObjectSnoozeScheduleItemRRuleByweekday1() (UpdateRuleResponseObjectSnoozeScheduleItemRRuleByweekday1, error) {
	var body UpdateRuleResponseObjectSnoozeScheduleItemRRuleByweekday1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateRuleResponseObjectSnoozeScheduleItemRRuleByweekday1 overwrites any union data inside the UpdateRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item as the provided UpdateRuleResponseObjectSnoozeScheduleItemRRuleByweekday1
func (t *UpdateRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item) FromUpdateRuleResponseObjectSnoozeScheduleItemRRuleByweekday1(v UpdateRuleResponseObjectSnoozeScheduleItemRRuleByweekday1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateRuleResponseObjectSnoozeScheduleItemRRuleByweekday1 performs a merge with any union data inside the UpdateRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item, using the provided UpdateRuleResponseObjectSnoozeScheduleItemRRuleByweekday1
func (t *UpdateRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item) MergeUpdateRuleResponseObjectSnoozeScheduleItemRRuleByweekday1(v UpdateRuleResponseObjectSnoozeScheduleItemRRuleByweekday1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UpdateRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UpdateRuleResponseObjectSnoozeScheduleItemRRule_Byweekday_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsIndicatorPropertiesCustomKql returns the union data inside the UpdateSloRequest_Indicator as a IndicatorPropertiesCustomKql
func (t UpdateSloRequest_Indicator) AsIndicatorPropertiesCustomKql() (IndicatorPropertiesCustomKql, error) {
	var body IndicatorPropertiesCustomKql
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndicatorPropertiesCustomKql overwrites any union data inside the UpdateSloRequest_Indicator as the provided IndicatorPropertiesCustomKql
func (t *UpdateSloRequest_Indicator) FromIndicatorPropertiesCustomKql(v IndicatorPropertiesCustomKql) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndicatorPropertiesCustomKql performs a merge with any union data inside the UpdateSloRequest_Indicator, using the provided IndicatorPropertiesCustomKql
func (t *UpdateSloRequest_Indicator) MergeIndicatorPropertiesCustomKql(v IndicatorPropertiesCustomKql) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIndicatorPropertiesApmAvailability returns the union data inside the UpdateSloRequest_Indicator as a IndicatorPropertiesApmAvailability
func (t UpdateSloRequest_Indicator) AsIndicatorPropertiesApmAvailability() (IndicatorPropertiesApmAvailability, error) {
	var body IndicatorPropertiesApmAvailability
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndicatorPropertiesApmAvailability overwrites any union data inside the UpdateSloRequest_Indicator as the provided IndicatorPropertiesApmAvailability
func (t *UpdateSloRequest_Indicator) FromIndicatorPropertiesApmAvailability(v IndicatorPropertiesApmAvailability) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndicatorPropertiesApmAvailability performs a merge with any union data inside the UpdateSloRequest_Indicator, using the provided IndicatorPropertiesApmAvailability
func (t *UpdateSloRequest_Indicator) MergeIndicatorPropertiesApmAvailability(v IndicatorPropertiesApmAvailability) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIndicatorPropertiesApmLatency returns the union data inside the UpdateSloRequest_Indicator as a IndicatorPropertiesApmLatency
func (t UpdateSloRequest_Indicator) AsIndicatorPropertiesApmLatency() (IndicatorPropertiesApmLatency, error) {
	var body IndicatorPropertiesApmLatency
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndicatorPropertiesApmLatency overwrites any union data inside the UpdateSloRequest_Indicator as the provided IndicatorPropertiesApmLatency
func (t *UpdateSloRequest_Indicator) FromIndicatorPropertiesApmLatency(v IndicatorPropertiesApmLatency) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndicatorPropertiesApmLatency performs a merge with any union data inside the UpdateSloRequest_Indicator, using the provided IndicatorPropertiesApmLatency
func (t *UpdateSloRequest_Indicator) MergeIndicatorPropertiesApmLatency(v IndicatorPropertiesApmLatency) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIndicatorPropertiesCustomMetric returns the union data inside the UpdateSloRequest_Indicator as a IndicatorPropertiesCustomMetric
func (t UpdateSloRequest_Indicator) AsIndicatorPropertiesCustomMetric() (IndicatorPropertiesCustomMetric, error) {
	var body IndicatorPropertiesCustomMetric
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndicatorPropertiesCustomMetric overwrites any union data inside the UpdateSloRequest_Indicator as the provided IndicatorPropertiesCustomMetric
func (t *UpdateSloRequest_Indicator) FromIndicatorPropertiesCustomMetric(v IndicatorPropertiesCustomMetric) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndicatorPropertiesCustomMetric performs a merge with any union data inside the UpdateSloRequest_Indicator, using the provided IndicatorPropertiesCustomMetric
func (t *UpdateSloRequest_Indicator) MergeIndicatorPropertiesCustomMetric(v IndicatorPropertiesCustomMetric) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIndicatorPropertiesHistogram returns the union data inside the UpdateSloRequest_Indicator as a IndicatorPropertiesHistogram
func (t UpdateSloRequest_Indicator) AsIndicatorPropertiesHistogram() (IndicatorPropertiesHistogram, error) {
	var body IndicatorPropertiesHistogram
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndicatorPropertiesHistogram overwrites any union data inside the UpdateSloRequest_Indicator as the provided IndicatorPropertiesHistogram
func (t *UpdateSloRequest_Indicator) FromIndicatorPropertiesHistogram(v IndicatorPropertiesHistogram) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndicatorPropertiesHistogram performs a merge with any union data inside the UpdateSloRequest_Indicator, using the provided IndicatorPropertiesHistogram
func (t *UpdateSloRequest_Indicator) MergeIndicatorPropertiesHistogram(v IndicatorPropertiesHistogram) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIndicatorPropertiesTimesliceMetric returns the union data inside the UpdateSloRequest_Indicator as a IndicatorPropertiesTimesliceMetric
func (t UpdateSloRequest_Indicator) AsIndicatorPropertiesTimesliceMetric() (IndicatorPropertiesTimesliceMetric, error) {
	var body IndicatorPropertiesTimesliceMetric
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndicatorPropertiesTimesliceMetric overwrites any union data inside the UpdateSloRequest_Indicator as the provided IndicatorPropertiesTimesliceMetric
func (t *UpdateSloRequest_Indicator) FromIndicatorPropertiesTimesliceMetric(v IndicatorPropertiesTimesliceMetric) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndicatorPropertiesTimesliceMetric performs a merge with any union data inside the UpdateSloRequest_Indicator, using the provided IndicatorPropertiesTimesliceMetric
func (t *UpdateSloRequest_Indicator) MergeIndicatorPropertiesTimesliceMetric(v IndicatorPropertiesTimesliceMetric) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UpdateSloRequest_Indicator) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UpdateSloRequest_Indicator) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// DeleteConnectorDefault request
	DeleteConnectorDefault(ctx context.Context, id string, params *DeleteConnectorDefaultParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConnectorDefault request
	GetConnectorDefault(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateConnectorDefaultWithBody request with any body
	CreateConnectorDefaultWithBody(ctx context.Context, id string, params *CreateConnectorDefaultParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateConnectorDefault(ctx context.Context, id string, params *CreateConnectorDefaultParams, body CreateConnectorDefaultJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateConnectorDefaultWithBody request with any body
	UpdateConnectorDefaultWithBody(ctx context.Context, id string, params *UpdateConnectorDefaultParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateConnectorDefault(ctx context.Context, id string, params *UpdateConnectorDefaultParams, body UpdateConnectorDefaultJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllConnectorsDefault request
	GetAllConnectorsDefault(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRuleDefault request
	DeleteRuleDefault(ctx context.Context, id string, params *DeleteRuleDefaultParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRuleDefault request
	GetRuleDefault(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRuleDefaultWithBody request with any body
	CreateRuleDefaultWithBody(ctx context.Context, id string, params *CreateRuleDefaultParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRuleDefault(ctx context.Context, id string, params *CreateRuleDefaultParams, body CreateRuleDefaultJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRuleDefaultWithBody request with any body
	UpdateRuleDefaultWithBody(ctx context.Context, id string, params *UpdateRuleDefaultParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRuleDefault(ctx context.Context, id string, params *UpdateRuleDefaultParams, body UpdateRuleDefaultJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindRuleDefault request
	FindRuleDefault(ctx context.Context, params *FindRuleDefaultParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllDataViewsDefault request
	GetAllDataViewsDefault(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDataViewDefaultWithBody request with any body
	CreateDataViewDefaultWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDataViewDefault(ctx context.Context, body CreateDataViewDefaultJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDataViewDefault request
	DeleteDataViewDefault(ctx context.Context, viewId ViewId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDataViewDefault request
	GetDataViewDefault(ctx context.Context, viewId ViewId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDataViewDefaultWithBody request with any body
	UpdateDataViewDefaultWithBody(ctx context.Context, viewId ViewId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateDataViewDefault(ctx context.Context, viewId ViewId, body UpdateDataViewDefaultJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AgentPolicyList request
	AgentPolicyList(ctx context.Context, params *AgentPolicyListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAgentPolicyWithBody request with any body
	CreateAgentPolicyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAgentPolicy(ctx context.Context, body CreateAgentPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAgentPolicyWithBody request with any body
	DeleteAgentPolicyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteAgentPolicy(ctx context.Context, body DeleteAgentPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AgentPolicyInfo request
	AgentPolicyInfo(ctx context.Context, agentPolicyId string, params *AgentPolicyInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAgentPolicyWithBody request with any body
	UpdateAgentPolicyWithBody(ctx context.Context, agentPolicyId string, params *UpdateAgentPolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAgentPolicy(ctx context.Context, agentPolicyId string, params *UpdateAgentPolicyParams, body UpdateAgentPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEnrollmentApiKeys request
	GetEnrollmentApiKeys(ctx context.Context, params *GetEnrollmentApiKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAllPackages request
	ListAllPackages(ctx context.Context, params *ListAllPackagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InstallPackageByUploadWithBody request with any body
	InstallPackageByUploadWithBody(ctx context.Context, params *InstallPackageByUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePackageWithBody request with any body
	DeletePackageWithBody(ctx context.Context, pkgName string, pkgVersion string, params *DeletePackageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeletePackage(ctx context.Context, pkgName string, pkgVersion string, params *DeletePackageParams, body DeletePackageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPackage request
	GetPackage(ctx context.Context, pkgName string, pkgVersion string, params *GetPackageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InstallPackageWithBody request with any body
	InstallPackageWithBody(ctx context.Context, pkgName string, pkgVersion string, params *InstallPackageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InstallPackage(ctx context.Context, pkgName string, pkgVersion string, params *InstallPackageParams, body InstallPackageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePackageWithBody request with any body
	UpdatePackageWithBody(ctx context.Context, pkgName string, pkgVersion string, params *UpdatePackageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePackage(ctx context.Context, pkgName string, pkgVersion string, params *UpdatePackageParams, body UpdatePackageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFleetServerHosts request
	GetFleetServerHosts(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostFleetServerHostsWithBody request with any body
	PostFleetServerHostsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostFleetServerHosts(ctx context.Context, body PostFleetServerHostsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFleetServerHosts request
	DeleteFleetServerHosts(ctx context.Context, itemId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOneFleetServerHosts request
	GetOneFleetServerHosts(ctx context.Context, itemId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateFleetServerHostsWithBody request with any body
	UpdateFleetServerHostsWithBody(ctx context.Context, itemId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateFleetServerHosts(ctx context.Context, itemId string, body UpdateFleetServerHostsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOutputs request
	GetOutputs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOutputsWithBody request with any body
	PostOutputsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostOutputs(ctx context.Context, body PostOutputsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteOutput request
	DeleteOutput(ctx context.Context, outputId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOutput request
	GetOutput(ctx context.Context, outputId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateOutputWithBody request with any body
	UpdateOutputWithBody(ctx context.Context, outputId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateOutput(ctx context.Context, outputId string, body UpdateOutputJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPackagePolicies request
	GetPackagePolicies(ctx context.Context, params *GetPackagePoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePackagePolicyWithBody request with any body
	CreatePackagePolicyWithBody(ctx context.Context, params *CreatePackagePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePackagePolicy(ctx context.Context, params *CreatePackagePolicyParams, body CreatePackagePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePackagePolicy request
	DeletePackagePolicy(ctx context.Context, packagePolicyId string, params *DeletePackagePolicyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPackagePolicy request
	GetPackagePolicy(ctx context.Context, packagePolicyId string, params *GetPackagePolicyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePackagePolicyWithBody request with any body
	UpdatePackagePolicyWithBody(ctx context.Context, packagePolicyId string, params *UpdatePackagePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePackagePolicy(ctx context.Context, packagePolicyId string, params *UpdatePackagePolicyParams, body UpdatePackagePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenerateServiceToken request
	GenerateServiceToken(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ImportSavedObjectsDefaultWithBody request with any body
	ImportSavedObjectsDefaultWithBody(ctx context.Context, params *ImportSavedObjectsDefaultParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindSlosOp request
	FindSlosOp(ctx context.Context, spaceId SpaceId, params *FindSlosOpParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSloOpWithBody request with any body
	CreateSloOpWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSloOp(ctx context.Context, spaceId SpaceId, body CreateSloOpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSloOp request
	DeleteSloOp(ctx context.Context, spaceId SpaceId, sloId SloId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSloOp request
	GetSloOp(ctx context.Context, spaceId SpaceId, sloId SloId, params *GetSloOpParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSloOpWithBody request with any body
	UpdateSloOpWithBody(ctx context.Context, spaceId SpaceId, sloId SloId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSloOp(ctx context.Context, spaceId SpaceId, sloId SloId, body UpdateSloOpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) DeleteConnectorDefault(ctx context.Context, id string, params *DeleteConnectorDefaultParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteConnectorDefaultRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConnectorDefault(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConnectorDefaultRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateConnectorDefaultWithBody(ctx context.Context, id string, params *CreateConnectorDefaultParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateConnectorDefaultRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateConnectorDefault(ctx context.Context, id string, params *CreateConnectorDefaultParams, body CreateConnectorDefaultJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateConnectorDefaultRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateConnectorDefaultWithBody(ctx context.Context, id string, params *UpdateConnectorDefaultParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateConnectorDefaultRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateConnectorDefault(ctx context.Context, id string, params *UpdateConnectorDefaultParams, body UpdateConnectorDefaultJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateConnectorDefaultRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllConnectorsDefault(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllConnectorsDefaultRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRuleDefault(ctx context.Context, id string, params *DeleteRuleDefaultParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRuleDefaultRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRuleDefault(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRuleDefaultRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRuleDefaultWithBody(ctx context.Context, id string, params *CreateRuleDefaultParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRuleDefaultRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRuleDefault(ctx context.Context, id string, params *CreateRuleDefaultParams, body CreateRuleDefaultJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRuleDefaultRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRuleDefaultWithBody(ctx context.Context, id string, params *UpdateRuleDefaultParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRuleDefaultRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRuleDefault(ctx context.Context, id string, params *UpdateRuleDefaultParams, body UpdateRuleDefaultJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRuleDefaultRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindRuleDefault(ctx context.Context, params *FindRuleDefaultParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindRuleDefaultRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllDataViewsDefault(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllDataViewsDefaultRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDataViewDefaultWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDataViewDefaultRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDataViewDefault(ctx context.Context, body CreateDataViewDefaultJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDataViewDefaultRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDataViewDefault(ctx context.Context, viewId ViewId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDataViewDefaultRequest(c.Server, viewId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDataViewDefault(ctx context.Context, viewId ViewId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDataViewDefaultRequest(c.Server, viewId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDataViewDefaultWithBody(ctx context.Context, viewId ViewId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDataViewDefaultRequestWithBody(c.Server, viewId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDataViewDefault(ctx context.Context, viewId ViewId, body UpdateDataViewDefaultJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDataViewDefaultRequest(c.Server, viewId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AgentPolicyList(ctx context.Context, params *AgentPolicyListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAgentPolicyListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAgentPolicyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAgentPolicyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAgentPolicy(ctx context.Context, body CreateAgentPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAgentPolicyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAgentPolicyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAgentPolicyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAgentPolicy(ctx context.Context, body DeleteAgentPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAgentPolicyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AgentPolicyInfo(ctx context.Context, agentPolicyId string, params *AgentPolicyInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAgentPolicyInfoRequest(c.Server, agentPolicyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAgentPolicyWithBody(ctx context.Context, agentPolicyId string, params *UpdateAgentPolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAgentPolicyRequestWithBody(c.Server, agentPolicyId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAgentPolicy(ctx context.Context, agentPolicyId string, params *UpdateAgentPolicyParams, body UpdateAgentPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAgentPolicyRequest(c.Server, agentPolicyId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEnrollmentApiKeys(ctx context.Context, params *GetEnrollmentApiKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEnrollmentApiKeysRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAllPackages(ctx context.Context, params *ListAllPackagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAllPackagesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InstallPackageByUploadWithBody(ctx context.Context, params *InstallPackageByUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInstallPackageByUploadRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePackageWithBody(ctx context.Context, pkgName string, pkgVersion string, params *DeletePackageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePackageRequestWithBody(c.Server, pkgName, pkgVersion, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePackage(ctx context.Context, pkgName string, pkgVersion string, params *DeletePackageParams, body DeletePackageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePackageRequest(c.Server, pkgName, pkgVersion, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPackage(ctx context.Context, pkgName string, pkgVersion string, params *GetPackageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPackageRequest(c.Server, pkgName, pkgVersion, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InstallPackageWithBody(ctx context.Context, pkgName string, pkgVersion string, params *InstallPackageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInstallPackageRequestWithBody(c.Server, pkgName, pkgVersion, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InstallPackage(ctx context.Context, pkgName string, pkgVersion string, params *InstallPackageParams, body InstallPackageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInstallPackageRequest(c.Server, pkgName, pkgVersion, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePackageWithBody(ctx context.Context, pkgName string, pkgVersion string, params *UpdatePackageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePackageRequestWithBody(c.Server, pkgName, pkgVersion, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePackage(ctx context.Context, pkgName string, pkgVersion string, params *UpdatePackageParams, body UpdatePackageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePackageRequest(c.Server, pkgName, pkgVersion, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFleetServerHosts(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFleetServerHostsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFleetServerHostsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFleetServerHostsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFleetServerHosts(ctx context.Context, body PostFleetServerHostsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFleetServerHostsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFleetServerHosts(ctx context.Context, itemId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFleetServerHostsRequest(c.Server, itemId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOneFleetServerHosts(ctx context.Context, itemId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOneFleetServerHostsRequest(c.Server, itemId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFleetServerHostsWithBody(ctx context.Context, itemId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFleetServerHostsRequestWithBody(c.Server, itemId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFleetServerHosts(ctx context.Context, itemId string, body UpdateFleetServerHostsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFleetServerHostsRequest(c.Server, itemId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOutputs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOutputsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOutputsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOutputsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOutputs(ctx context.Context, body PostOutputsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOutputsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOutput(ctx context.Context, outputId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOutputRequest(c.Server, outputId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOutput(ctx context.Context, outputId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOutputRequest(c.Server, outputId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOutputWithBody(ctx context.Context, outputId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOutputRequestWithBody(c.Server, outputId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOutput(ctx context.Context, outputId string, body UpdateOutputJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOutputRequest(c.Server, outputId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPackagePolicies(ctx context.Context, params *GetPackagePoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPackagePoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePackagePolicyWithBody(ctx context.Context, params *CreatePackagePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePackagePolicyRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePackagePolicy(ctx context.Context, params *CreatePackagePolicyParams, body CreatePackagePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePackagePolicyRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePackagePolicy(ctx context.Context, packagePolicyId string, params *DeletePackagePolicyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePackagePolicyRequest(c.Server, packagePolicyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPackagePolicy(ctx context.Context, packagePolicyId string, params *GetPackagePolicyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPackagePolicyRequest(c.Server, packagePolicyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePackagePolicyWithBody(ctx context.Context, packagePolicyId string, params *UpdatePackagePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePackagePolicyRequestWithBody(c.Server, packagePolicyId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePackagePolicy(ctx context.Context, packagePolicyId string, params *UpdatePackagePolicyParams, body UpdatePackagePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePackagePolicyRequest(c.Server, packagePolicyId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateServiceToken(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateServiceTokenRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportSavedObjectsDefaultWithBody(ctx context.Context, params *ImportSavedObjectsDefaultParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportSavedObjectsDefaultRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindSlosOp(ctx context.Context, spaceId SpaceId, params *FindSlosOpParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindSlosOpRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSloOpWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSloOpRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSloOp(ctx context.Context, spaceId SpaceId, body CreateSloOpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSloOpRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSloOp(ctx context.Context, spaceId SpaceId, sloId SloId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSloOpRequest(c.Server, spaceId, sloId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSloOp(ctx context.Context, spaceId SpaceId, sloId SloId, params *GetSloOpParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSloOpRequest(c.Server, spaceId, sloId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSloOpWithBody(ctx context.Context, spaceId SpaceId, sloId SloId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSloOpRequestWithBody(c.Server, spaceId, sloId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSloOp(ctx context.Context, spaceId SpaceId, sloId SloId, body UpdateSloOpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSloOpRequest(c.Server, spaceId, sloId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewDeleteConnectorDefaultRequest generates requests for DeleteConnectorDefault
func NewDeleteConnectorDefaultRequest(server string, id string, params *DeleteConnectorDefaultParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/actions/connector/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "kbn-xsrf", runtime.ParamLocationHeader, params.KbnXsrf)
		if err != nil {
			return nil, err
		}

		req.Header.Set("kbn-xsrf", headerParam0)

	}

	return req, nil
}

// NewGetConnectorDefaultRequest generates requests for GetConnectorDefault
func NewGetConnectorDefaultRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/actions/connector/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateConnectorDefaultRequest calls the generic CreateConnectorDefault builder with application/json body
func NewCreateConnectorDefaultRequest(server string, id string, params *CreateConnectorDefaultParams, body CreateConnectorDefaultJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateConnectorDefaultRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewCreateConnectorDefaultRequestWithBody generates requests for CreateConnectorDefault with any type of body
func NewCreateConnectorDefaultRequestWithBody(server string, id string, params *CreateConnectorDefaultParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/actions/connector/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "kbn-xsrf", runtime.ParamLocationHeader, params.KbnXsrf)
		if err != nil {
			return nil, err
		}

		req.Header.Set("kbn-xsrf", headerParam0)

	}

	return req, nil
}

// NewUpdateConnectorDefaultRequest calls the generic UpdateConnectorDefault builder with application/json body
func NewUpdateConnectorDefaultRequest(server string, id string, params *UpdateConnectorDefaultParams, body UpdateConnectorDefaultJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateConnectorDefaultRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdateConnectorDefaultRequestWithBody generates requests for UpdateConnectorDefault with any type of body
func NewUpdateConnectorDefaultRequestWithBody(server string, id string, params *UpdateConnectorDefaultParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/actions/connector/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "kbn-xsrf", runtime.ParamLocationHeader, params.KbnXsrf)
		if err != nil {
			return nil, err
		}

		req.Header.Set("kbn-xsrf", headerParam0)

	}

	return req, nil
}

// NewGetAllConnectorsDefaultRequest generates requests for GetAllConnectorsDefault
func NewGetAllConnectorsDefaultRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/actions/connectors")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteRuleDefaultRequest generates requests for DeleteRuleDefault
func NewDeleteRuleDefaultRequest(server string, id string, params *DeleteRuleDefaultParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/alerting/rule/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "kbn-xsrf", runtime.ParamLocationHeader, params.KbnXsrf)
		if err != nil {
			return nil, err
		}

		req.Header.Set("kbn-xsrf", headerParam0)

	}

	return req, nil
}

// NewGetRuleDefaultRequest generates requests for GetRuleDefault
func NewGetRuleDefaultRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/alerting/rule/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRuleDefaultRequest calls the generic CreateRuleDefault builder with application/json body
func NewCreateRuleDefaultRequest(server string, id string, params *CreateRuleDefaultParams, body CreateRuleDefaultJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRuleDefaultRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewCreateRuleDefaultRequestWithBody generates requests for CreateRuleDefault with any type of body
func NewCreateRuleDefaultRequestWithBody(server string, id string, params *CreateRuleDefaultParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/alerting/rule/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "kbn-xsrf", runtime.ParamLocationHeader, params.KbnXsrf)
		if err != nil {
			return nil, err
		}

		req.Header.Set("kbn-xsrf", headerParam0)

	}

	return req, nil
}

// NewUpdateRuleDefaultRequest calls the generic UpdateRuleDefault builder with application/json body
func NewUpdateRuleDefaultRequest(server string, id string, params *UpdateRuleDefaultParams, body UpdateRuleDefaultJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRuleDefaultRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUpdateRuleDefaultRequestWithBody generates requests for UpdateRuleDefault with any type of body
func NewUpdateRuleDefaultRequestWithBody(server string, id string, params *UpdateRuleDefaultParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/alerting/rule/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "kbn-xsrf", runtime.ParamLocationHeader, params.KbnXsrf)
		if err != nil {
			return nil, err
		}

		req.Header.Set("kbn-xsrf", headerParam0)

	}

	return req, nil
}

// NewFindRuleDefaultRequest generates requests for FindRuleDefault
func NewFindRuleDefaultRequest(server string, params *FindRuleDefaultParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/alerting/rules/_find")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DefaultSearchOperator != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "default_search_operator", runtime.ParamLocationQuery, *params.DefaultSearchOperator); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SearchFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search_fields", runtime.ParamLocationQuery, *params.SearchFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortField != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_field", runtime.ParamLocationQuery, *params.SortField); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortOrder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_order", runtime.ParamLocationQuery, *params.SortOrder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasReference != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "has_reference", runtime.ParamLocationQuery, *params.HasReference); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fields", runtime.ParamLocationQuery, params.Fields); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter_consumers", runtime.ParamLocationQuery, params.FilterConsumers); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllDataViewsDefaultRequest generates requests for GetAllDataViewsDefault
func NewGetAllDataViewsDefaultRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/data_views")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDataViewDefaultRequest calls the generic CreateDataViewDefault builder with application/json body
func NewCreateDataViewDefaultRequest(server string, body CreateDataViewDefaultJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDataViewDefaultRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateDataViewDefaultRequestWithBody generates requests for CreateDataViewDefault with any type of body
func NewCreateDataViewDefaultRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/data_views/data_view")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDataViewDefaultRequest generates requests for DeleteDataViewDefault
func NewDeleteDataViewDefaultRequest(server string, viewId ViewId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "viewId", runtime.ParamLocationPath, viewId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/data_views/data_view/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDataViewDefaultRequest generates requests for GetDataViewDefault
func NewGetDataViewDefaultRequest(server string, viewId ViewId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "viewId", runtime.ParamLocationPath, viewId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/data_views/data_view/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateDataViewDefaultRequest calls the generic UpdateDataViewDefault builder with application/json body
func NewUpdateDataViewDefaultRequest(server string, viewId ViewId, body UpdateDataViewDefaultJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDataViewDefaultRequestWithBody(server, viewId, "application/json", bodyReader)
}

// NewUpdateDataViewDefaultRequestWithBody generates requests for UpdateDataViewDefault with any type of body
func NewUpdateDataViewDefaultRequestWithBody(server string, viewId ViewId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "viewId", runtime.ParamLocationPath, viewId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/data_views/data_view/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAgentPolicyListRequest generates requests for AgentPolicyList
func NewAgentPolicyListRequest(server string, params *AgentPolicyListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/agent_policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Kuery != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kuery", runtime.ParamLocationQuery, *params.Kuery); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Full != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full", runtime.ParamLocationQuery, *params.Full); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NoAgentCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "noAgentCount", runtime.ParamLocationQuery, *params.NoAgentCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAgentPolicyRequest calls the generic CreateAgentPolicy builder with application/json body
func NewCreateAgentPolicyRequest(server string, body CreateAgentPolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAgentPolicyRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAgentPolicyRequestWithBody generates requests for CreateAgentPolicy with any type of body
func NewCreateAgentPolicyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/agent_policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAgentPolicyRequest calls the generic DeleteAgentPolicy builder with application/json body
func NewDeleteAgentPolicyRequest(server string, body DeleteAgentPolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteAgentPolicyRequestWithBody(server, "application/json", bodyReader)
}

// NewDeleteAgentPolicyRequestWithBody generates requests for DeleteAgentPolicy with any type of body
func NewDeleteAgentPolicyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/agent_policies/delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAgentPolicyInfoRequest generates requests for AgentPolicyInfo
func NewAgentPolicyInfoRequest(server string, agentPolicyId string, params *AgentPolicyInfoParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "agentPolicyId", runtime.ParamLocationPath, agentPolicyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/agent_policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAgentPolicyRequest calls the generic UpdateAgentPolicy builder with application/json body
func NewUpdateAgentPolicyRequest(server string, agentPolicyId string, params *UpdateAgentPolicyParams, body UpdateAgentPolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAgentPolicyRequestWithBody(server, agentPolicyId, params, "application/json", bodyReader)
}

// NewUpdateAgentPolicyRequestWithBody generates requests for UpdateAgentPolicy with any type of body
func NewUpdateAgentPolicyRequestWithBody(server string, agentPolicyId string, params *UpdateAgentPolicyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "agentPolicyId", runtime.ParamLocationPath, agentPolicyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/agent_policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetEnrollmentApiKeysRequest generates requests for GetEnrollmentApiKeys
func NewGetEnrollmentApiKeysRequest(server string, params *GetEnrollmentApiKeysParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/enrollment_api_keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Kuery != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kuery", runtime.ParamLocationQuery, *params.Kuery); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllPackagesRequest generates requests for ListAllPackages
func NewListAllPackagesRequest(server string, params *ListAllPackagesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/epm/packages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ExcludeInstallStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludeInstallStatus", runtime.ParamLocationQuery, *params.ExcludeInstallStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Prerelease != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prerelease", runtime.ParamLocationQuery, *params.Prerelease); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Experimental != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "experimental", runtime.ParamLocationQuery, *params.Experimental); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Category != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "category", runtime.ParamLocationQuery, *params.Category); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInstallPackageByUploadRequestWithBody generates requests for InstallPackageByUpload with any type of body
func NewInstallPackageByUploadRequestWithBody(server string, params *InstallPackageByUploadParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/epm/packages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IgnoreMappingUpdateErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ignoreMappingUpdateErrors", runtime.ParamLocationQuery, *params.IgnoreMappingUpdateErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipDataStreamRollover != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipDataStreamRollover", runtime.ParamLocationQuery, *params.SkipDataStreamRollover); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePackageRequest calls the generic DeletePackage builder with application/json body
func NewDeletePackageRequest(server string, pkgName string, pkgVersion string, params *DeletePackageParams, body DeletePackageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeletePackageRequestWithBody(server, pkgName, pkgVersion, params, "application/json", bodyReader)
}

// NewDeletePackageRequestWithBody generates requests for DeletePackage with any type of body
func NewDeletePackageRequestWithBody(server string, pkgName string, pkgVersion string, params *DeletePackageParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pkgName", runtime.ParamLocationPath, pkgName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "pkgVersion", runtime.ParamLocationPath, pkgVersion)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/epm/packages/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Force != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IgnoreUnverified != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ignoreUnverified", runtime.ParamLocationQuery, *params.IgnoreUnverified); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Full != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full", runtime.ParamLocationQuery, *params.Full); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Prerelease != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prerelease", runtime.ParamLocationQuery, *params.Prerelease); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPackageRequest generates requests for GetPackage
func NewGetPackageRequest(server string, pkgName string, pkgVersion string, params *GetPackageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pkgName", runtime.ParamLocationPath, pkgName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "pkgVersion", runtime.ParamLocationPath, pkgVersion)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/epm/packages/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IgnoreUnverified != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ignoreUnverified", runtime.ParamLocationQuery, *params.IgnoreUnverified); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Full != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full", runtime.ParamLocationQuery, *params.Full); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Prerelease != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prerelease", runtime.ParamLocationQuery, *params.Prerelease); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInstallPackageRequest calls the generic InstallPackage builder with application/json body
func NewInstallPackageRequest(server string, pkgName string, pkgVersion string, params *InstallPackageParams, body InstallPackageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInstallPackageRequestWithBody(server, pkgName, pkgVersion, params, "application/json", bodyReader)
}

// NewInstallPackageRequestWithBody generates requests for InstallPackage with any type of body
func NewInstallPackageRequestWithBody(server string, pkgName string, pkgVersion string, params *InstallPackageParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pkgName", runtime.ParamLocationPath, pkgName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "pkgVersion", runtime.ParamLocationPath, pkgVersion)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/epm/packages/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IgnoreMappingUpdateErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ignoreMappingUpdateErrors", runtime.ParamLocationQuery, *params.IgnoreMappingUpdateErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipDataStreamRollover != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipDataStreamRollover", runtime.ParamLocationQuery, *params.SkipDataStreamRollover); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IgnoreUnverified != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ignoreUnverified", runtime.ParamLocationQuery, *params.IgnoreUnverified); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Full != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full", runtime.ParamLocationQuery, *params.Full); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Prerelease != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prerelease", runtime.ParamLocationQuery, *params.Prerelease); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdatePackageRequest calls the generic UpdatePackage builder with application/json body
func NewUpdatePackageRequest(server string, pkgName string, pkgVersion string, params *UpdatePackageParams, body UpdatePackageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePackageRequestWithBody(server, pkgName, pkgVersion, params, "application/json", bodyReader)
}

// NewUpdatePackageRequestWithBody generates requests for UpdatePackage with any type of body
func NewUpdatePackageRequestWithBody(server string, pkgName string, pkgVersion string, params *UpdatePackageParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pkgName", runtime.ParamLocationPath, pkgName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "pkgVersion", runtime.ParamLocationPath, pkgVersion)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/epm/packages/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IgnoreUnverified != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ignoreUnverified", runtime.ParamLocationQuery, *params.IgnoreUnverified); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Full != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full", runtime.ParamLocationQuery, *params.Full); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Prerelease != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prerelease", runtime.ParamLocationQuery, *params.Prerelease); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFleetServerHostsRequest generates requests for GetFleetServerHosts
func NewGetFleetServerHostsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/fleet_server_hosts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostFleetServerHostsRequest calls the generic PostFleetServerHosts builder with application/json body
func NewPostFleetServerHostsRequest(server string, body PostFleetServerHostsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostFleetServerHostsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostFleetServerHostsRequestWithBody generates requests for PostFleetServerHosts with any type of body
func NewPostFleetServerHostsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/fleet_server_hosts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFleetServerHostsRequest generates requests for DeleteFleetServerHosts
func NewDeleteFleetServerHostsRequest(server string, itemId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/fleet_server_hosts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOneFleetServerHostsRequest generates requests for GetOneFleetServerHosts
func NewGetOneFleetServerHostsRequest(server string, itemId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/fleet_server_hosts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateFleetServerHostsRequest calls the generic UpdateFleetServerHosts builder with application/json body
func NewUpdateFleetServerHostsRequest(server string, itemId string, body UpdateFleetServerHostsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateFleetServerHostsRequestWithBody(server, itemId, "application/json", bodyReader)
}

// NewUpdateFleetServerHostsRequestWithBody generates requests for UpdateFleetServerHosts with any type of body
func NewUpdateFleetServerHostsRequestWithBody(server string, itemId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/fleet_server_hosts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetOutputsRequest generates requests for GetOutputs
func NewGetOutputsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/outputs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostOutputsRequest calls the generic PostOutputs builder with application/json body
func NewPostOutputsRequest(server string, body PostOutputsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostOutputsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostOutputsRequestWithBody generates requests for PostOutputs with any type of body
func NewPostOutputsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/outputs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOutputRequest generates requests for DeleteOutput
func NewDeleteOutputRequest(server string, outputId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "outputId", runtime.ParamLocationPath, outputId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/outputs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOutputRequest generates requests for GetOutput
func NewGetOutputRequest(server string, outputId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "outputId", runtime.ParamLocationPath, outputId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/outputs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateOutputRequest calls the generic UpdateOutput builder with application/json body
func NewUpdateOutputRequest(server string, outputId string, body UpdateOutputJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOutputRequestWithBody(server, outputId, "application/json", bodyReader)
}

// NewUpdateOutputRequestWithBody generates requests for UpdateOutput with any type of body
func NewUpdateOutputRequestWithBody(server string, outputId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "outputId", runtime.ParamLocationPath, outputId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/outputs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPackagePoliciesRequest generates requests for GetPackagePolicies
func NewGetPackagePoliciesRequest(server string, params *GetPackagePoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/package_policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Kuery != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kuery", runtime.ParamLocationQuery, *params.Kuery); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePackagePolicyRequest calls the generic CreatePackagePolicy builder with application/json body
func NewCreatePackagePolicyRequest(server string, params *CreatePackagePolicyParams, body CreatePackagePolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePackagePolicyRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreatePackagePolicyRequestWithBody generates requests for CreatePackagePolicy with any type of body
func NewCreatePackagePolicyRequestWithBody(server string, params *CreatePackagePolicyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/package_policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePackagePolicyRequest generates requests for DeletePackagePolicy
func NewDeletePackagePolicyRequest(server string, packagePolicyId string, params *DeletePackagePolicyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "packagePolicyId", runtime.ParamLocationPath, packagePolicyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/package_policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Force != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPackagePolicyRequest generates requests for GetPackagePolicy
func NewGetPackagePolicyRequest(server string, packagePolicyId string, params *GetPackagePolicyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "packagePolicyId", runtime.ParamLocationPath, packagePolicyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/package_policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePackagePolicyRequest calls the generic UpdatePackagePolicy builder with application/json body
func NewUpdatePackagePolicyRequest(server string, packagePolicyId string, params *UpdatePackagePolicyParams, body UpdatePackagePolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePackagePolicyRequestWithBody(server, packagePolicyId, params, "application/json", bodyReader)
}

// NewUpdatePackagePolicyRequestWithBody generates requests for UpdatePackagePolicy with any type of body
func NewUpdatePackagePolicyRequestWithBody(server string, packagePolicyId string, params *UpdatePackagePolicyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "packagePolicyId", runtime.ParamLocationPath, packagePolicyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/package_policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGenerateServiceTokenRequest generates requests for GenerateServiceToken
func NewGenerateServiceTokenRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/service_tokens")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewImportSavedObjectsDefaultRequestWithBody generates requests for ImportSavedObjectsDefault with any type of body
func NewImportSavedObjectsDefaultRequestWithBody(server string, params *ImportSavedObjectsDefaultParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/saved_objects/_import")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CreateNewCopies != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createNewCopies", runtime.ParamLocationQuery, *params.CreateNewCopies); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Overwrite != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "overwrite", runtime.ParamLocationQuery, *params.Overwrite); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CompatibilityMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "compatibilityMode", runtime.ParamLocationQuery, *params.CompatibilityMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindSlosOpRequest generates requests for FindSlosOp
func NewFindSlosOpRequest(server string, spaceId SpaceId, params *FindSlosOpParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/s/%s/api/observability/slos", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.KqlQuery != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kqlQuery", runtime.ParamLocationQuery, *params.KqlQuery); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortBy", runtime.ParamLocationQuery, *params.SortBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortDirection", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HideStale != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hideStale", runtime.ParamLocationQuery, *params.HideStale); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSloOpRequest calls the generic CreateSloOp builder with application/json body
func NewCreateSloOpRequest(server string, spaceId SpaceId, body CreateSloOpJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSloOpRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateSloOpRequestWithBody generates requests for CreateSloOp with any type of body
func NewCreateSloOpRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/s/%s/api/observability/slos", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSloOpRequest generates requests for DeleteSloOp
func NewDeleteSloOpRequest(server string, spaceId SpaceId, sloId SloId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sloId", runtime.ParamLocationPath, sloId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/s/%s/api/observability/slos/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSloOpRequest generates requests for GetSloOp
func NewGetSloOpRequest(server string, spaceId SpaceId, sloId SloId, params *GetSloOpParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sloId", runtime.ParamLocationPath, sloId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/s/%s/api/observability/slos/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.InstanceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "instanceId", runtime.ParamLocationQuery, *params.InstanceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSloOpRequest calls the generic UpdateSloOp builder with application/json body
func NewUpdateSloOpRequest(server string, spaceId SpaceId, sloId SloId, body UpdateSloOpJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSloOpRequestWithBody(server, spaceId, sloId, "application/json", bodyReader)
}

// NewUpdateSloOpRequestWithBody generates requests for UpdateSloOp with any type of body
func NewUpdateSloOpRequestWithBody(server string, spaceId SpaceId, sloId SloId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sloId", runtime.ParamLocationPath, sloId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/s/%s/api/observability/slos/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// DeleteConnectorDefaultWithResponse request
	DeleteConnectorDefaultWithResponse(ctx context.Context, id string, params *DeleteConnectorDefaultParams, reqEditors ...RequestEditorFn) (*DeleteConnectorDefaultResponse, error)

	// GetConnectorDefaultWithResponse request
	GetConnectorDefaultWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetConnectorDefaultResponse, error)

	// CreateConnectorDefaultWithBodyWithResponse request with any body
	CreateConnectorDefaultWithBodyWithResponse(ctx context.Context, id string, params *CreateConnectorDefaultParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateConnectorDefaultResponse, error)

	CreateConnectorDefaultWithResponse(ctx context.Context, id string, params *CreateConnectorDefaultParams, body CreateConnectorDefaultJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateConnectorDefaultResponse, error)

	// UpdateConnectorDefaultWithBodyWithResponse request with any body
	UpdateConnectorDefaultWithBodyWithResponse(ctx context.Context, id string, params *UpdateConnectorDefaultParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateConnectorDefaultResponse, error)

	UpdateConnectorDefaultWithResponse(ctx context.Context, id string, params *UpdateConnectorDefaultParams, body UpdateConnectorDefaultJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateConnectorDefaultResponse, error)

	// GetAllConnectorsDefaultWithResponse request
	GetAllConnectorsDefaultWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllConnectorsDefaultResponse, error)

	// DeleteRuleDefaultWithResponse request
	DeleteRuleDefaultWithResponse(ctx context.Context, id string, params *DeleteRuleDefaultParams, reqEditors ...RequestEditorFn) (*DeleteRuleDefaultResponse, error)

	// GetRuleDefaultWithResponse request
	GetRuleDefaultWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetRuleDefaultResponse, error)

	// CreateRuleDefaultWithBodyWithResponse request with any body
	CreateRuleDefaultWithBodyWithResponse(ctx context.Context, id string, params *CreateRuleDefaultParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRuleDefaultResponse, error)

	CreateRuleDefaultWithResponse(ctx context.Context, id string, params *CreateRuleDefaultParams, body CreateRuleDefaultJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRuleDefaultResponse, error)

	// UpdateRuleDefaultWithBodyWithResponse request with any body
	UpdateRuleDefaultWithBodyWithResponse(ctx context.Context, id string, params *UpdateRuleDefaultParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRuleDefaultResponse, error)

	UpdateRuleDefaultWithResponse(ctx context.Context, id string, params *UpdateRuleDefaultParams, body UpdateRuleDefaultJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRuleDefaultResponse, error)

	// FindRuleDefaultWithResponse request
	FindRuleDefaultWithResponse(ctx context.Context, params *FindRuleDefaultParams, reqEditors ...RequestEditorFn) (*FindRuleDefaultResponse, error)

	// GetAllDataViewsDefaultWithResponse request
	GetAllDataViewsDefaultWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllDataViewsDefaultResponse, error)

	// CreateDataViewDefaultWithBodyWithResponse request with any body
	CreateDataViewDefaultWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDataViewDefaultResponse, error)

	CreateDataViewDefaultWithResponse(ctx context.Context, body CreateDataViewDefaultJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDataViewDefaultResponse, error)

	// DeleteDataViewDefaultWithResponse request
	DeleteDataViewDefaultWithResponse(ctx context.Context, viewId ViewId, reqEditors ...RequestEditorFn) (*DeleteDataViewDefaultResponse, error)

	// GetDataViewDefaultWithResponse request
	GetDataViewDefaultWithResponse(ctx context.Context, viewId ViewId, reqEditors ...RequestEditorFn) (*GetDataViewDefaultResponse, error)

	// UpdateDataViewDefaultWithBodyWithResponse request with any body
	UpdateDataViewDefaultWithBodyWithResponse(ctx context.Context, viewId ViewId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDataViewDefaultResponse, error)

	UpdateDataViewDefaultWithResponse(ctx context.Context, viewId ViewId, body UpdateDataViewDefaultJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDataViewDefaultResponse, error)

	// AgentPolicyListWithResponse request
	AgentPolicyListWithResponse(ctx context.Context, params *AgentPolicyListParams, reqEditors ...RequestEditorFn) (*AgentPolicyListResponse, error)

	// CreateAgentPolicyWithBodyWithResponse request with any body
	CreateAgentPolicyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAgentPolicyResponse, error)

	CreateAgentPolicyWithResponse(ctx context.Context, body CreateAgentPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAgentPolicyResponse, error)

	// DeleteAgentPolicyWithBodyWithResponse request with any body
	DeleteAgentPolicyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteAgentPolicyResponse, error)

	DeleteAgentPolicyWithResponse(ctx context.Context, body DeleteAgentPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteAgentPolicyResponse, error)

	// AgentPolicyInfoWithResponse request
	AgentPolicyInfoWithResponse(ctx context.Context, agentPolicyId string, params *AgentPolicyInfoParams, reqEditors ...RequestEditorFn) (*AgentPolicyInfoResponse, error)

	// UpdateAgentPolicyWithBodyWithResponse request with any body
	UpdateAgentPolicyWithBodyWithResponse(ctx context.Context, agentPolicyId string, params *UpdateAgentPolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAgentPolicyResponse, error)

	UpdateAgentPolicyWithResponse(ctx context.Context, agentPolicyId string, params *UpdateAgentPolicyParams, body UpdateAgentPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAgentPolicyResponse, error)

	// GetEnrollmentApiKeysWithResponse request
	GetEnrollmentApiKeysWithResponse(ctx context.Context, params *GetEnrollmentApiKeysParams, reqEditors ...RequestEditorFn) (*GetEnrollmentApiKeysResponse, error)

	// ListAllPackagesWithResponse request
	ListAllPackagesWithResponse(ctx context.Context, params *ListAllPackagesParams, reqEditors ...RequestEditorFn) (*ListAllPackagesResponse, error)

	// InstallPackageByUploadWithBodyWithResponse request with any body
	InstallPackageByUploadWithBodyWithResponse(ctx context.Context, params *InstallPackageByUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InstallPackageByUploadResponse, error)

	// DeletePackageWithBodyWithResponse request with any body
	DeletePackageWithBodyWithResponse(ctx context.Context, pkgName string, pkgVersion string, params *DeletePackageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeletePackageResponse, error)

	DeletePackageWithResponse(ctx context.Context, pkgName string, pkgVersion string, params *DeletePackageParams, body DeletePackageJSONRequestBody, reqEditors ...RequestEditorFn) (*DeletePackageResponse, error)

	// GetPackageWithResponse request
	GetPackageWithResponse(ctx context.Context, pkgName string, pkgVersion string, params *GetPackageParams, reqEditors ...RequestEditorFn) (*GetPackageResponse, error)

	// InstallPackageWithBodyWithResponse request with any body
	InstallPackageWithBodyWithResponse(ctx context.Context, pkgName string, pkgVersion string, params *InstallPackageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InstallPackageResponse, error)

	InstallPackageWithResponse(ctx context.Context, pkgName string, pkgVersion string, params *InstallPackageParams, body InstallPackageJSONRequestBody, reqEditors ...RequestEditorFn) (*InstallPackageResponse, error)

	// UpdatePackageWithBodyWithResponse request with any body
	UpdatePackageWithBodyWithResponse(ctx context.Context, pkgName string, pkgVersion string, params *UpdatePackageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePackageResponse, error)

	UpdatePackageWithResponse(ctx context.Context, pkgName string, pkgVersion string, params *UpdatePackageParams, body UpdatePackageJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePackageResponse, error)

	// GetFleetServerHostsWithResponse request
	GetFleetServerHostsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetFleetServerHostsResponse, error)

	// PostFleetServerHostsWithBodyWithResponse request with any body
	PostFleetServerHostsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFleetServerHostsResponse, error)

	PostFleetServerHostsWithResponse(ctx context.Context, body PostFleetServerHostsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFleetServerHostsResponse, error)

	// DeleteFleetServerHostsWithResponse request
	DeleteFleetServerHostsWithResponse(ctx context.Context, itemId string, reqEditors ...RequestEditorFn) (*DeleteFleetServerHostsResponse, error)

	// GetOneFleetServerHostsWithResponse request
	GetOneFleetServerHostsWithResponse(ctx context.Context, itemId string, reqEditors ...RequestEditorFn) (*GetOneFleetServerHostsResponse, error)

	// UpdateFleetServerHostsWithBodyWithResponse request with any body
	UpdateFleetServerHostsWithBodyWithResponse(ctx context.Context, itemId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFleetServerHostsResponse, error)

	UpdateFleetServerHostsWithResponse(ctx context.Context, itemId string, body UpdateFleetServerHostsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFleetServerHostsResponse, error)

	// GetOutputsWithResponse request
	GetOutputsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOutputsResponse, error)

	// PostOutputsWithBodyWithResponse request with any body
	PostOutputsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOutputsResponse, error)

	PostOutputsWithResponse(ctx context.Context, body PostOutputsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOutputsResponse, error)

	// DeleteOutputWithResponse request
	DeleteOutputWithResponse(ctx context.Context, outputId string, reqEditors ...RequestEditorFn) (*DeleteOutputResponse, error)

	// GetOutputWithResponse request
	GetOutputWithResponse(ctx context.Context, outputId string, reqEditors ...RequestEditorFn) (*GetOutputResponse, error)

	// UpdateOutputWithBodyWithResponse request with any body
	UpdateOutputWithBodyWithResponse(ctx context.Context, outputId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOutputResponse, error)

	UpdateOutputWithResponse(ctx context.Context, outputId string, body UpdateOutputJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOutputResponse, error)

	// GetPackagePoliciesWithResponse request
	GetPackagePoliciesWithResponse(ctx context.Context, params *GetPackagePoliciesParams, reqEditors ...RequestEditorFn) (*GetPackagePoliciesResponse, error)

	// CreatePackagePolicyWithBodyWithResponse request with any body
	CreatePackagePolicyWithBodyWithResponse(ctx context.Context, params *CreatePackagePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePackagePolicyResponse, error)

	CreatePackagePolicyWithResponse(ctx context.Context, params *CreatePackagePolicyParams, body CreatePackagePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePackagePolicyResponse, error)

	// DeletePackagePolicyWithResponse request
	DeletePackagePolicyWithResponse(ctx context.Context, packagePolicyId string, params *DeletePackagePolicyParams, reqEditors ...RequestEditorFn) (*DeletePackagePolicyResponse, error)

	// GetPackagePolicyWithResponse request
	GetPackagePolicyWithResponse(ctx context.Context, packagePolicyId string, params *GetPackagePolicyParams, reqEditors ...RequestEditorFn) (*GetPackagePolicyResponse, error)

	// UpdatePackagePolicyWithBodyWithResponse request with any body
	UpdatePackagePolicyWithBodyWithResponse(ctx context.Context, packagePolicyId string, params *UpdatePackagePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePackagePolicyResponse, error)

	UpdatePackagePolicyWithResponse(ctx context.Context, packagePolicyId string, params *UpdatePackagePolicyParams, body UpdatePackagePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePackagePolicyResponse, error)

	// GenerateServiceTokenWithResponse request
	GenerateServiceTokenWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GenerateServiceTokenResponse, error)

	// ImportSavedObjectsDefaultWithBodyWithResponse request with any body
	ImportSavedObjectsDefaultWithBodyWithResponse(ctx context.Context, params *ImportSavedObjectsDefaultParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportSavedObjectsDefaultResponse, error)

	// FindSlosOpWithResponse request
	FindSlosOpWithResponse(ctx context.Context, spaceId SpaceId, params *FindSlosOpParams, reqEditors ...RequestEditorFn) (*FindSlosOpResponse, error)

	// CreateSloOpWithBodyWithResponse request with any body
	CreateSloOpWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSloOpResponse, error)

	CreateSloOpWithResponse(ctx context.Context, spaceId SpaceId, body CreateSloOpJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSloOpResponse, error)

	// DeleteSloOpWithResponse request
	DeleteSloOpWithResponse(ctx context.Context, spaceId SpaceId, sloId SloId, reqEditors ...RequestEditorFn) (*DeleteSloOpResponse, error)

	// GetSloOpWithResponse request
	GetSloOpWithResponse(ctx context.Context, spaceId SpaceId, sloId SloId, params *GetSloOpParams, reqEditors ...RequestEditorFn) (*GetSloOpResponse, error)

	// UpdateSloOpWithBodyWithResponse request with any body
	UpdateSloOpWithBodyWithResponse(ctx context.Context, spaceId SpaceId, sloId SloId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSloOpResponse, error)

	UpdateSloOpWithResponse(ctx context.Context, spaceId SpaceId, sloId SloId, body UpdateSloOpJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSloOpResponse, error)
}

type DeleteConnectorDefaultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteConnectorDefaultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteConnectorDefaultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConnectorDefaultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetConnectorResponseObject
}

// Status returns HTTPResponse.Status
func (r GetConnectorDefaultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConnectorDefaultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateConnectorDefaultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateConnectorResponseObject
}

// Status returns HTTPResponse.Status
func (r CreateConnectorDefaultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateConnectorDefaultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateConnectorDefaultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateConnectorResponseObject
}

// Status returns HTTPResponse.Status
func (r UpdateConnectorDefaultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateConnectorDefaultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllConnectorsDefaultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetAllConnectorsDefaultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllConnectorsDefaultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRuleDefaultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteRuleDefaultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRuleDefaultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRuleDefaultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetRuleResponseObject
}

// Status returns HTTPResponse.Status
func (r GetRuleDefaultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRuleDefaultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRuleDefaultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateRuleResponseObject
}

// Status returns HTTPResponse.Status
func (r CreateRuleDefaultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRuleDefaultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRuleDefaultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateRuleResponseObject
}

// Status returns HTTPResponse.Status
func (r UpdateRuleDefaultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRuleDefaultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindRuleDefaultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FindRuleResponseObject
}

// Status returns HTTPResponse.Status
func (r FindRuleDefaultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindRuleDefaultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllDataViewsDefaultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetAllDataViewsResponseObject
}

// Status returns HTTPResponse.Status
func (r GetAllDataViewsDefaultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllDataViewsDefaultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDataViewDefaultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DataViewResponseObject
}

// Status returns HTTPResponse.Status
func (r CreateDataViewDefaultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDataViewDefaultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDataViewDefaultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteDataViewDefaultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDataViewDefaultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDataViewDefaultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DataViewResponseObject
}

// Status returns HTTPResponse.Status
func (r GetDataViewDefaultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDataViewDefaultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateDataViewDefaultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DataViewResponseObject
}

// Status returns HTTPResponse.Status
func (r UpdateDataViewDefaultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDataViewDefaultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AgentPolicyListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AgentPolicyListResponseObject
}

// Status returns HTTPResponse.Status
func (r AgentPolicyListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AgentPolicyListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAgentPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateAgentPolicyResponseObject
}

// Status returns HTTPResponse.Status
func (r CreateAgentPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAgentPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAgentPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeleteAgentPolicyResponseObject
}

// Status returns HTTPResponse.Status
func (r DeleteAgentPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAgentPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AgentPolicyInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AgentPolicyInfoResponseObject
}

// Status returns HTTPResponse.Status
func (r AgentPolicyInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AgentPolicyInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAgentPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateAgentPolicyResponseObject
}

// Status returns HTTPResponse.Status
func (r UpdateAgentPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAgentPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEnrollmentApiKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetEnrollmentApiKeysResponseObject
}

// Status returns HTTPResponse.Status
func (r GetEnrollmentApiKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEnrollmentApiKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAllPackagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetPackagesResponse
}

// Status returns HTTPResponse.Status
func (r ListAllPackagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAllPackagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InstallPackageByUploadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InstallPackageByUploadResponseObject
}

// Status returns HTTPResponse.Status
func (r InstallPackageByUploadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InstallPackageByUploadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePackageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeletePackageResponseObject
}

// Status returns HTTPResponse.Status
func (r DeletePackageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePackageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPackageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetPackageResponseObject
}

// Status returns HTTPResponse.Status
func (r GetPackageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPackageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InstallPackageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InstallPackageResponseObject
}

// Status returns HTTPResponse.Status
func (r InstallPackageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InstallPackageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePackageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdatePackageResponseObject
}

// Status returns HTTPResponse.Status
func (r UpdatePackageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePackageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFleetServerHostsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetFleetServerHostsResponseObject
}

// Status returns HTTPResponse.Status
func (r GetFleetServerHostsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFleetServerHostsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostFleetServerHostsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostFleetServerHostsResponseObject
}

// Status returns HTTPResponse.Status
func (r PostFleetServerHostsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostFleetServerHostsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFleetServerHostsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeleteFleetServerHostsResponseObject
}

// Status returns HTTPResponse.Status
func (r DeleteFleetServerHostsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFleetServerHostsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOneFleetServerHostsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetOneFleetServerHostsResponseObject
}

// Status returns HTTPResponse.Status
func (r GetOneFleetServerHostsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOneFleetServerHostsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateFleetServerHostsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateFleetServerHostsResponseObject
}

// Status returns HTTPResponse.Status
func (r UpdateFleetServerHostsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateFleetServerHostsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOutputsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetOutputsResponseObject
}

// Status returns HTTPResponse.Status
func (r GetOutputsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOutputsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOutputsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostOutputsResponseObject
}

// Status returns HTTPResponse.Status
func (r PostOutputsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOutputsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOutputResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeleteOutputResponseObject
}

// Status returns HTTPResponse.Status
func (r DeleteOutputResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOutputResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOutputResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetOutputResponseObject
}

// Status returns HTTPResponse.Status
func (r GetOutputResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOutputResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOutputResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateOutputResponseObject
}

// Status returns HTTPResponse.Status
func (r UpdateOutputResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOutputResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPackagePoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetPackagePoliciesResponseObject
}

// Status returns HTTPResponse.Status
func (r GetPackagePoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPackagePoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePackagePolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreatePackagePolicyResponseObject
}

// Status returns HTTPResponse.Status
func (r CreatePackagePolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePackagePolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePackagePolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeletePackagePolicyResponseObject
}

// Status returns HTTPResponse.Status
func (r DeletePackagePolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePackagePolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPackagePolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetPackagePolicyResponseObject
}

// Status returns HTTPResponse.Status
func (r GetPackagePolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPackagePolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePackagePolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdatePackagePolicyResponseObject
}

// Status returns HTTPResponse.Status
func (r UpdatePackagePolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePackagePolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenerateServiceTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GenerateServiceTokenResponseObject
}

// Status returns HTTPResponse.Status
func (r GenerateServiceTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenerateServiceTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ImportSavedObjectsDefaultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ImportSavedObjectsResponseObject
}

// Status returns HTTPResponse.Status
func (r ImportSavedObjectsDefaultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ImportSavedObjectsDefaultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindSlosOpResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FindSloResponse
}

// Status returns HTTPResponse.Status
func (r FindSlosOpResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindSlosOpResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSloOpResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateSloResponse
}

// Status returns HTTPResponse.Status
func (r CreateSloOpResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSloOpResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSloOpResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteSloOpResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSloOpResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSloOpResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SloWithSummaryResponse
}

// Status returns HTTPResponse.Status
func (r GetSloOpResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSloOpResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSloOpResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SloDefinitionResponse
}

// Status returns HTTPResponse.Status
func (r UpdateSloOpResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSloOpResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// DeleteConnectorDefaultWithResponse request returning *DeleteConnectorDefaultResponse
func (c *ClientWithResponses) DeleteConnectorDefaultWithResponse(ctx context.Context, id string, params *DeleteConnectorDefaultParams, reqEditors ...RequestEditorFn) (*DeleteConnectorDefaultResponse, error) {
	rsp, err := c.DeleteConnectorDefault(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteConnectorDefaultResponse(rsp)
}

// GetConnectorDefaultWithResponse request returning *GetConnectorDefaultResponse
func (c *ClientWithResponses) GetConnectorDefaultWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetConnectorDefaultResponse, error) {
	rsp, err := c.GetConnectorDefault(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConnectorDefaultResponse(rsp)
}

// CreateConnectorDefaultWithBodyWithResponse request with arbitrary body returning *CreateConnectorDefaultResponse
func (c *ClientWithResponses) CreateConnectorDefaultWithBodyWithResponse(ctx context.Context, id string, params *CreateConnectorDefaultParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateConnectorDefaultResponse, error) {
	rsp, err := c.CreateConnectorDefaultWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateConnectorDefaultResponse(rsp)
}

func (c *ClientWithResponses) CreateConnectorDefaultWithResponse(ctx context.Context, id string, params *CreateConnectorDefaultParams, body CreateConnectorDefaultJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateConnectorDefaultResponse, error) {
	rsp, err := c.CreateConnectorDefault(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateConnectorDefaultResponse(rsp)
}

// UpdateConnectorDefaultWithBodyWithResponse request with arbitrary body returning *UpdateConnectorDefaultResponse
func (c *ClientWithResponses) UpdateConnectorDefaultWithBodyWithResponse(ctx context.Context, id string, params *UpdateConnectorDefaultParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateConnectorDefaultResponse, error) {
	rsp, err := c.UpdateConnectorDefaultWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateConnectorDefaultResponse(rsp)
}

func (c *ClientWithResponses) UpdateConnectorDefaultWithResponse(ctx context.Context, id string, params *UpdateConnectorDefaultParams, body UpdateConnectorDefaultJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateConnectorDefaultResponse, error) {
	rsp, err := c.UpdateConnectorDefault(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateConnectorDefaultResponse(rsp)
}

// GetAllConnectorsDefaultWithResponse request returning *GetAllConnectorsDefaultResponse
func (c *ClientWithResponses) GetAllConnectorsDefaultWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllConnectorsDefaultResponse, error) {
	rsp, err := c.GetAllConnectorsDefault(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllConnectorsDefaultResponse(rsp)
}

// DeleteRuleDefaultWithResponse request returning *DeleteRuleDefaultResponse
func (c *ClientWithResponses) DeleteRuleDefaultWithResponse(ctx context.Context, id string, params *DeleteRuleDefaultParams, reqEditors ...RequestEditorFn) (*DeleteRuleDefaultResponse, error) {
	rsp, err := c.DeleteRuleDefault(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRuleDefaultResponse(rsp)
}

// GetRuleDefaultWithResponse request returning *GetRuleDefaultResponse
func (c *ClientWithResponses) GetRuleDefaultWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetRuleDefaultResponse, error) {
	rsp, err := c.GetRuleDefault(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRuleDefaultResponse(rsp)
}

// CreateRuleDefaultWithBodyWithResponse request with arbitrary body returning *CreateRuleDefaultResponse
func (c *ClientWithResponses) CreateRuleDefaultWithBodyWithResponse(ctx context.Context, id string, params *CreateRuleDefaultParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRuleDefaultResponse, error) {
	rsp, err := c.CreateRuleDefaultWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRuleDefaultResponse(rsp)
}

func (c *ClientWithResponses) CreateRuleDefaultWithResponse(ctx context.Context, id string, params *CreateRuleDefaultParams, body CreateRuleDefaultJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRuleDefaultResponse, error) {
	rsp, err := c.CreateRuleDefault(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRuleDefaultResponse(rsp)
}

// UpdateRuleDefaultWithBodyWithResponse request with arbitrary body returning *UpdateRuleDefaultResponse
func (c *ClientWithResponses) UpdateRuleDefaultWithBodyWithResponse(ctx context.Context, id string, params *UpdateRuleDefaultParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRuleDefaultResponse, error) {
	rsp, err := c.UpdateRuleDefaultWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRuleDefaultResponse(rsp)
}

func (c *ClientWithResponses) UpdateRuleDefaultWithResponse(ctx context.Context, id string, params *UpdateRuleDefaultParams, body UpdateRuleDefaultJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRuleDefaultResponse, error) {
	rsp, err := c.UpdateRuleDefault(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRuleDefaultResponse(rsp)
}

// FindRuleDefaultWithResponse request returning *FindRuleDefaultResponse
func (c *ClientWithResponses) FindRuleDefaultWithResponse(ctx context.Context, params *FindRuleDefaultParams, reqEditors ...RequestEditorFn) (*FindRuleDefaultResponse, error) {
	rsp, err := c.FindRuleDefault(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindRuleDefaultResponse(rsp)
}

// GetAllDataViewsDefaultWithResponse request returning *GetAllDataViewsDefaultResponse
func (c *ClientWithResponses) GetAllDataViewsDefaultWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllDataViewsDefaultResponse, error) {
	rsp, err := c.GetAllDataViewsDefault(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllDataViewsDefaultResponse(rsp)
}

// CreateDataViewDefaultWithBodyWithResponse request with arbitrary body returning *CreateDataViewDefaultResponse
func (c *ClientWithResponses) CreateDataViewDefaultWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDataViewDefaultResponse, error) {
	rsp, err := c.CreateDataViewDefaultWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDataViewDefaultResponse(rsp)
}

func (c *ClientWithResponses) CreateDataViewDefaultWithResponse(ctx context.Context, body CreateDataViewDefaultJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDataViewDefaultResponse, error) {
	rsp, err := c.CreateDataViewDefault(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDataViewDefaultResponse(rsp)
}

// DeleteDataViewDefaultWithResponse request returning *DeleteDataViewDefaultResponse
func (c *ClientWithResponses) DeleteDataViewDefaultWithResponse(ctx context.Context, viewId ViewId, reqEditors ...RequestEditorFn) (*DeleteDataViewDefaultResponse, error) {
	rsp, err := c.DeleteDataViewDefault(ctx, viewId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDataViewDefaultResponse(rsp)
}

// GetDataViewDefaultWithResponse request returning *GetDataViewDefaultResponse
func (c *ClientWithResponses) GetDataViewDefaultWithResponse(ctx context.Context, viewId ViewId, reqEditors ...RequestEditorFn) (*GetDataViewDefaultResponse, error) {
	rsp, err := c.GetDataViewDefault(ctx, viewId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDataViewDefaultResponse(rsp)
}

// UpdateDataViewDefaultWithBodyWithResponse request with arbitrary body returning *UpdateDataViewDefaultResponse
func (c *ClientWithResponses) UpdateDataViewDefaultWithBodyWithResponse(ctx context.Context, viewId ViewId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDataViewDefaultResponse, error) {
	rsp, err := c.UpdateDataViewDefaultWithBody(ctx, viewId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDataViewDefaultResponse(rsp)
}

func (c *ClientWithResponses) UpdateDataViewDefaultWithResponse(ctx context.Context, viewId ViewId, body UpdateDataViewDefaultJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDataViewDefaultResponse, error) {
	rsp, err := c.UpdateDataViewDefault(ctx, viewId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDataViewDefaultResponse(rsp)
}

// AgentPolicyListWithResponse request returning *AgentPolicyListResponse
func (c *ClientWithResponses) AgentPolicyListWithResponse(ctx context.Context, params *AgentPolicyListParams, reqEditors ...RequestEditorFn) (*AgentPolicyListResponse, error) {
	rsp, err := c.AgentPolicyList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAgentPolicyListResponse(rsp)
}

// CreateAgentPolicyWithBodyWithResponse request with arbitrary body returning *CreateAgentPolicyResponse
func (c *ClientWithResponses) CreateAgentPolicyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAgentPolicyResponse, error) {
	rsp, err := c.CreateAgentPolicyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAgentPolicyResponse(rsp)
}

func (c *ClientWithResponses) CreateAgentPolicyWithResponse(ctx context.Context, body CreateAgentPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAgentPolicyResponse, error) {
	rsp, err := c.CreateAgentPolicy(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAgentPolicyResponse(rsp)
}

// DeleteAgentPolicyWithBodyWithResponse request with arbitrary body returning *DeleteAgentPolicyResponse
func (c *ClientWithResponses) DeleteAgentPolicyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteAgentPolicyResponse, error) {
	rsp, err := c.DeleteAgentPolicyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAgentPolicyResponse(rsp)
}

func (c *ClientWithResponses) DeleteAgentPolicyWithResponse(ctx context.Context, body DeleteAgentPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteAgentPolicyResponse, error) {
	rsp, err := c.DeleteAgentPolicy(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAgentPolicyResponse(rsp)
}

// AgentPolicyInfoWithResponse request returning *AgentPolicyInfoResponse
func (c *ClientWithResponses) AgentPolicyInfoWithResponse(ctx context.Context, agentPolicyId string, params *AgentPolicyInfoParams, reqEditors ...RequestEditorFn) (*AgentPolicyInfoResponse, error) {
	rsp, err := c.AgentPolicyInfo(ctx, agentPolicyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAgentPolicyInfoResponse(rsp)
}

// UpdateAgentPolicyWithBodyWithResponse request with arbitrary body returning *UpdateAgentPolicyResponse
func (c *ClientWithResponses) UpdateAgentPolicyWithBodyWithResponse(ctx context.Context, agentPolicyId string, params *UpdateAgentPolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAgentPolicyResponse, error) {
	rsp, err := c.UpdateAgentPolicyWithBody(ctx, agentPolicyId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAgentPolicyResponse(rsp)
}

func (c *ClientWithResponses) UpdateAgentPolicyWithResponse(ctx context.Context, agentPolicyId string, params *UpdateAgentPolicyParams, body UpdateAgentPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAgentPolicyResponse, error) {
	rsp, err := c.UpdateAgentPolicy(ctx, agentPolicyId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAgentPolicyResponse(rsp)
}

// GetEnrollmentApiKeysWithResponse request returning *GetEnrollmentApiKeysResponse
func (c *ClientWithResponses) GetEnrollmentApiKeysWithResponse(ctx context.Context, params *GetEnrollmentApiKeysParams, reqEditors ...RequestEditorFn) (*GetEnrollmentApiKeysResponse, error) {
	rsp, err := c.GetEnrollmentApiKeys(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEnrollmentApiKeysResponse(rsp)
}

// ListAllPackagesWithResponse request returning *ListAllPackagesResponse
func (c *ClientWithResponses) ListAllPackagesWithResponse(ctx context.Context, params *ListAllPackagesParams, reqEditors ...RequestEditorFn) (*ListAllPackagesResponse, error) {
	rsp, err := c.ListAllPackages(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAllPackagesResponse(rsp)
}

// InstallPackageByUploadWithBodyWithResponse request with arbitrary body returning *InstallPackageByUploadResponse
func (c *ClientWithResponses) InstallPackageByUploadWithBodyWithResponse(ctx context.Context, params *InstallPackageByUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InstallPackageByUploadResponse, error) {
	rsp, err := c.InstallPackageByUploadWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInstallPackageByUploadResponse(rsp)
}

// DeletePackageWithBodyWithResponse request with arbitrary body returning *DeletePackageResponse
func (c *ClientWithResponses) DeletePackageWithBodyWithResponse(ctx context.Context, pkgName string, pkgVersion string, params *DeletePackageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeletePackageResponse, error) {
	rsp, err := c.DeletePackageWithBody(ctx, pkgName, pkgVersion, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePackageResponse(rsp)
}

func (c *ClientWithResponses) DeletePackageWithResponse(ctx context.Context, pkgName string, pkgVersion string, params *DeletePackageParams, body DeletePackageJSONRequestBody, reqEditors ...RequestEditorFn) (*DeletePackageResponse, error) {
	rsp, err := c.DeletePackage(ctx, pkgName, pkgVersion, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePackageResponse(rsp)
}

// GetPackageWithResponse request returning *GetPackageResponse
func (c *ClientWithResponses) GetPackageWithResponse(ctx context.Context, pkgName string, pkgVersion string, params *GetPackageParams, reqEditors ...RequestEditorFn) (*GetPackageResponse, error) {
	rsp, err := c.GetPackage(ctx, pkgName, pkgVersion, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPackageResponse(rsp)
}

// InstallPackageWithBodyWithResponse request with arbitrary body returning *InstallPackageResponse
func (c *ClientWithResponses) InstallPackageWithBodyWithResponse(ctx context.Context, pkgName string, pkgVersion string, params *InstallPackageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InstallPackageResponse, error) {
	rsp, err := c.InstallPackageWithBody(ctx, pkgName, pkgVersion, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInstallPackageResponse(rsp)
}

func (c *ClientWithResponses) InstallPackageWithResponse(ctx context.Context, pkgName string, pkgVersion string, params *InstallPackageParams, body InstallPackageJSONRequestBody, reqEditors ...RequestEditorFn) (*InstallPackageResponse, error) {
	rsp, err := c.InstallPackage(ctx, pkgName, pkgVersion, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInstallPackageResponse(rsp)
}

// UpdatePackageWithBodyWithResponse request with arbitrary body returning *UpdatePackageResponse
func (c *ClientWithResponses) UpdatePackageWithBodyWithResponse(ctx context.Context, pkgName string, pkgVersion string, params *UpdatePackageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePackageResponse, error) {
	rsp, err := c.UpdatePackageWithBody(ctx, pkgName, pkgVersion, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePackageResponse(rsp)
}

func (c *ClientWithResponses) UpdatePackageWithResponse(ctx context.Context, pkgName string, pkgVersion string, params *UpdatePackageParams, body UpdatePackageJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePackageResponse, error) {
	rsp, err := c.UpdatePackage(ctx, pkgName, pkgVersion, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePackageResponse(rsp)
}

// GetFleetServerHostsWithResponse request returning *GetFleetServerHostsResponse
func (c *ClientWithResponses) GetFleetServerHostsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetFleetServerHostsResponse, error) {
	rsp, err := c.GetFleetServerHosts(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFleetServerHostsResponse(rsp)
}

// PostFleetServerHostsWithBodyWithResponse request with arbitrary body returning *PostFleetServerHostsResponse
func (c *ClientWithResponses) PostFleetServerHostsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFleetServerHostsResponse, error) {
	rsp, err := c.PostFleetServerHostsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFleetServerHostsResponse(rsp)
}

func (c *ClientWithResponses) PostFleetServerHostsWithResponse(ctx context.Context, body PostFleetServerHostsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFleetServerHostsResponse, error) {
	rsp, err := c.PostFleetServerHosts(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFleetServerHostsResponse(rsp)
}

// DeleteFleetServerHostsWithResponse request returning *DeleteFleetServerHostsResponse
func (c *ClientWithResponses) DeleteFleetServerHostsWithResponse(ctx context.Context, itemId string, reqEditors ...RequestEditorFn) (*DeleteFleetServerHostsResponse, error) {
	rsp, err := c.DeleteFleetServerHosts(ctx, itemId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFleetServerHostsResponse(rsp)
}

// GetOneFleetServerHostsWithResponse request returning *GetOneFleetServerHostsResponse
func (c *ClientWithResponses) GetOneFleetServerHostsWithResponse(ctx context.Context, itemId string, reqEditors ...RequestEditorFn) (*GetOneFleetServerHostsResponse, error) {
	rsp, err := c.GetOneFleetServerHosts(ctx, itemId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOneFleetServerHostsResponse(rsp)
}

// UpdateFleetServerHostsWithBodyWithResponse request with arbitrary body returning *UpdateFleetServerHostsResponse
func (c *ClientWithResponses) UpdateFleetServerHostsWithBodyWithResponse(ctx context.Context, itemId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFleetServerHostsResponse, error) {
	rsp, err := c.UpdateFleetServerHostsWithBody(ctx, itemId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFleetServerHostsResponse(rsp)
}

func (c *ClientWithResponses) UpdateFleetServerHostsWithResponse(ctx context.Context, itemId string, body UpdateFleetServerHostsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFleetServerHostsResponse, error) {
	rsp, err := c.UpdateFleetServerHosts(ctx, itemId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFleetServerHostsResponse(rsp)
}

// GetOutputsWithResponse request returning *GetOutputsResponse
func (c *ClientWithResponses) GetOutputsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOutputsResponse, error) {
	rsp, err := c.GetOutputs(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOutputsResponse(rsp)
}

// PostOutputsWithBodyWithResponse request with arbitrary body returning *PostOutputsResponse
func (c *ClientWithResponses) PostOutputsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOutputsResponse, error) {
	rsp, err := c.PostOutputsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOutputsResponse(rsp)
}

func (c *ClientWithResponses) PostOutputsWithResponse(ctx context.Context, body PostOutputsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostOutputsResponse, error) {
	rsp, err := c.PostOutputs(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOutputsResponse(rsp)
}

// DeleteOutputWithResponse request returning *DeleteOutputResponse
func (c *ClientWithResponses) DeleteOutputWithResponse(ctx context.Context, outputId string, reqEditors ...RequestEditorFn) (*DeleteOutputResponse, error) {
	rsp, err := c.DeleteOutput(ctx, outputId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOutputResponse(rsp)
}

// GetOutputWithResponse request returning *GetOutputResponse
func (c *ClientWithResponses) GetOutputWithResponse(ctx context.Context, outputId string, reqEditors ...RequestEditorFn) (*GetOutputResponse, error) {
	rsp, err := c.GetOutput(ctx, outputId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOutputResponse(rsp)
}

// UpdateOutputWithBodyWithResponse request with arbitrary body returning *UpdateOutputResponse
func (c *ClientWithResponses) UpdateOutputWithBodyWithResponse(ctx context.Context, outputId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOutputResponse, error) {
	rsp, err := c.UpdateOutputWithBody(ctx, outputId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOutputResponse(rsp)
}

func (c *ClientWithResponses) UpdateOutputWithResponse(ctx context.Context, outputId string, body UpdateOutputJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOutputResponse, error) {
	rsp, err := c.UpdateOutput(ctx, outputId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOutputResponse(rsp)
}

// GetPackagePoliciesWithResponse request returning *GetPackagePoliciesResponse
func (c *ClientWithResponses) GetPackagePoliciesWithResponse(ctx context.Context, params *GetPackagePoliciesParams, reqEditors ...RequestEditorFn) (*GetPackagePoliciesResponse, error) {
	rsp, err := c.GetPackagePolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPackagePoliciesResponse(rsp)
}

// CreatePackagePolicyWithBodyWithResponse request with arbitrary body returning *CreatePackagePolicyResponse
func (c *ClientWithResponses) CreatePackagePolicyWithBodyWithResponse(ctx context.Context, params *CreatePackagePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePackagePolicyResponse, error) {
	rsp, err := c.CreatePackagePolicyWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePackagePolicyResponse(rsp)
}

func (c *ClientWithResponses) CreatePackagePolicyWithResponse(ctx context.Context, params *CreatePackagePolicyParams, body CreatePackagePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePackagePolicyResponse, error) {
	rsp, err := c.CreatePackagePolicy(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePackagePolicyResponse(rsp)
}

// DeletePackagePolicyWithResponse request returning *DeletePackagePolicyResponse
func (c *ClientWithResponses) DeletePackagePolicyWithResponse(ctx context.Context, packagePolicyId string, params *DeletePackagePolicyParams, reqEditors ...RequestEditorFn) (*DeletePackagePolicyResponse, error) {
	rsp, err := c.DeletePackagePolicy(ctx, packagePolicyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePackagePolicyResponse(rsp)
}

// GetPackagePolicyWithResponse request returning *GetPackagePolicyResponse
func (c *ClientWithResponses) GetPackagePolicyWithResponse(ctx context.Context, packagePolicyId string, params *GetPackagePolicyParams, reqEditors ...RequestEditorFn) (*GetPackagePolicyResponse, error) {
	rsp, err := c.GetPackagePolicy(ctx, packagePolicyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPackagePolicyResponse(rsp)
}

// UpdatePackagePolicyWithBodyWithResponse request with arbitrary body returning *UpdatePackagePolicyResponse
func (c *ClientWithResponses) UpdatePackagePolicyWithBodyWithResponse(ctx context.Context, packagePolicyId string, params *UpdatePackagePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePackagePolicyResponse, error) {
	rsp, err := c.UpdatePackagePolicyWithBody(ctx, packagePolicyId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePackagePolicyResponse(rsp)
}

func (c *ClientWithResponses) UpdatePackagePolicyWithResponse(ctx context.Context, packagePolicyId string, params *UpdatePackagePolicyParams, body UpdatePackagePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePackagePolicyResponse, error) {
	rsp, err := c.UpdatePackagePolicy(ctx, packagePolicyId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePackagePolicyResponse(rsp)
}

// GenerateServiceTokenWithResponse request returning *GenerateServiceTokenResponse
func (c *ClientWithResponses) GenerateServiceTokenWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GenerateServiceTokenResponse, error) {
	rsp, err := c.GenerateServiceToken(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateServiceTokenResponse(rsp)
}

// ImportSavedObjectsDefaultWithBodyWithResponse request with arbitrary body returning *ImportSavedObjectsDefaultResponse
func (c *ClientWithResponses) ImportSavedObjectsDefaultWithBodyWithResponse(ctx context.Context, params *ImportSavedObjectsDefaultParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportSavedObjectsDefaultResponse, error) {
	rsp, err := c.ImportSavedObjectsDefaultWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportSavedObjectsDefaultResponse(rsp)
}

// FindSlosOpWithResponse request returning *FindSlosOpResponse
func (c *ClientWithResponses) FindSlosOpWithResponse(ctx context.Context, spaceId SpaceId, params *FindSlosOpParams, reqEditors ...RequestEditorFn) (*FindSlosOpResponse, error) {
	rsp, err := c.FindSlosOp(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindSlosOpResponse(rsp)
}

// CreateSloOpWithBodyWithResponse request with arbitrary body returning *CreateSloOpResponse
func (c *ClientWithResponses) CreateSloOpWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSloOpResponse, error) {
	rsp, err := c.CreateSloOpWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSloOpResponse(rsp)
}

func (c *ClientWithResponses) CreateSloOpWithResponse(ctx context.Context, spaceId SpaceId, body CreateSloOpJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSloOpResponse, error) {
	rsp, err := c.CreateSloOp(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSloOpResponse(rsp)
}

// DeleteSloOpWithResponse request returning *DeleteSloOpResponse
func (c *ClientWithResponses) DeleteSloOpWithResponse(ctx context.Context, spaceId SpaceId, sloId SloId, reqEditors ...RequestEditorFn) (*DeleteSloOpResponse, error) {
	rsp, err := c.DeleteSloOp(ctx, spaceId, sloId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSloOpResponse(rsp)
}

// GetSloOpWithResponse request returning *GetSloOpResponse
func (c *ClientWithResponses) GetSloOpWithResponse(ctx context.Context, spaceId SpaceId, sloId SloId, params *GetSloOpParams, reqEditors ...RequestEditorFn) (*GetSloOpResponse, error) {
	rsp, err := c.GetSloOp(ctx, spaceId, sloId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSloOpResponse(rsp)
}

// UpdateSloOpWithBodyWithResponse request with arbitrary body returning *UpdateSloOpResponse
func (c *ClientWithResponses) UpdateSloOpWithBodyWithResponse(ctx context.Context, spaceId SpaceId, sloId SloId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSloOpResponse, error) {
	rsp, err := c.UpdateSloOpWithBody(ctx, spaceId, sloId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSloOpResponse(rsp)
}

func (c *ClientWithResponses) UpdateSloOpWithResponse(ctx context.Context, spaceId SpaceId, sloId SloId, body UpdateSloOpJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSloOpResponse, error) {
	rsp, err := c.UpdateSloOp(ctx, spaceId, sloId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSloOpResponse(rsp)
}

// ParseDeleteConnectorDefaultResponse parses an HTTP response from a DeleteConnectorDefaultWithResponse call
func ParseDeleteConnectorDefaultResponse(rsp *http.Response) (*DeleteConnectorDefaultResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteConnectorDefaultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetConnectorDefaultResponse parses an HTTP response from a GetConnectorDefaultWithResponse call
func ParseGetConnectorDefaultResponse(rsp *http.Response) (*GetConnectorDefaultResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConnectorDefaultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetConnectorResponseObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateConnectorDefaultResponse parses an HTTP response from a CreateConnectorDefaultWithResponse call
func ParseCreateConnectorDefaultResponse(rsp *http.Response) (*CreateConnectorDefaultResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateConnectorDefaultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateConnectorResponseObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateConnectorDefaultResponse parses an HTTP response from a UpdateConnectorDefaultWithResponse call
func ParseUpdateConnectorDefaultResponse(rsp *http.Response) (*UpdateConnectorDefaultResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateConnectorDefaultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateConnectorResponseObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAllConnectorsDefaultResponse parses an HTTP response from a GetAllConnectorsDefaultWithResponse call
func ParseGetAllConnectorsDefaultResponse(rsp *http.Response) (*GetAllConnectorsDefaultResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllConnectorsDefaultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteRuleDefaultResponse parses an HTTP response from a DeleteRuleDefaultWithResponse call
func ParseDeleteRuleDefaultResponse(rsp *http.Response) (*DeleteRuleDefaultResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRuleDefaultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetRuleDefaultResponse parses an HTTP response from a GetRuleDefaultWithResponse call
func ParseGetRuleDefaultResponse(rsp *http.Response) (*GetRuleDefaultResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRuleDefaultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetRuleResponseObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateRuleDefaultResponse parses an HTTP response from a CreateRuleDefaultWithResponse call
func ParseCreateRuleDefaultResponse(rsp *http.Response) (*CreateRuleDefaultResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRuleDefaultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateRuleResponseObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateRuleDefaultResponse parses an HTTP response from a UpdateRuleDefaultWithResponse call
func ParseUpdateRuleDefaultResponse(rsp *http.Response) (*UpdateRuleDefaultResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRuleDefaultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateRuleResponseObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindRuleDefaultResponse parses an HTTP response from a FindRuleDefaultWithResponse call
func ParseFindRuleDefaultResponse(rsp *http.Response) (*FindRuleDefaultResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindRuleDefaultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FindRuleResponseObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAllDataViewsDefaultResponse parses an HTTP response from a GetAllDataViewsDefaultWithResponse call
func ParseGetAllDataViewsDefaultResponse(rsp *http.Response) (*GetAllDataViewsDefaultResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllDataViewsDefaultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetAllDataViewsResponseObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateDataViewDefaultResponse parses an HTTP response from a CreateDataViewDefaultWithResponse call
func ParseCreateDataViewDefaultResponse(rsp *http.Response) (*CreateDataViewDefaultResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDataViewDefaultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DataViewResponseObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteDataViewDefaultResponse parses an HTTP response from a DeleteDataViewDefaultWithResponse call
func ParseDeleteDataViewDefaultResponse(rsp *http.Response) (*DeleteDataViewDefaultResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDataViewDefaultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetDataViewDefaultResponse parses an HTTP response from a GetDataViewDefaultWithResponse call
func ParseGetDataViewDefaultResponse(rsp *http.Response) (*GetDataViewDefaultResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDataViewDefaultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DataViewResponseObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateDataViewDefaultResponse parses an HTTP response from a UpdateDataViewDefaultWithResponse call
func ParseUpdateDataViewDefaultResponse(rsp *http.Response) (*UpdateDataViewDefaultResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateDataViewDefaultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DataViewResponseObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAgentPolicyListResponse parses an HTTP response from a AgentPolicyListWithResponse call
func ParseAgentPolicyListResponse(rsp *http.Response) (*AgentPolicyListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AgentPolicyListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AgentPolicyListResponseObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateAgentPolicyResponse parses an HTTP response from a CreateAgentPolicyWithResponse call
func ParseCreateAgentPolicyResponse(rsp *http.Response) (*CreateAgentPolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAgentPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateAgentPolicyResponseObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteAgentPolicyResponse parses an HTTP response from a DeleteAgentPolicyWithResponse call
func ParseDeleteAgentPolicyResponse(rsp *http.Response) (*DeleteAgentPolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAgentPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeleteAgentPolicyResponseObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAgentPolicyInfoResponse parses an HTTP response from a AgentPolicyInfoWithResponse call
func ParseAgentPolicyInfoResponse(rsp *http.Response) (*AgentPolicyInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AgentPolicyInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AgentPolicyInfoResponseObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateAgentPolicyResponse parses an HTTP response from a UpdateAgentPolicyWithResponse call
func ParseUpdateAgentPolicyResponse(rsp *http.Response) (*UpdateAgentPolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAgentPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateAgentPolicyResponseObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetEnrollmentApiKeysResponse parses an HTTP response from a GetEnrollmentApiKeysWithResponse call
func ParseGetEnrollmentApiKeysResponse(rsp *http.Response) (*GetEnrollmentApiKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEnrollmentApiKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetEnrollmentApiKeysResponseObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListAllPackagesResponse parses an HTTP response from a ListAllPackagesWithResponse call
func ParseListAllPackagesResponse(rsp *http.Response) (*ListAllPackagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAllPackagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPackagesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseInstallPackageByUploadResponse parses an HTTP response from a InstallPackageByUploadWithResponse call
func ParseInstallPackageByUploadResponse(rsp *http.Response) (*InstallPackageByUploadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InstallPackageByUploadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InstallPackageByUploadResponseObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeletePackageResponse parses an HTTP response from a DeletePackageWithResponse call
func ParseDeletePackageResponse(rsp *http.Response) (*DeletePackageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePackageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeletePackageResponseObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPackageResponse parses an HTTP response from a GetPackageWithResponse call
func ParseGetPackageResponse(rsp *http.Response) (*GetPackageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPackageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPackageResponseObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseInstallPackageResponse parses an HTTP response from a InstallPackageWithResponse call
func ParseInstallPackageResponse(rsp *http.Response) (*InstallPackageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InstallPackageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InstallPackageResponseObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdatePackageResponse parses an HTTP response from a UpdatePackageWithResponse call
func ParseUpdatePackageResponse(rsp *http.Response) (*UpdatePackageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePackageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdatePackageResponseObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFleetServerHostsResponse parses an HTTP response from a GetFleetServerHostsWithResponse call
func ParseGetFleetServerHostsResponse(rsp *http.Response) (*GetFleetServerHostsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFleetServerHostsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetFleetServerHostsResponseObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostFleetServerHostsResponse parses an HTTP response from a PostFleetServerHostsWithResponse call
func ParsePostFleetServerHostsResponse(rsp *http.Response) (*PostFleetServerHostsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostFleetServerHostsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostFleetServerHostsResponseObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteFleetServerHostsResponse parses an HTTP response from a DeleteFleetServerHostsWithResponse call
func ParseDeleteFleetServerHostsResponse(rsp *http.Response) (*DeleteFleetServerHostsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFleetServerHostsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeleteFleetServerHostsResponseObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetOneFleetServerHostsResponse parses an HTTP response from a GetOneFleetServerHostsWithResponse call
func ParseGetOneFleetServerHostsResponse(rsp *http.Response) (*GetOneFleetServerHostsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOneFleetServerHostsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetOneFleetServerHostsResponseObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateFleetServerHostsResponse parses an HTTP response from a UpdateFleetServerHostsWithResponse call
func ParseUpdateFleetServerHostsResponse(rsp *http.Response) (*UpdateFleetServerHostsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateFleetServerHostsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateFleetServerHostsResponseObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetOutputsResponse parses an HTTP response from a GetOutputsWithResponse call
func ParseGetOutputsResponse(rsp *http.Response) (*GetOutputsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOutputsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetOutputsResponseObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostOutputsResponse parses an HTTP response from a PostOutputsWithResponse call
func ParsePostOutputsResponse(rsp *http.Response) (*PostOutputsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOutputsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostOutputsResponseObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteOutputResponse parses an HTTP response from a DeleteOutputWithResponse call
func ParseDeleteOutputResponse(rsp *http.Response) (*DeleteOutputResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOutputResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeleteOutputResponseObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetOutputResponse parses an HTTP response from a GetOutputWithResponse call
func ParseGetOutputResponse(rsp *http.Response) (*GetOutputResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOutputResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetOutputResponseObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateOutputResponse parses an HTTP response from a UpdateOutputWithResponse call
func ParseUpdateOutputResponse(rsp *http.Response) (*UpdateOutputResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateOutputResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateOutputResponseObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPackagePoliciesResponse parses an HTTP response from a GetPackagePoliciesWithResponse call
func ParseGetPackagePoliciesResponse(rsp *http.Response) (*GetPackagePoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPackagePoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPackagePoliciesResponseObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreatePackagePolicyResponse parses an HTTP response from a CreatePackagePolicyWithResponse call
func ParseCreatePackagePolicyResponse(rsp *http.Response) (*CreatePackagePolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePackagePolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreatePackagePolicyResponseObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeletePackagePolicyResponse parses an HTTP response from a DeletePackagePolicyWithResponse call
func ParseDeletePackagePolicyResponse(rsp *http.Response) (*DeletePackagePolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePackagePolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeletePackagePolicyResponseObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPackagePolicyResponse parses an HTTP response from a GetPackagePolicyWithResponse call
func ParseGetPackagePolicyResponse(rsp *http.Response) (*GetPackagePolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPackagePolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPackagePolicyResponseObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdatePackagePolicyResponse parses an HTTP response from a UpdatePackagePolicyWithResponse call
func ParseUpdatePackagePolicyResponse(rsp *http.Response) (*UpdatePackagePolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePackagePolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdatePackagePolicyResponseObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGenerateServiceTokenResponse parses an HTTP response from a GenerateServiceTokenWithResponse call
func ParseGenerateServiceTokenResponse(rsp *http.Response) (*GenerateServiceTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenerateServiceTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GenerateServiceTokenResponseObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseImportSavedObjectsDefaultResponse parses an HTTP response from a ImportSavedObjectsDefaultWithResponse call
func ParseImportSavedObjectsDefaultResponse(rsp *http.Response) (*ImportSavedObjectsDefaultResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ImportSavedObjectsDefaultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ImportSavedObjectsResponseObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFindSlosOpResponse parses an HTTP response from a FindSlosOpWithResponse call
func ParseFindSlosOpResponse(rsp *http.Response) (*FindSlosOpResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindSlosOpResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FindSloResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateSloOpResponse parses an HTTP response from a CreateSloOpWithResponse call
func ParseCreateSloOpResponse(rsp *http.Response) (*CreateSloOpResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSloOpResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateSloResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteSloOpResponse parses an HTTP response from a DeleteSloOpWithResponse call
func ParseDeleteSloOpResponse(rsp *http.Response) (*DeleteSloOpResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSloOpResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSloOpResponse parses an HTTP response from a GetSloOpWithResponse call
func ParseGetSloOpResponse(rsp *http.Response) (*GetSloOpResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSloOpResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SloWithSummaryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateSloOpResponse parses an HTTP response from a UpdateSloOpWithResponse call
func ParseUpdateSloOpResponse(rsp *http.Response) (*UpdateSloOpResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSloOpResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SloDefinitionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
